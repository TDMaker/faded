<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://faded.auspicious.space</id>
    <title>Typhoeus</title>
    <updated>2020-04-18T12:56:26.192Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://faded.auspicious.space"/>
    <link rel="self" href="https://faded.auspicious.space/atom.xml"/>
    <logo>https://faded.auspicious.space/images/avatar.png</logo>
    <icon>https://faded.auspicious.space/favicon.ico</icon>
    <rights>All rights reserved 2020, Typhoeus</rights>
    <entry>
        <title type="html"><![CDATA[如何优雅地链式取值]]></title>
        <id>https://faded.auspicious.space/post/how-to-elegantly-optional-chaining/</id>
        <link href="https://faded.auspicious.space/post/how-to-elegantly-optional-chaining/">
        </link>
        <updated>2020-04-18T06:26:57.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p><a href="https://juejin.im/post/5ba08483e51d450e99430a7f">如何优雅地链式取值</a></p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p><a href="https://juejin.im/post/5ba08483e51d450e99430a7f">如何优雅地链式取值</a></p>
</blockquote>
<!-- more -->
<p>开发中，链式取值是非常正常的操作，如：</p>
<pre><code class="language-javascript">res.data.goods.list[0].price
</code></pre>
<p>但是对于这种操作报出类似于 <code>Uncaught TypeError: Cannot read property 'goods' of undefined</code> 这种错误也是再正常不过了，如果说是 <code>res</code> 数据是自己定义，那么可控性会大一些，但是如果这些数据来自于不同端（如前后端），那么这种数据对于我们来说我们都是不可控的，因此为了保证程序能够正常运行下去，我们需要对此校验：</p>
<pre><code class="language-javascript">if (res.data.goods.list[0] &amp;&amp; res.data.goods.list[0].price) {
// your code
}
</code></pre>
<p>如果再精细一点，对于所有都进行校验的话，就会像这样：</p>
<pre><code class="language-javascript">if (res &amp;&amp; res.data &amp;&amp; res.data.goods &amp;&amp; res.data.goods.list &amp;&amp; res.data.goods.list[0] &amp;&amp; res.data.goods.list[0].price){
// your code
}
</code></pre>
<p>不敢想象，如果数据的层级再深一点会怎样，这种实现实在是非常不优雅，那么如果优雅地来实现链式取值呢？</p>
<h1 id="optional-chaining">optional chaining</h1>
<p>这是一个出于 stage 2 的 ecma 新语法，目前已经有了 babel 的插件 <code>babel-plugin-transform-optional-chaining</code>，这种语法在 <code>swift</code> 中有，可以看下官方给的实例：</p>
<pre><code class="language-javascript">a?.b                          // undefined if `a` is null/undefined, `a.b` otherwise.
a == null ? undefined : a.b

a?.[x]                        // undefined if `a` is null/undefined, `a[x]` otherwise.
a == null ? undefined : a[x]

a?.b()                        // undefined if `a` is null/undefined
a == null ? undefined : a.b() // throws a TypeError if `a.b` is not a function
                              // otherwise, evaluates to `a.b()`

a?.()                        // undefined if `a` is null/undefined
a == null ? undefined : a()  // throws a TypeError if `a` is neither null/undefined, nor a function
                             // invokes the function `a` otherwise
</code></pre>
<h1 id="通过函数解析字符串">通过函数解析字符串</h1>
<p>我们可以通过函数解析字符串来解决这个问题，这种实现就是 <code>lodash</code> 的 <code>_.get</code> 方法。</p>
<pre><code class="language-javascript">var object = { a: [{ b: { c: 3 } }] };
var result = _.get(object, 'a[0].b.c', 1);
console.log(result);
// output: 3
</code></pre>
<p>实现起来也非常简单，只是简单的字符串解析而已：</p>
<pre><code class="language-javascript">function get (obj, props, def) {
    if((obj == null) || obj == null || typeof props !== 'string') return def;
    const temp = props.split('.');
    const fieldArr = [].concat(temp);
    temp.forEach((e, i) =&gt; {
        if(/^(\w+)\[(\w+)\]$/.test(e)) {
            const matchs = e.match(/^(\w+)\[(\w+)\]$/);
            const field1 = matchs[1];
            const field2 = matchs[2];
            const index = fieldArr.indexOf(e);
            fieldArr.splice(index, 1, field1, field2);
        }
    })
    return fieldArr.reduce((pre, cur) =&gt; {
        const target = pre[cur] || def;

        if(target instanceof Array) {
            return [].concat(target);
        }
        if(target instanceof Object) {
            return Object.assign({}, target)
        }
        return target;
    }, obj)
}
</code></pre>
<pre><code class="language-javascript">var c = {a: {b : [1,2,3] }}
get(c ,'a.b')     // [1,2,3]
get(c, 'a.b[1]')  // 2
get(c, 'a.d', 12)  // 12
</code></pre>
<h1 id="使用解构赋值">使用解构赋值</h1>
<p>这个思路是来自 github 上 <a href="https://github.com/you-dont-need/You-Dont-Need-Lodash-Underscore">You-Dont-Need-Lodash-Underscore</a> 这个仓库，看到这个的时候真的佩服。</p>
<pre><code class="language-javascript">const c = {a:{b: [1,2,3,4]}}

const { a: result } = c;
// result : {b: [1,2,3,4]}
const {a: { c: result = 12 }} = c
// result: 12
</code></pre>
<p>当然，这个时候为了保证不报 <code>uncaught Typeerror</code>，我们仍然需要定义默认值， 就像这样, 貌似如果不加 <code>lint</code> 可读性堪忧。</p>
<pre><code class="language-javascript">const {a: {c: {d: result2} = {}}} = c
</code></pre>
<h1 id="使用-proxy">使用 Proxy</h1>
<p>这个是组内同事提到的，一个简单实现如下：</p>
<pre><code class="language-javascript">function pointer(obj, path = []) {
    return new Proxy(() =&gt; {}, {
        get (target, property) {
            return pointer(obj, path.concat(property))
        },
        apply (target, self, args) {
            let val = obj;
            let parent;
            for(let i = 0; i &lt; path.length; i++) {
                if(val === null || val === undefined) break;
                parent = val;
                val = val[path[i]]    
            }
            if(val === null || val === undefined) {
                val = args[0]
            }
            return val;
        }
    })
}
</code></pre>
<p>我们可以这样使用：</p>
<pre><code class="language-javascript">let c = {a: {b: [1, ,2 ,3]}}

pointer(c).a();   // {b: [1,2,3]}

pointer(c).a.b(); // [1,2,3]

pointer(d).a.b.d('default value');  // default value
</code></pre>
<p>这差不多就是心中所谓的优雅了。</p>
<p>综上，在实际工作中，使用方法四会是最优雅，可读性也非常强，但考虑到浏览器的话，可能方法二会更加常用，当然，如果你所要取的值层级不是太深，你组内的同事要严格的 <code>lint</code>，方法三也不失为一种好的选择。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[& * # 这三个是什么符号？]]></title>
        <id>https://faded.auspicious.space/post/names-of-three-sign/</id>
        <link href="https://faded.auspicious.space/post/names-of-three-sign/">
        </link>
        <updated>2020-04-18T06:17:34.000Z</updated>
        <content type="html"><![CDATA[<p><code>&amp;</code> 这个符号的名字是 ampersand，含义就是“and”。听到这个词，要意识到老师在说啥。<br>
<code>*</code> 这个符号的名是 asterisk，一种符号，在文章中一般表示，底下有脚注。<br>
<code>#</code> 这个符号的名字是 hash，是不是很难受的感觉，在英文里的意思是表示数字，比如我家住 18 号 401，写地址可以写成 #18, 401，另外在美国还用于表示磅这个重量单位，比如 2# of sugar，大概两斤糖；<br>
<code>～</code> 这个符号的名字最难找，叫 tilde，从西班牙语或者葡萄牙语过来的名字，参看维基百科；<br>
<code>`</code> 这个符号，我一般念做 back tick，不过我也没查到，我看百科里叫 back quote；<br>
<code>^</code> 这个符号，叫 caret，在 ASCII 里面是一个Space Symbol。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[TCP——套接口编程]]></title>
        <id>https://faded.auspicious.space/post/tcp-suite-programming/</id>
        <link href="https://faded.auspicious.space/post/tcp-suite-programming/">
        </link>
        <updated>2020-04-18T04:29:36.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p><a href="https://juejin.im/post/5bc01a34f265da0ac446ce96">值得收藏的TCP套接口编程文章</a></p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p><a href="https://juejin.im/post/5bc01a34f265da0ac446ce96">值得收藏的TCP套接口编程文章</a></p>
</blockquote>
<!-- more -->
<h1 id="tcp-客户端-服务器典型事件">TCP 客户端-服务器典型事件</h1>
<p>下图是 TCP 客户端与服务器之间交互的一系列典型事件时间表：</p>
<ol>
<li>首先启动服务器，等待客户端连接。</li>
<li>启动客户端，连接到服务器。</li>
<li>客户端发送一个请求给服务器，服务器处理请求，响应客户端。</li>
<li>循环步骤3。</li>
<li>客户端给服务器发一个文件结束符，关闭客户端连接。</li>
<li>服务器也关闭连接。</li>
</ol>
<figure data-type="image" tabindex="1"><img src="https://faded.auspicious.space/post-images/1587184330372.png" alt="基本TCP客户-服务器程序的套接口函数" loading="lazy"></figure>
<h1 id="套接口编程基本函数">套接口编程基本函数</h1>
<h2 id="socket-函数">socket 函数</h2>
<p>为了执行网络 I/O，一个进程（无论是服务端还是客户端）必须做的第一件事情就是调用 <code>socket</code> 函数。</p>
<pre><code class="language-c">#include &lt;sys/socket.h&gt; /* basic socket definitions */
int socket(int family, int type, int protocol);/* 返回：非负描述字——成功，-1——出错 */
</code></pre>
<h3 id="family协议族">family——协议族</h3>
<table>
<thead>
<tr>
<th>族</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>AF_INET</td>
<td>IPv4 协议</td>
</tr>
<tr>
<td>AF_INET6</td>
<td>IPv6 协议</td>
</tr>
<tr>
<td>AF_LOCAL</td>
<td>Unix 域协议</td>
</tr>
<tr>
<td>AF_ROUTE</td>
<td>路由套接口</td>
</tr>
<tr>
<td>AF_KEY</td>
<td>密钥套接口</td>
</tr>
</tbody>
</table>
<h3 id="type套接口类型">type——套接口类型</h3>
<table>
<thead>
<tr>
<th>类型</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>SOCK_STREAM</td>
<td>字节流套接口</td>
</tr>
<tr>
<td>SOCK_DGRAM</td>
<td>数据报套接口</td>
</tr>
<tr>
<td>SOCK_RAW</td>
<td>原始套接口</td>
</tr>
</tbody>
</table>
<h3 id="有效的-family-和-type-组合简略版">有效的 family 和 type 组合（简略版）</h3>
<table>
<thead>
<tr>
<th></th>
<th>AF_INET</th>
<th>AF_INET6</th>
</tr>
</thead>
<tbody>
<tr>
<td>SOCK_STREAM</td>
<td>TCP</td>
<td>TCP</td>
</tr>
<tr>
<td>SOCK_DGRAM</td>
<td>UDP</td>
<td>UDP</td>
</tr>
<tr>
<td>SOCK_RAW</td>
<td>IPv4</td>
<td>IPv6</td>
</tr>
</tbody>
</table>
<p><code>socket</code> 函数返回一个套接口描述字，简称套接字（<code>sockfd</code>）。获取套接字无需指定地址，只需要指定协议族和套接口类型（如上表中的组合）。</p>
<h2 id="connect-函数">connect 函数</h2>
<p>TCP 客户用 <code>connect</code> 函数来建立一个与 TCP 服务器的连接。</p>
<pre><code class="language-c">#include &lt;sys/socket.h&gt; /* basic socket definitions */
int connect(int sockfd, const struct sockaddr * servaddr, socklen_t addrlen);/* 返回：0——成功，-1——出错 */
</code></pre>
<ul>
<li>参数 <code>sockfd</code> 便是 <code>socket</code> 函数返回的套接口描述字。</li>
<li>套接口地址结构 <code>servaddr</code> 必须包含服务器的 IP 地址和端口号。</li>
<li>客户端不必非要绑定一个端口（调用 <code>bind</code> 函数），内核会选择源 IP 和一个临时端口。</li>
<li><code>connect</code> 函数会触发 TCP 三次握手。有可能出现下面的错误情况：
<ol>
<li>
<p>客户端未收到 <code>SYN</code> 分节的响应：<br>
第一次发出未收到，间隔 6s 再发一次，再没收到，隔 24s 再发一次，总共等待 75s 还没收到则返回错误（<code>ETIMEDOUT</code>）。可以用时间日期程序验证一下：</p>
<p>查看本地网络信息：</p>
<pre><code class="language-bash">
JACKIELUO-MC0:intro jackieluo$ ifconfig
en0: flags=8863&lt;UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
ether f4:0f:24:2a:72:a6
inet6 fe80::1830:dbd:1b29:2989%en0 prefixlen 64 secured scopeid 0x6
inet 192.168.0.101 netmask 0xffffff00 broadcast 192.168.0.255
nd6 options=201&lt;PERFORMNUD,DAD&gt;
media: autoselect
status: active
</code></pre>
<p>将程序指向本地地址 <code>192.168.0.101</code>（确保时间日期服务器程序已运行），成功：</p>
<pre><code class="language-bash">
JACKIELUO-MC0:intro jackieluo$ ./daytimetcpcli 192.168.0.101
Sat Oct  6 17:06:55 2018
</code></pre>
<p>将程序指向本地子网地址 <code>192.168.0.102</code>，其主机ID（102）不存在，等待几分钟后超时返回：</p>
<pre><code class="language-bash">
JACKIELUO-MC0:intro jackieluo$ ./daytimetcpcli 192.168.0.102
connect error: Operation timed out
</code></pre>
</li>
<li>
<p>收到 <code>RST</code>：<br>
即服务器主机在指定端口上没有等待连接的进程，这称为“<code>hard error</code>”，客户端一接收到 <code>RST</code>，马上返回错误（<code>ECONNREFUSED</code>）。验证：</p>
<p>关闭之前本机运行的 <code>daytimetcpsrv</code> 进程</p>
<p>将程序指向本地地址<code>192.168.0.101</code>：</p>
<pre><code class="language-bash">
JACKIELUO-MC0:intro jackieluo$ ./daytimetcpcli 192.168.0.101
connect error: Connection refused
</code></pre>
</li>
<li>
<p>发出的 <code>SYN</code> 在路由器上引发了目的不可达 <code>ICMP</code> 错误：<br>
这个错误被称为“<code>soft error</code>”，最终返回 <code>EHOSTUNREACH</code> 或者 <code>ENETUNREACH</code>。</p>
</li>
</ol>
</li>
</ul>
<h2 id="bind-函数">bind 函数</h2>
<p>函数 <code>bind</code> 为套接口分配一个本地协议地址，包括 IP 地址和端口号。</p>
<pre><code class="language-c">#include &lt;sys/socket.h&gt; /* basic socket definitions */
int bind(int sockfd, const struct sockaddr * servaddr, socklen_t addrlen);/* 返回：0——成功，-1——出错 */
</code></pre>
<ul>
<li>客户端可以不调用这个函数，由内核选择一个本地 IP 的临时端口就好。</li>
<li>服务器一般都会调用 <code>bind</code> 函数绑定 IP 地址和端口，供客户端调用。一个例外是 RPC（远程过程调用）服务器，它由内核为其选择临时端口。然后通过 RPC 端口映射器进行注册，客户端与该服务器连接之前，先通过端口映射器获取服务器的端口。</li>
<li>进程可以把一个特定的 IP 地址捆绑到它的套接口上。对于客户端，它发送的请求，源IP地址就是这个地址；对于服务器，如果绑定了 IP 地址，则只接受目的地为此 IP 地址的客户连接。</li>
<li>如果服务器不把 IP 地址绑定到套接口上，那么内核把客户端发送 <code>SYN</code> 所在分组的目的 IP 地址作为服务器的源 IP 地址。（即服务器收到 <code>SYN</code> 的 IP）</li>
</ul>
<p>给函数 <code>bind</code> 指定用于捆绑的 IP 地址和 / 或端口号的结果：</p>
<table>
<thead>
<tr>
<th>IP地址</th>
<th>端口</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>0</td>
<td>内核选择 IP 地址和端口</td>
</tr>
<tr>
<td></td>
<td>非 0</td>
<td>内核选择 IP 地址，进程指定端口</td>
</tr>
<tr>
<td>本地 IP 地址</td>
<td>0</td>
<td>进程选择 IP 地址，内核指定端口</td>
</tr>
<tr>
<td>本地 IP 地址</td>
<td>非 0</td>
<td>进程选择 IP 地址和端口</td>
</tr>
</tbody>
</table>
<h2 id="listen-函数">listen 函数</h2>
<p>函数 <code>listen</code> 仅被 TCP 服务器调用。</p>
<pre><code class="language-c">#include &lt;sys/socket.h&gt; /* basic socket definitions */
int listen(int sockfd, int backlog);/* 返回：0——成功，-1——出错 */
</code></pre>
<p>调用函数 <code>socket</code> 函数创建的套接口，默认是主动方，下一步应是调用 <code>connect</code>，<code>CLOSED</code> 的下一个状态是 <code>SYN_SENT</code>（见 TCP 状态转换图）。而函数 <code>listen</code> 将套接口转换成被动方，告诉内核，应接受指向此套接口的连接请求，<code>CLOSED</code> 状态变成 <code>LISTEN</code>。</p>
<p>函数 <code>listen</code> 的第二个参数 <code>backlog</code> 表示内核为此套接口排队的最大连接数。对于给定的监听套接口，内核会维护两个队列：</p>
<ol>
<li>未完成连接队列（incomplete connection queue）<code>SYN</code> 分节已由客户发出，到达服务器，正在进行 TCP 的三路握手。此时这些套接口处于 <code>SYN_RCVD</code> 状态。</li>
<li>已完成连接队列（completed connection queue）<code>SYN</code> 分节已由客户发出，到达服务器，并且已完成三路握手。此时这些套接口处于 <code>ESTABLISHED</code> 状态。</li>
<li>当来自客户的 <code>SYN</code> 到达时，TCP 在未完成连接队列中创建一个新条目，直到三路握手中，第三个分节（客户对服务 <code>SYN</code> 的 <code>ACK</code>）到达，这个条目移到已完成连接队列的队尾。</li>
<li>当进程调用 <code>accept</code> 函数时，已完成连接队列的头部条目返回给进程。</li>
<li>两个队列之和不能超过 <code>backlog</code>。</li>
<li>当一个客户 <code>SYN</code> 到达时，若这两个队列都是满的，TCP 就忽略此分节，且不发送 <code>RST</code>。客户 TCP 将重发 <code>SYN</code>，期望不久就能在队列中找到空闲位置。<br>
<img src="https://faded.auspicious.space/post-images/1587185907119.png" alt="" loading="lazy"><br>
TCP 为监听套接口维护的两个队列。</li>
</ol>
<h2 id="accept-函数">accept 函数</h2>
<p>函数 <code>accept</code> 由 TCP 服务器调用，从已完成连接队列头部返回下一个已完成连接，若该队列为空，则进程睡眠（假定套接口为默认的阻塞方式）。</p>
<pre><code class="language-c">#include &lt;sys/socket.h&gt; /* basic socket definitions */
int accept(int sockfd, struct sockaddr *cliaddr, socklen_t *addrlen);/* 返回：非负描述字——成功，-1——出错 */
</code></pre>
<p>函数 <code>accept</code> 的第一个参数和返回值都是套接口描述字。其中，</p>
<ol>
<li>第一个参数，称为监听套接口描述字，即由函数 <code>socket</code> 返回，也用于 <code>bind</code>，<code>listen</code> 的第一个参数。</li>
<li>返回值，称为已连接套接口描述字。</li>
</ol>
<p>通常一个服务器，只生成一个监听套接口描述字，直到其关闭。而内核为每个被接受的客户连接，创建一个已连接套接口，当客户连接完成时，关闭该已连接套接口。</p>
<p>注意到 <code>intro/daytimetcpsrv.c</code> 中，后两个参数传的都是空指针，这是因为我们不关注客户的身份，无需知道客户的协议地址。</p>
<pre><code class="language-c">connfd = Accept(listenfd, (SA *) NULL, NULL);
</code></pre>
<p>稍作修改，不再传入空指针，见 <code>intro/daytimetcpsrv1.c</code>：</p>
<pre><code class="language-c">socklen_t len;
struct sockaddr_in servaddr, cliaddr;
...
connfd = Accept(listenfd, (SA *) &amp;cliaddr, &amp;len);
printf(&quot;connection from %s, port %d\n&quot;,
    Inet_ntop(AF_INET, &amp;cliaddr.sin_addr, buff, sizeof(buff)),
    ntohs(cliaddr.sin_port));
</code></pre>
<p>kill 掉之前的 <code>daytimetcpsrv</code> 进程：</p>
<pre><code class="language-bash">
$ sudo lsof -i -P | grep -i &quot;listen&quot;
daytimetc 80986           root    3u  IPv4 0xae12d925e4528793      0t0    TCP *:13 (LISTEN)
$ sudo kill -9 80986
</code></pre>
<p>编译运行新的服务端程序：</p>
<pre><code class="language-bash">
$ make daytimetcpsrv1.c daytimetcpsrv1
$ ./daytimetcpsrv1
</code></pre>
<p>重复执行客户端程序，发几个请求：</p>
<pre><code class="language-bash">
$ ./daytimetcpcli 127.0.0.1
Wed Sep 26 14:11:20 2018
$ ./daytimetcpcli 127.0.0.1
Wed Sep 26 14:17:06 2018
</code></pre>
<p>查看服务端打印：</p>
<pre><code class="language-bash">
connection from 127.0.0.1, port 58201
connection from 127.0.0.1, port 58342
</code></pre>
<p>注意到，由于客户端程序没有调用 <code>bind</code> 函数，内核为它的协议地址选择了源 <code>ip</code> 作为 IP 地址，临时端口号也发生了变化。</p>
<h2 id="fork-和-exec-函数">fork 和 exec 函数</h2>
<pre><code class="language-c">#include &lt;unistd.h&gt;
pid_t fork(void);/* 返回：在子进程中为0，在父进程中为子进程ID，-1——出错 */
</code></pre>
<p><code>fork</code> 函数调用一次，却返回两次。</p>
<ol>
<li>在调用它的进程（即父进程），它返回一次，返回值是派生出来的子进程的进程 ID。 父进程可能有很多子进程，必须通过返回值跟踪记录子进程 ID。</li>
<li>在子进程，它还返回一次，返回值为 0。 子进程只有一个父进程，总可以通过 <code>getppid</code> 来得到父进程的 ID。</li>
</ol>
<p>通过返回值可以判断当前进程是子进程还是父进程。</p>
<p>父进程在调用 <code>fork</code> 之前打开的所有描述字在函数 <code>fork</code> 返回后都是共享的。网络服务器会利用这一特性：</p>
<ol>
<li>父进程调用 <code>accept</code>。</li>
<li>父进程调用 <code>fork</code>，已连接套接口就在父进程与子进程间共享。（一般来说就是子进程读、写已连接套接口，而父进程关闭已连接套接口）。</li>
</ol>
<p><code>fork</code> 有两个典型应用：</p>
<ol>
<li>一个进程为自己派生一个拷贝，并发执行任务，这也是典型的并发网络服务器模型。</li>
<li>一个进程想执行其他的程序，于是调用 <code>fork</code> 生成一个拷贝，利用子进程调用 <code>exec</code> 来执行新的程序。典型应用是 <code>shell</code>。</li>
</ol>
<p>以文件形式存储在硬盘上的可执行程序若要被执行，需要由一个现有进程调用 <code>exec</code> 函数。我们将调用 <code>exec</code> 的进程称为调用进程，新程序的进程 ID 并不改变，仍处于当前进程。</p>
<h1 id="小结">小结</h1>
<p>客户和服务器，从调用 <code>socket</code> 开始，返回一个套接口描述字。客户调用 <code>connect</code>，服务器调用 <code>bind</code>、<code>listen</code>、<code>accept</code>。最后套接口由 <code>close</code> 关闭。</p>
<p>多数 TCP 服务器是调用 <code>fork</code> 来实现并发处理多客户请求的。多数 UDP 服务器则是迭代的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Git——超详实教程与命令大全]]></title>
        <id>https://faded.auspicious.space/post/git-super-detailed-tutorials-and-commands/</id>
        <link href="https://faded.auspicious.space/post/git-super-detailed-tutorials-and-commands/">
        </link>
        <updated>2020-04-17T04:05:39.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p><a href="https://juejin.im/post/5bd2a0d8e51d457a4e0d4fd5">超详实Git简明教程与命令大全</a></p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p><a href="https://juejin.im/post/5bd2a0d8e51d457a4e0d4fd5">超详实Git简明教程与命令大全</a></p>
</blockquote>
<!-- more -->
<p><a href="https://git-scm.com/">Git</a>（wiki: <a href="https://en.wikipedia.org/wiki/Git">en</a>  <a href="https://zh.wikipedia.org/wiki/Git">chs</a> ）是一个免费开源的分布式版本控制系统，由 <code>Linux</code> 内核作者 Linus Torvalds 开发，大型开源项目 Linux Kernel、Android、Chromium、Mono、DotNet、UE4 等都使用 Git 管理项目著名 github 网站使用 Git 托管所有项目代码，Git 的代码也托管在 github 上，链接为：<a href="github.com/git">github.com/git</a> 与集中式版本控制系统（开源软件：SVN；免费软件：CVS；商业软件：微软的 VSS、IBM 的 Rational ClearCase）相比。</p>
<p><strong>Git 优点</strong>：</p>
<ol>
<li>本地是版本库的完整镜像，因此支持离线工作；</li>
<li>绝大多数操作都只需要访问本地文件和资源，而且与每个提交都是所有文件的完整副本，因此速度非常快；</li>
<li>强大快捷的分支功能，非常适合非线性开发过程。</li>
</ol>
<p><strong>Git 缺点</strong>：</p>
<ol>
<li>只能全量整体，而不能以子目录和分支为单位进行更新、提交等操作；</li>
<li>子目录和分支不能单独进行权限控制；</li>
<li>由于每个提交都是所有文件的完整副本，因此更占磁盘空间。</li>
</ol>
<p><img src="https://faded.auspicious.space/post-images/1587098525528.png" alt="" loading="lazy"><br>
注：SVN 等集中式版本控制系统存储每个文件与初始化版本的差异。<br>
<img src="https://faded.auspicious.space/post-images/1587098560926.png" alt="" loading="lazy"><br>
注：Git 每个提交都是所有文件的完整副本，使得 Git 在回溯到某个提交时，不会对所有文件执行差异计算还原，因此速度会非常快。</p>
<p>这使得源代码、配置文件等更适合用 Git 来管理，而资源等较大的二进制文件则容易导致版本库体积膨胀。</p>
<p>在项目实践中，对于资源等较大的二进制文件可以采用 <a href="https://git-lfs.github.com/">Git-LFS</a> 来管理，UE4 则是使用自己开发的 GitDependencies 来管理。</p>
<h1 id="基本概念">基本概念</h1>
<ul>
<li><code>origin</code>：默认远程版本库名。</li>
<li><code>master</code>：默认分支名。</li>
<li><code>origin/master</code>：远程默认分支名。</li>
<li><code>HEAD</code>：当前分支顶端 <code>Commit</code> 的别名，即当前分支最近的一个提交的 <code>SHA-1</code> 哈希值。</li>
<li><code>ORIG_HEAD</code>：上次 <code>HEAD</code> 指针的位置。注：当执行 <code>git reset / git pull / git merge</code> 命令时，<code>git</code> 会把老的 <code>HEAD</code> 拷贝到文件 <code>.git/ORIG_HEAD</code> 中，在后续命令中可以使用 <code>ORIG_HEAD</code> 引用这个提交。</li>
<li><code>commit</code>（提交）：每个 <code>commit</code> 都是全部文件的完整快照，并用一个 <code>commitID</code>（基于文件的内容或目录结构计算出来的 40 位十六进制的 <code>SHA-1</code> 哈希值） 来唯一标志。从某个角度上来说，Git 维护的就是一个 <code>commitID</code> 有向无环图。</li>
<li><code>detached HEAD</code>：<code>HEAD</code> 没有指向任何分支的状态。一般有以下几种情况会出现这种情况：
<ol>
<li>使用 <code>checkout</code> 命令跳到某个没有分支指着的 <code>commit</code> 时；</li>
<li><code>rebase</code> 处理冲突时所处的状态；</li>
<li>切换到某个远程分支 <code>cache</code> 上时。</li>
</ol>
</li>
</ul>
<p>在 Git 中，在执行命令时，一定要清楚：你在哪？对谁执行这个命令？ 本文使用 git 版本为：<code>git version 2.13.0.windows</code></p>
<p>运行命令行建议使用：<code>git bash</code>（可通过右键菜单 <code>Git Bash here</code> 来启动），主要有3个原因：</p>
<ol>
<li>在 <code>Windows</code> 的 <code>cmd</code> 下执行 <code>git log</code> 等需要显示多页内容的命令时，会导致 <code>cmd</code> 卡死（有时按 <code>Q</code> 键也没法退出）；</li>
<li><code>git bash</code> 中可以使用 <code>MinGW</code> 中自带的 <code>Linux</code> 环境下常用的命令工具；</li>
<li><code>git bash</code> 着色做得更好，利于阅读。</li>
</ol>
<h1 id="图解常见操作">图解常见操作</h1>
<ul>
<li><code>Working Directory</code>：即工作区。操作系统层面的目录树结构，也可以理解为一个 <code>tree</code> 目录对象。</li>
<li><code>Stage(Index)</code>：即暂存区，为等待 <code>Commit</code> 的文件列表。是以扁平的文件清单实现的，不过从理解层面上也可以理解为 <code>tree</code> 目录对象。</li>
<li><code>Local Repository</code>(History)：本地版本库。有向无环图，其每一个节点都是一个 <code>tree</code> 目录对象。</li>
<li><code>Remote Repository</code>：远程版本库。有向无环图，其每一个节点都是一个 <code>tree</code>目录对象。</li>
</ul>
<p><img src="https://faded.auspicious.space/post-images/1587099496728.png" alt="" loading="lazy"><br>
注：图中 <code>git checkout -- &lt;file&gt;</code> 1、2 步骤的含义是当在暂存区中有修改时，优先使用暂存区中的修改覆盖工作区。</p>
<h1 id="svn-命令对比一览">SVN 命令对比一览</h1>
<table>
<thead>
<tr>
<th>svn</th>
<th>git</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>svn checkout</td>
<td>git clone</td>
<td>检出项目</td>
</tr>
<tr>
<td>svn update</td>
<td>git fetch<br>git pull</td>
<td>更新</td>
</tr>
<tr>
<td>svn commit</td>
<td>git commit<br>git push</td>
<td>提交</td>
</tr>
<tr>
<td>svn add</td>
<td>git add</td>
<td>添加</td>
</tr>
<tr>
<td>svn mv</td>
<td>git mv</td>
<td>移动</td>
</tr>
<tr>
<td>svn rm</td>
<td>git rm</td>
<td>删除</td>
</tr>
<tr>
<td>svn status</td>
<td>git status</td>
<td>查看状态</td>
</tr>
<tr>
<td>svn log</td>
<td>git log</td>
<td>查看 log</td>
</tr>
<tr>
<td>svn diff</td>
<td>git diff</td>
<td>查看差异</td>
</tr>
<tr>
<td>svn revert</td>
<td>git checkout<br>git reset<br>git revert</td>
<td>撤销、丢弃修改</td>
</tr>
<tr>
<td>svn copy</td>
<td>git checkout -b/-B<br>git branch</td>
<td>创建分支</td>
</tr>
<tr>
<td>svn switch</td>
<td>git checkout</td>
<td>切换分支</td>
</tr>
<tr>
<td>svn copy</td>
<td>git tag</td>
<td>创建tag</td>
</tr>
<tr>
<td>svn merge</td>
<td>git merge<br>git rebase</td>
<td>分支合并</td>
</tr>
</tbody>
</table>
<h1 id="文件存储机制">文件存储机制</h1>
<p>Git 存储使用的是一个内容寻址的文件系统，其核心部分是一个简单的键值对（<code>key-value</code>）数据库，当向数据库中插入任意类型的内容，它会返回一个 40 位十六进制的 <code>SHA-1</code> 哈希值用作索引。在版本库中，Git 维护的数据结构有：以下 4 种对象及索引，并通过保存 <code>commitID</code> 有向无环图的 <code>log</code> 日志来维护与管理项目的修订版本和历史信息。</p>
<ul>
<li><code>blob</code> — 1 个 <code>blob</code> 保存 1 个文件的 1 个版本的数据。</li>
<li><code>tree</code> — 表示 1 个目录，记录着目录里所有文件 <code>blob</code> 哈希值、文件名子目录名及其他元数据。通过递归引用其他目录树，从而建立一个包含文件和子目录的完整层次结构。</li>
<li><code>commit</code>  — 1 个提交对象保存版本库中每一次变化的元数据，每个提交对象指向一个版本的 <code>git</code> 目录树对象。</li>
<li><code>tag</code> — 分为轻量标签和附注标签。轻量标签实际上是一个特定提交的引用，附注标签是存储在 <code>git</code> 中的一个完整可被校验的对象（保存在 <code>.git/refs/tags</code> 中），还包含打标签者的名字、E-mail、日志、注释等信息。</li>
</ul>
<p><code>git</code> 使用 <code>zlib</code> 将头部信息（对象类型：<code>blob</code> 或 <code>tree</code> 或 <code>commit</code> + 1 个空格 + 数据内容长度 + 1 个空字节）和对象数据拼接一起的内容进行压缩存储成一个文件。</p>
<p>压缩的文件被十六进制的 <code>SHA-1</code> 哈希值命名，该文件可以用 <code>pigz.exe -dz &lt;文件路径&gt;</code> 来解压查看。注：Windows 版的 <code>pigz.exe</code> 可以从<a href="https://sourceforge.net/projects/pigzforwindows/">这儿</a>下载。</p>
<p>40 位十六进制的 <code>SHA-1</code> 哈希值 <code>= sha1(&quot;blob/tree/commit &quot; + filesize + &quot;\0&quot; + data)</code>， 如：<code>sha1(&quot;blob 7\0foobar\n&quot;) = &quot;323fae03f4606ea9991df8befbb2fca795e648fa&quot;</code>   注：<code>\n</code> 的二进制为 <code>0a</code>。<br>
<img src="https://faded.auspicious.space/post-images/1587100311371.png" alt="" loading="lazy"></p>
<h1 id="底层命令剖析-git-对象">底层命令—剖析 Git 对象</h1>
<ul>
<li>
<p><code>find .git/objects -type f</code> // 用 <code>find</code> 命令查看 <code>.git/objects</code> 目录（递归子目录）中的所有文件。</p>
</li>
<li>
<p><code>git rev-list --objects --all</code> // 查看所有 <code>git</code> 对象的 <code>SHA-1</code> 哈希值与文件名的对应关系。</p>
</li>
<li>
<p><code>git rev-list --objects --all | grep 83c4fbc43a6f187d4e8a247a1c9aced872b2315d</code> // 查看 <code>SHA-1</code> 哈希值为 <code>83c4fbc43a6f187d4e8a247a1c9aced872b2315d</code> 的文件名。</p>
</li>
<li>
<p><code>echo &quot;Hello World!&quot; | git hash-object --stdin</code> // 计算内容为 <code>Hello World!</code> 文件的 <code>SHA-1</code> 哈希值。</p>
</li>
<li>
<p><code>echo &quot;Hello World!&quot; | git hash-object -w --stdin</code> // 计算内容为 <code>Hello World!</code> 文件的 <code>SHA-1</code> 哈希值并写入到当前 <code>git</code> 本地版本库中。</p>
</li>
<li>
<p><code>git hash-object README.txt</code> // 查看 <code>README.txt</code> 的 <code>SHA-1</code> 哈希值。</p>
</li>
<li>
<p><code>git hash-object -w README.txt</code> // 查看 <code>README.txt</code> 的 <code>SHA-1</code> 哈希值并写入到当前 <code>git</code> 本地版本库中。</p>
</li>
<li>
<p><code>git cat-file -p master^^{tree}</code> // 查看 <code>master</code> 分支 <code>HEAD</code> 指针 <code>git</code> 目录（<code>tree</code> 对象）下的各子目录（<code>tree</code> 对象）和文件（<code>blob</code> 对象）的 <code>SHA-1</code> 哈希值。</p>
<pre><code class="language-bash">100644 blob 7abd3a56703ad4a7120571967f5d06607b5e5502 README.txt
040000 tree 9f448c40e684dc38109574007c661277c815fb7e ss
</code></pre>
<p>注：<code>040000</code>：表示目录；<code>100644</code>：表示一般文件；<code>100755</code>：表示可执行文件；<code>120000</code>：表示符号链接。</p>
</li>
<li>
<p><code>git cat-file -p 7abd3a56703ad4a7120571967f5d06607b5e5502</code> // 查看 <code>SHA-1</code> 哈希值为 <code>7abd3a56703ad4a7120571967f5d06607b5e5502</code> 文件的内容。</p>
</li>
<li>
<p><code>git show 7abd3a56703ad4a7120571967f5d06607b5e5502</code> // 查看 <code>SHA-1</code> 哈希值为 <code>7abd3a56703ad4a7120571967f5d06607b5e5502</code> 文件的内容。</p>
</li>
<li>
<p><code>git cat-file -t f3961f5</code> // 查看 <code>f3961f5</code> 提交对象的类型：显示为 <code>commit</code>。</p>
</li>
<li>
<p><code>git cat-file -p f3961f5</code> // 查看 <code>f3961f5</code> 提交对象的信息：包含 <code>git</code> 目录（<code>tree</code> 对象）、上次提交对象的 <code>SHA-1</code> 哈希值及提交时 <code>Author</code>、<code>Date</code> 和注释信息。</p>
<pre><code class="language-bash">tree ead34240822030a3f71df4fc351057d80d7d83f8
parent 33d5bbc5d61b024aab5078e40548c4e3da808e0e
author nicochen &lt;nicochen@tencent.com&gt; 1537258258 +0800
committer nicochen &lt;nicochen@tencent.com&gt; 1537258258 +0800
123 desc txt
</code></pre>
</li>
<li>
<p><code>git cat-file -p tag1.0</code> // 查看轻量标签或附注标签 <code>tag1.0</code> 信息。</p>
</li>
<li>
<p><code>git cat-file tag tag1.0</code> // 查看附注标签 <code>tag1.0</code> 信息。</p>
</li>
<li>
<p><code>git ls-tree ead34240822030a3f71df4fc351057d80d7d83f8</code> // 查看 <code>tree</code> 目录对象 <code>ead34240822030a3f71df4fc351057d80d7d83f8</code> 中包含的 <code>blob</code> 文件对象和 <code>tree</code> 目录对象。</p>
</li>
<li>
<p><code>git ls-tree HEAD</code> // 查看 <code>HEAD</code> 所指向 <code>tree</code> 目录对象中包含的 <code>blob</code> 文件对象和 <code>tree</code> 目录对象。</p>
</li>
<li>
<p><code>git verify-pack -v .git/objects/pack/pack-a9282552b62cbe3f255fbb20374695a17c1ba2a2.idx</code> // 查看<code>pack-a9282552b62cbe3f255fbb20374695a17c1ba2a2.pack</code> 压缩包中的内容。</p>
</li>
<li>
<p><code>git update-index n.txt</code> // 将修改状态的 <code>n.txt</code> 文件添加到暂存区。</p>
</li>
<li>
<p><code>git update-index --add n.txt</code> // 将未追踪状态或修改状态的 <code>n.txt</code> 文件添加到暂存区。</p>
</li>
<li>
<p><code>git update-index --add --cacheinfo 100644 5d11580eed65ffd34b6786274a60460b3582aa7d n.txt</code>  // 使用类型为 <code>100644</code>、<code>SHA-1</code> 哈希值为 <code>5d11580eed65ffd34b6786274a60460b3582aa7d</code> 的信息将追踪状态或修改状态的 <code>n.txt</code> 添加到暂存区。</p>
</li>
<li>
<p><code>git write-tree</code>  // 将整个暂存区内容生成一个 <code>tree</code> 对象，并输出其 <code>SHA-1</code> 哈希值。</p>
</li>
<li>
<p><code>echo &quot;add n.txt&quot; | git commit-tree 31b7ca405196ca9e8fb4d5404b315bef9f2c841f -p HEAD</code> // 用 <code>git write-tree</code> 得到的<code>31b7ca405196ca9e8fb4d5404b315bef9f2c841f</code> 树对象创建一个注释为 <code>add n.txt</code> 的提交对象，并将提交对象的父亲设置为当前 <code>HEAD</code>。</p>
</li>
<li>
<p><code>git update-ref refs/heads/master 372aa8e425b57ca30e2974b8e7737133caaa0b7f</code>  // 若当前分支为 <code>master</code>，更新 <code>HEAD</code> 指向上面 <code>git commit-tree</code> 命令得到的 <code>372aa8e425b57ca30e2974b8e7737133caaa0b7f</code> 提交对象，此时用 <code>git log</code> 就可以看到这条 <code>commit</code> 记录。</p>
</li>
<li>
<p><code>git write-tree --prefix=ss</code> // 将暂存区中 <code>ss</code> 目录下的内容生成一个 <code>tree</code> 对象，并输出其 <code>SHA-1</code> 哈希值。</p>
</li>
<li>
<p><code>git update-ref -d refs/remotes/origin/v1.0</code> // 删除 <code>v1.0</code> 远程分支 <code>cache</code>。</p>
</li>
<li>
<p><code>git update-index --chmod=+x engine_mac.sh</code> // 为 <code>engine_mac.sh</code> 增加可执行权限（Linux、Unix、Mac OS X 系统上需要）。</p>
</li>
</ul>
<h1 id="命令大全">命令大全</h1>
<h2 id="查看命令帮助">查看命令帮助</h2>
<ul>
<li><code>git config --help</code> // 查看 <code>git config</code> 命令详细用法</li>
<li><code>git help config</code> // 功能同上</li>
</ul>
<h2 id="配置">配置</h2>
<ul>
<li><code>git config --global user.name &quot;kekec&quot;</code> // 配置提交用户名。</li>
<li><code>git config --global user.email &quot;kekec@qq.com&quot;</code> // 配置 E-mail 信息。</li>
<li><code>git config --global core.editor vim</code> // 配置默认文本编辑器，当 Git 需要你输入信息时会调用它。</li>
<li><code>git config --global alias.st status</code> // 为 <code>status</code> 配置别名 <code>st</code>，这样 <code>git status</code> 就可以写成 <code>git st</code>。</li>
<li><code>git config --list</code> // 查看当前仓库的所有配置信息（包括分支相关的信息）</li>
<li><code>git config user.name</code> // 查看当前仓库的用户名信息</li>
<li><code>git config -e --global</code> // 编辑全局配置文件（用户名和 E-mail 信息就记录在其中）  所在目录：<code>c:/users/&lt;用户名&gt;/.gitconfig</code>。</li>
<li><code>git config -e</code> // 编辑当前仓库的配置文件  所在目录：<code>.git\config</code>。</li>
</ul>
<h2 id="创建版本库">创建版本库</h2>
<ul>
<li><code>git init</code> // 在当前目录创建一个空的 <code>git</code> 代码库。</li>
<li><code>git init MyGame</code> // 在当前目录创建一个名为 <code>MyGame</code> 的文件夹，然后在其中创建一个空的 <code>git</code> 代码库。</li>
</ul>
<p>.git目录结构如下：<br>
<img src="https://faded.auspicious.space/post-images/1587103199628.png" alt="" loading="lazy"></p>
<ul>
<li>
<p><code>hooks</code>：不同操作时执行的 <code>hook</code> 脚本。</p>
</li>
<li>
<p><code>info/exclude</code>：与 <code>.gitignore</code> 文件（该文件需放在 <code>.git</code> 文件夹的同级目录中，Windows 下可通过命令行 <code>type nul &gt; .gitignore</code> 来创建）一样，用作文件过滤。不同的是：该文件不会提交到版本库，因此过滤只对本地生效，不影响其他人。</p>
<pre><code class="language-bash"># 忽略所有.so 结尾的文件
*.so
# 但 game.so 除外
!game.so
# 仅仅忽略项目根目录下的 README.md 文件，不包括 subdir/README.md
/README.md
# 忽略 .svn/ 目录下的所有文件
.svn/
# 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt
doc/*.txt
# 忽略 doc/ 目录下所有扩展名为 txt 的文件
doc/**/*.txt
</code></pre>
</li>
<li>
<p><code>logs/refs/heads</code>：各个本地分支的版本 <code>log</code> 记录。</p>
</li>
<li>
<p><code>logs/refs/remotes</code>：各个远程分支 <code>cache</code> 的 <code>log</code> 记录。</p>
</li>
<li>
<p><code>logs/refs/stash</code>：储藏区数据。</p>
</li>
<li>
<p><code>logs/HEAD</code>：<code>git</code> 操作记录。</p>
</li>
<li>
<p><code>objects</code>：2 级文件索引（把 <code>SHA-1</code> 哈希值拆成了：<code>2位+38位</code>），存储 <code>commit</code> 数据、<code>blob</code> 文件数据和 <code>tree</code> 目录数据。</p>
</li>
<li>
<p><code>objects/pack</code>：<code>pack</code> 文件为存储 <code>commit</code>、<code>tree</code> 目录及 <code>blob</code> 文件的压缩数据；<code>idx</code> 文件为 <code>pack</code> 文件中各数据对象的索引。</p>
</li>
<li>
<p><code>objects/info/packs</code>：该文件记录所有 <code>git</code> 库的 <code>pack</code> 文件列表。</p>
</li>
<li>
<p><code>refs/heads</code>：各个本地分支 <code>HEAD</code>。</p>
</li>
<li>
<p><code>refs/remotes</code>：各个远程分支 <code>cache</code> 的 <code>HEAD</code>。</p>
</li>
<li>
<p><code>refs/tags</code>：各个附注标签的信息。</p>
</li>
<li>
<p><code>COMMIT_EDITMSG</code>：上一次提交的注释。</p>
</li>
<li>
<p><code>config</code>：版本库相关的配置信息。</p>
</li>
<li>
<p><code>description</code>：仓库描述信息，供 <code>gitweb</code> 程序使用。</p>
</li>
<li>
<p><code>index</code>：暂存区相关的信息。</p>
</li>
<li>
<p><code>HEAD</code>：指向当前分支的最近提交（如：<code>ref: refs/heads/master</code>）。</p>
</li>
<li>
<p><code>ORIG_HEAD</code>：执行 <code>git merge / git pull / git reset</code> 操作时，会把调整为新值之前的先前版本的 <code>HEAD</code> 记录到 <code>OERG_HEAD</code> 中，用于恢复或回滚之前的状态。</p>
</li>
<li>
<p><code>FETCH_HEAD</code>：<code>git fech</code> 将所有抓取分支的 <code>HEAD</code> 记录到 <code>.git/FETCH_HEAD</code> 中。</p>
</li>
<li>
<p><code>MERGEHEAD</code>：正在合并进 <code>HEAD</code> 的 <code>commit id</code>。</p>
</li>
<li>
<p><code>packed-refs</code>：远程版本库 <code>cache</code> 和远程标签 <code>cache</code>。</p>
</li>
</ul>
<h2 id="日志与文件状态">日志与文件状态</h2>
<ul>
<li><code>git reflog</code> // 查看操作记录。<br>
注：每条操作记录使用 <code>HEAD@{n}</code> 来标识。</li>
<li><code>git show HEAD@{5}</code> // 查看索引为 5 的操作记录的详细信息。</li>
<li><code>git status</code> // 查看当前所处的分支暂存区和工作区的文件（会显示当前所处分支）。
<ul>
<li>注1：处于暂存区的文件状态:：<code>staged</code>（已暂存）；处于工作区的文件状态:：<code>untrack</code>（未跟踪）、<code>modified</code>（已修改）；</li>
<li>注2：工作区中的空目录不会被 <code>git</code> 追踪。</li>
</ul>
</li>
<li><code>git status -s --ignored</code> // 以简洁模式查看暂存区和工作区的文件（全部显示，不执行文件过滤）。</li>
<li><code>git status -uno</code> // 查看暂存区和工作区的非 <code>untrack</code>（未跟踪）状态文件。</li>
<li><code>git status -uall</code> // 查看暂存区和工作区的状态文件（递归子目录显示出里面的文件）。</li>
<li><code>git log</code> // 查看本地版本库提交记录（会显示当前所处分支，<code>HEAD</code> 指针指向哪个分支的哪条提交）。</li>
<li><code>git log --stat</code> // 查看本地版本库提交记录（会显示当前所处分支，<code>HEAD</code> 指针指向哪个分支的哪条提交和每次提交的文件变更简略统计信息）。</li>
<li><code>git log -- README.md</code> // 查看 <code>README.md</code> 文件的本地版本库提交记录。</li>
<li><code>git log --graph -- README.md</code> // 以图形化方式查看 <code>README.md</code> 文件的本地版本库提交记录。</li>
<li><code>git log -p README.md</code> // 查看 <code>README.md</code> 文件的本地版本库提交记录（显示出每次的修改内容）。</li>
<li><code>git log --grep &quot;test&quot;</code> // 显示注释中含有 <code>test</code> 字符串的提交。</li>
<li><code>git log --author=kekec</code> // 查看本地版本库中作者为 <code>kekec</code> 的提交记录。</li>
<li><code>git log -S &quot;SplitPath(FString&amp; str)&quot;</code> // 查看 <code>SplitPath(FString&amp; str)</code> 内容是什么时候加到项目中那些文件中去的。</li>
<li><code>git log --since=2.weeks</code> // 查看最近 2 周的提交记录。</li>
<li><code>git log --since=&quot;2 weeks 3 days 2 hours 30 minutes 59 seconds ago&quot;</code> // 查看 2 周 3 天 2 小时 30 分 59 秒以前的提交记录。</li>
<li><code>git log --after=&quot;2018-10-7&quot; --before=&quot;2018-10-12&quot;</code> // 查看 <code>2018.10.7~2018.10.12</code> 之间的提交记录。</li>
<li><code>git log --since=&quot;2018-10-7&quot; --until=&quot;2018-10-12&quot;</code> // 功能同上：<code>git log --after=&quot;2018-10-7&quot; --before=&quot;2018-10-12&quot;</code>。<br>
注：<code>--since</code>、<code>--until</code> 标记和 <code>--after</code>、<code>--before</code> 标记分别是等价的。</li>
<li><code>git whatchanged README.md</code> // 查看 <code>README.md</code> 文件的本地版本库提交记录（包括文件改名）。</li>
<li><code>git log --follow README.md</code> // 功能同上：<code>git whatchanged README.md</code>。</li>
<li><code>git log -3</code> // 查看最近 3 条本地版本库提交记录。</li>
<li><code>git log -3 --pretty --oneline</code> // 查看最近 3 条本地版本库提交记录（简洁模式，一行显示一个提交）。</li>
<li><code>git log --graph --oneline</code> // 以图形化简洁模式查看当前分支的本地版本库提交记录。</li>
<li><code>git log release --graph --oneline</code> // 以图形化简洁模式查看 <code>release</code> 分支的本地版本库提交记录。</li>
<li><code>git log --graph --oneline --no-merges</code> // 以图形化简洁模式查看当前分支的本地版本库提交记录（过滤 <code>merge</code> 过来的提交）。</li>
<li><code>git log --graph --oneline --merges</code> // 以图形化简洁模式查看当前分支的本地版本库提交记录（只显示有 2 个及以上父亲节点的提交）。</li>
<li><code>git log --graph --oneline --name-only</code> // 以图形化简洁模式查看当前分支的本地版本库提交记录（并显示每次提交的文件名称清单）。</li>
<li><code>git log --graph --oneline --name-status</code> // 以图形化简洁模式查看当前分支的本地版本库提交记录（并显示每次提交的文件状态、名称清单）。</li>
<li><code>git log --graph --oneline --stat</code> // 以图形化简洁模式查看当前分支的本地版本库提交记录（并显示每次提交的文件变化统计、各文件名及增删记录）。</li>
<li><code>git log --graph --oneline --shortstat</code> // 以图形化简洁模式查看当前分支的本地版本库提交记录（并显示每次提交的文件变化统计及增删记录）。</li>
<li><code>git log --graph --oneline --decorate --all</code> // 以图形化简洁模式查看所有分支的本地版本库提交记录树。</li>
<li><code>git log --graph --pretty=format:&quot;%H - %an, %ad : %s&quot;</code> // 自定义格式图形化查看所有分支的本地版本库提交记录树。
<ul>
<li><code>%H</code> 提交对象（<code>commit</code>）的完整哈希字串；</li>
<li><code>%h</code> 提交对象的简短哈希字串；</li>
<li><code>%T</code> 树对象（<code>tree</code>）的完整哈希字串；</li>
<li><code>%t</code> 树对象的简短哈希字串；</li>
<li><code>%P</code> 父对象（<code>parent</code>）的完整哈希字串；</li>
<li><code>%p</code> 父对象的简短哈希字串；</li>
<li><code>%an</code> 作者（<code>author</code>）的名字；</li>
<li><code>%ae</code> 作者的电子邮件地址；</li>
<li><code>%ad</code> 作者修订日期（可以用 <code>--date=</code> 选项定制格式）；</li>
<li><code>%ar</code> 作者修订日期，按多久以前的方式显示；</li>
<li><code>%cn</code> 提交者（<code>committer</code>）的名字；</li>
<li><code>%ce</code> 提交者的电子邮件地址；</li>
<li><code>%cd</code> 提交日期；</li>
<li><code>%cr</code> 提交日期，按多久以前的方式显示；</li>
<li><code>%s</code> 提交说明；</li>
</ul>
</li>
<li><code>git log master..v5.0</code> // 查看 <code>v5.0</code> 分支还未合并到 <code>master</code> 分支上的提交记录列表。</li>
<li><code>git log v5.0..master</code> // 查看 <code>master</code> 分支还未合并到 <code>v5.0</code> 分支上的提交记录列表。</li>
<li><code>git log master...v5.0</code> // <code>git log master..v5.0 + git log v5.0..master</code>。</li>
<li><code>git shortlog -sn</code> // 统计各个提交者的次数。</li>
<li><code>git blame README.md</code> // 显示 <code>README.md</code> 最近一次的修改信息。</li>
<li><code>git show 3a6c702376168aa15a2f3d7bc98000d07a70d023 README.md</code> // 查看 <code>README.md</code> 文件的 <code>3a6c702376168aa15a2f3d7bc98000d07a70d023</code> 提交的修改内容。</li>
<li><code>git show HEAD</code> // 查看最近一次提交的修改内容。</li>
<li><code>git show --name-only HEAD</code> // 查看最近一次提交的文件列表（不显示具体的修改内容）。</li>
</ul>
<h2 id="标签查看新建切换删除">标签（查看/新建/切换/删除）</h2>
<ul>
<li><code>git tag</code> // 列出所有的标签。</li>
<li><code>git tag -l 'tag1*'</code> // 列出所有 <code>tag1</code> 开头的标签。</li>
<li><code>git tag tag1.0</code> // 创建名为 <code>tag1.0</code> 的轻量标签。</li>
<li><code>git tag -a tag1.0 -m &quot;tag1.0 desc&quot;</code> // 添加 <code>tag1.0 desc</code> 注释并创建名为 <code>tag1.0</code> 的附注标签。</li>
<li><code>git tag tag2.0 abffefc5d82078cbaea7fcbb5106ab0c21cbeba9</code> // 在 <code>abffefc5d82078cbaea7fcbb5106ab0c21cbeba9</code> 提交处创建名为 <code>tag2.0</code> 的轻量标签。</li>
<li><code>git tag -a tag2.0 -m &quot;tag2.0 desc&quot; abffefc</code> // 在 <code>abffefc</code> 提交处创建名为 <code>tag2.0</code> 的附注标签。</li>
<li><code>git tag -d tag2.0</code> // 删除名为 <code>tag2.0</code> 的标签。</li>
<li><code>git show tag1.0</code> // 查看名为 <code>tag1.0</code> 相关的信息。</li>
<li><code>git ls-remote --tags</code> // 查看所有远端的标签。</li>
</ul>
<h2 id="分支查看新建切换删除">分支（查看/新建/切换/删除）</h2>
<ul>
<li><code>git branch</code> // 列出所有本地分支。</li>
<li><code>git branch -r</code> // 列出所有远程分支 <code>cache</code>。</li>
<li><code>git branch -a</code> // 列出所有本地分支和远程分支 <code>cache</code>。</li>
<li><code>git branch -av</code> // 列出所有本地分支和远程分支 <code>cache</code>（含简单说明）。</li>
<li><code>git branch -vv</code> // 查看所有本地分支和远程分支 <code>cache</code> 之间的追踪关系。</li>
<li><code>git branch v1.0</code> // 在当前分支的 <code>HAED</code> 指针下创建名为 <code>v1.0</code> 的分支（创建完不会切到 <code>v1.0</code> 分支上）。</li>
<li><code>git branch --track v1.0 origin/v1.0</code> // 若 <code>v1.0</code> 分支不存在则先新建，然后将其与远程分支 <code>origin/v1.0</code> 建立追踪关系。
<ul>
<li>远程分支 <code>origin/v1.0</code> 要存在，否则命令执行失败。</li>
<li>执行完不会切到 <code>v1.0</code> 分支上。</li>
</ul>
</li>
<li><code>git branch v2.0 372aa8e425b57ca30e2974b8e7737133caaa0b7f</code> // 在 <code>372aa8e425b57ca30e2974b8e7737133caaa0b7f</code> 提交处创建名为 <code>v2.0</code> 的分支（创建完不会切到 <code>v2.0</code> 分支上）。</li>
<li><code>git branch -m v1.0 x1.0</code> // 将分支 <code>v1.0</code> 重命名为 <code>x1.0</code>。</li>
<li><code>git checkout v1.0</code> // 切换到 <code>v1.0</code> 分支上（<code>v1.0</code> 分支不存在则命令执行失败）。</li>
<li><code>git checkout -b v1.0</code> // 创建并切换到 <code>v1.0</code> 分支上（<code>v1.0</code> 分支存在则命令执行失败）。</li>
<li><code>git checkout -B v1.0</code> // 不存在则创建，并切换到 <code>v1.0</code> 分支上。</li>
<li><code>git checkout -b v1.0 5a95f2d</code> // 在 <code>5a95f2d</code> 提交处创建并切换到 <code>v1.0</code> 的分支上。</li>
<li><code>git checkout -b v1.0 tag1.0</code> // 在标签 <code>tag1.0</code> 处创建并切换到 <code>v1.0</code> 的分支上。</li>
<li><code>git checkout -t origin/v1.0</code> // 创建并切换到 <code>origin/v1.0</code> 远程分支 <code>cache</code> 的名为 <code>v1.0</code> 本地分支上，并建立两者追踪关系（本地分支 <code>v1.0</code> 存在则命令执行失败）。</li>
<li><code>git checkout -b x1.0 -t origin/v1.0</code> // 创建并切换到 <code>origin/v1.0</code> 远程分支 <code>cache</code> 的名为 <code>x1.0</code> 本地分支上，并建立两者追踪关系（本地分支 <code>x1.0</code> 存在则命令执行失败）
<ul>
<li>注1：切换分支前，必须处理工作区（未追踪的文件不用处理）和暂存区的修改才能切换成功</li>
<li>注2：切换成功后，工作区会被设置成分支的内容</li>
<li>注3：不允许在远程分支 <code>cache</code> 上提交，需要创建对应关联的本地分支，然后在本地分支上进行提交。</li>
</ul>
</li>
<li><code>git checkout -f v1.0</code> // 强制切换到 <code>v1.0</code> 分支上，丢弃暂存区和工作区中的所有文件的修改（工作区中未追踪的文件不受影响）。</li>
<li><code>git checkout -f -B v1.0 origin/v1.0</code> // 不存在则创建，强制切换到 <code>v1.0</code> 分支上，丢弃暂存区和工作区中的所有文件的修改，并将 <code>HEAD</code> 指向 <code>origin/v1.0</code> 处（工作区中未追踪的文件不受影响）。</li>
<li><code>git checkout -</code> // 切换到上一次分支。</li>
<li><code>git branch -d v2.0</code> // 删除名为 <code>v2.0</code> 的分支（必须先切到其他分支上才能执行删除操作）。</li>
<li><code>git branch -D v2.0</code> // 强制删除名为 <code>v2.0</code> 的分支（必须先切到其他分支上才能执行删除操作）。</li>
<li><code>git branch -dr origin/v2.0</code> // 删除远程分支 <code>origin/v2.0 cache</code>。</li>
</ul>
<h2 id="文件增加删除提交撤销">文件（增加/删除/提交/撤销）</h2>
<ul>
<li>
<p><code>git add README.md</code> // 将当前目录下的 <code>README.md</code> 文件加入到暂存区。</p>
</li>
<li>
<p><code>git add .</code> // 将当前目录下（递归子目录）所有文件加入到暂存区。</p>
</li>
<li>
<p><code>git add -u .</code> // 将当前目录下（递归子目录）所有追踪状态的文件加入到暂存区。</p>
</li>
<li>
<p><code>git add Doc/\*.txt</code> // 将当前目录的 <code>Doc</code> 文件夹下（递归子目录）所有 <code>txt</code> 后缀的文件加入到暂存区。</p>
</li>
<li>
<p><code>git rm README.md</code> // 删除工作区文件，并且将这次删除放入暂存区（若 <code>README.md</code> 在工作区或暂存区中有修改，命令会执行失败）。</p>
</li>
<li>
<p><code>git rm -f README.md</code> // 强制删除工作区文件，并且将这次删除放入暂存区（即使 <code>README.md</code> 在工作区或暂存区中有修改，也会执行删除操作）。</p>
</li>
<li>
<p><code>git rm --cached README.md</code> // 不删除工作区对应的文件，只将 <code>README.md</code> 删除放入暂存区以供提交。</p>
</li>
<li>
<p><code>git mv README.md test.md</code> // 将 <code>README.md</code> 改名为 <code>test.md</code>，并且将这个改名放入暂存区。</p>
</li>
<li>
<p><code>git commit -m &quot;desc&quot;</code> // 添加 <code>desc</code> 注释并将暂存区中的所有修改提交到本地仓库。</p>
</li>
<li>
<p><code>git commit README.md -m &quot;desc&quot;</code> // 添加 <code>desc</code> 注释并将暂存区中的 <code>README.md</code> 的修改提交到本地仓库。</p>
</li>
<li>
<p><code>git commit --amend -m &quot;desc&quot;</code> // 添加 <code>desc</code> 注释使用当前提交覆盖上一次的提交（若上一次提交包含 <code>1.txt</code> 和 <code>2.txt</code> 的修改，当前提交只包含 <code>1.txt</code> 的修改；执行命令后，本地版本库中为本次的 <code>1.txt</code> 和上一次 <code>2.txt</code>）。若没有提交内容，则用来改写上一次提交的日志信息。</p>
</li>
<li>
<p><code>git commit -m &quot;desc&quot; --amend README.txt</code> // 添加 <code>desc</code> 注释使用 <code>README.txt</code> 的当前提交覆盖上一次的提交。</p>
</li>
<li>
<p><code>git commit -a -m &quot;desc&quot;</code> // 添加 <code>desc</code> 注释并将工作区和暂存区中的所有修改提交到本地仓库。</p>
</li>
<li>
<p><code>git commit -am &quot;desc&quot;</code> // 功能同上。</p>
</li>
<li>
<p><code>git commit -c b5cad94d229e72bd7aff5fe2c6f022b29c30e7a8</code> // 拿 <code>372aa8e425b57ca30e2974b8e7737133caaa0b7f</code> 提交的信息（作者、提交者、注释、时间戳等）来提交当前修改。</p>
</li>
<li>
<p><code>git reset -- README.md</code> // 丢弃暂存区中的 <code>README.md</code> 文件的修改。</p>
</li>
<li>
<p><code>git reset README.md</code> // 功能如上，丢弃暂存区中的 <code>README.md</code> 文件的修改。</p>
</li>
<li>
<p><code>git reset b5cad94 README.md</code> // 使用本地版本库 <code>b5cad94</code> 提交处的 <code>README.md</code> 版本覆盖暂存区中的 <code>README.md</code>。</p>
</li>
<li>
<p><code>git reset</code> // 丢弃暂存区中的所有文件的修改（工作区不受影响）。</p>
</li>
<li>
<p><code>git reset --mixed</code> // <code>--mixed</code> 为缺省参数，命令与上面 <code>git reset</code> 一样。</p>
</li>
<li>
<p><code>git reset --hard</code> // 丢弃暂存区和工作区中的所有文件的修改（工作区中未追踪的文件不受影响）。</p>
</li>
<li>
<p><code>git reset --soft b5cad94d229e72bd7aff5fe2c6f022b29c30e7a8</code> // 仅将当前分支的。<code>HEAD</code> 指向 <code>372aa8e425b57ca30e2974b8e7737133caaa0b7f</code> 提交（暂存区和工作区中的所有文件的修改都不丢弃）。</p>
</li>
<li>
<p><code>git reset --soft HEAD~</code> // 仅将当前分支的 <code>HEAD</code> 指向上一次提交（暂存区和工作区中的所有文件的修改都不丢弃）。</p>
</li>
<li>
<p><code>git reset --soft HEAD~2</code> // 仅将当前分支的 <code>HEAD</code> 指向上两次提交（暂存区和工作区中的所有文件的修改都不丢弃）。</p>
</li>
<li>
<p><code>git reset --merge &lt;commit&gt;</code> // 在被污染的工作区中回滚 <code>merge</code> 或者 <code>pull</code>。</p>
<pre><code class="language-bash">$ git pull                         (1) 
Auto-merging nitfol 
Merge made by recursive. 
nitfol                |   20 +++++---- 
... 
$ git reset --merge ORIG_HEAD      (2)
</code></pre>
<ol>
<li>即便你已经在本地更改了一些你的工作区，你也可安全的 <code>git pull</code>，前提是你知道将要 <code>pull</code> 的内容不会覆盖你的工作区中的内容。</li>
<li><code>git pull</code> 完后，你发现这次 <code>pull</code> 下来的修改不满意，想要回滚到 <code>pull</code> 之前的状态，我们可以执行 <code>git reset --hard ORIG_HEAD</code>，但是这个命令有个副作用就是清空你的工作区，即丢弃你的本地未 <code>add</code> 的那些改变。</li>
</ol>
<p>为了避免丢弃工作区中的内容，可以使用 <code>git reset --merge ORIG_HEAD</code>，注意其中的<code>--hard</code> 换成了 <code>--merge</code>，这样就可以避免在回滚时清除工作区。</p>
</li>
<li>
<p><code>git reset --keep &lt;commit&gt;</code> // 保留工作区并丢弃一些之前的提交。<br>
假设你正在编辑一些文件，并且已经提交，接着继续工作，但是现在你发现当前在工作区中的内容应该属于另一个分支，与之前的提交没有什么关系。此时，可以开启一个新的分支，并且保留着工作区中的内容。</p>
<pre><code class="language-bash">$ git tag start 
$ git checkout -b branch1 
$ edit 
$ git commit ...                            (1) 
$ edit 
$ git checkout -b branch2                   (2) 
$ git reset --keep start                    (3)
</code></pre>
<ol>
<li>这次是把在 <code>branch1</code> 中的改变提交了。</li>
<li>此时发现，之前的提交不属于这个分支，此时新建了 <code>branch2</code> 分支，并切换到了 <code>branch2</code> 上。</li>
<li>此时可以用 <code>reset --keep</code> 把在 <code>start</code> 之后的提交清除掉，但是保持工作区不变。</li>
</ol>
</li>
<li>
<p><code>git checkout -- README.md</code> // <code>--</code> 符号非常重要，否则就变成了切换到 <code>README.md</code> 分支了。<br>
// 当 <code>README.md</code> 在暂存区中有修改时，使用暂存区中的修改覆盖工作区中的 <code>README.md</code>。<br>
// 当 <code>README.md</code> 不在暂存区中时，使用本地版本库中的 <code>HEAD</code> 指针处的修改覆盖工作区中的 <code>README.md</code>。</p>
</li>
<li>
<p><code>git checkout -- .</code> // 使用暂存区和本地版本库来恢复当前目录（递归子目录）下的所有文件。<br>
注：若暂存区中有修改，优先使用暂存区。</p>
</li>
<li>
<p><code>git checkout HEAD README.md</code> // 使用本地版本库中的 <code>HEAD</code> 处提交覆盖暂存区和工作区中的 <code>README.md</code>。</p>
</li>
<li>
<p><code>git checkout 9a387f22ff949fa16336508adc2284384bd6a890 README.md</code> // 使用本地版本库中的 <code>9a387f22ff949fa16336508adc2284384bd6a890</code> 修改覆盖暂存区和工作区中的 <code>README.md</code>。</p>
</li>
<li>
<p><code>git checkout -b v2.0 tag2.0</code> // 在名为 <code>tag2.0</code> 的提交处创建并切换到 <code>v2.0</code> 分支上（<code>v2.0</code> 分支存在则命令执行失败）。</p>
</li>
<li>
<p><code>git revert --no-edit 3a6c702376168aa15a2f3d7bc98000d07a70d023</code> // 回滚 <code>3a6c702376168aa15a2f3d7bc98000d07a70d023</code> 提交，然后提交到本地仓库。</p>
</li>
<li>
<p><code>git revert HEAD~</code> // 回滚 <code>HEAD</code> 的上一次提交，然后会弹出 <code>vim</code> 环境编辑注释（输入 <code>:q</code> 直接使用默认注释内容、输入 <code>:q!</code> 放弃修改使用默认注释内容、输入 <code>:x</code> 或 <code>:wq</code> 保存当前修改的注释内容），然后提交到本地仓库。</p>
</li>
<li>
<p><code>git revert -n HEAD~3</code> // 回滚掉 <code>HEAD~3</code> 处的提交，不自动提交到本地仓库。</p>
</li>
<li>
<p><code>git revert -n HEAD~2..HEAD</code> // 回滚掉 <code>(HEAD~2, HEAD]</code> 之间的 2 次提交，不自动提交到本地仓库。<br>
注：<code>git reset</code> 是把 <code>HEAD</code> 向后移动来删除提交，而 <code>git revert</code> 是用一次新的提交来回滚之前的提交（<code>HEAD</code> 会继续前进）。</p>
</li>
</ul>
<h2 id="查看差异">查看差异</h2>
<ul>
<li><code>git diff README.md</code> // 查看当前目录下的 <code>README.md</code> 在工作区和暂存区之间的差异。</li>
<li><code>git diff --cached README.md</code> // 查看当前目录下的 <code>README.md</code> 在暂存区和本地仓库最后一次提交之间的差异。</li>
<li><code>git diff --cached 372aa8e425b57ca30e2974b8e7737133caaa0b7f README.md</code> // 查看当前目录下的 <code>README.md</code> 在暂存区和本地仓库的 <code>372aa8e425b57ca30e2974b8e7737133caaa0b7f</code> 提交之间的差异。</li>
<li><code>git diff HEAD README.md</code> // 查看当前目录下的 <code>README.md</code> 在工作区和本地仓库 <code>HEAD</code> 指针处提交之间的差异。</li>
<li><code>git diff 372aa8e425b57ca30e2974b8e7737133caaa0b7f README.md</code> // 查看当前目录下的 <code>README.md</code> 在工作区和本地仓库的 <code>372aa8e425b57ca30e2974b8e7737133caaa0b7f</code> 提交之间的差异。</li>
<li><code>git diff 372aa8e425b57ca30e2974b8e7737133caaa0b7f HEAD README.md</code> // 查看当前目录下的 <code>README.md</code> 在本地仓库的 <code>372aa8e425b57ca30e2974b8e7737133caaa0b7f</code> 提交和最后一次提交之间的差异。</li>
<li><code>git diff 372aa8e425b57ca30e2974b8e7737133caaa0b7f HEAD</code> // 查看本地仓库的 <code>372aa8e425b57ca30e2974b8e7737133caaa0b7f</code> 提交和最后一次提交之间的差异。</li>
<li><code>git diff 372aa8e b5cad94 README.md</code> // 查看当前目录下的 <code>README.md</code> 在本地仓库的 <code>372aa8e</code> 提交和 <code>b5cad94</code> 提交之间的差异<br>
注：可以将 <code>git diff</code> 换成 <code>git difftool</code> 来使用外部 <code>diff</code> 工具（可以在 <code>c:/users/&lt;用户名&gt;/.gitconfig</code> 文件配置 <code>beyond compare</code> 作为默认的 <code>difftool</code> 和 <code>mergetool</code>）来查看差异。<pre><code class="language-bash">[diff]
    tool = bc3
[difftool]
    prompt = false
[difftool &quot;bc3&quot;]
    cmd = &quot;\&quot;e:/program files (x86)/beyond compare 3/bcomp.exe\&quot; \&quot;$LOCAL\&quot; \&quot;$REMOTE\&quot;&quot;
</code></pre>
</li>
</ul>
<h2 id="分支合并">分支合并</h2>
<ul>
<li>
<p><code>git merge-base Master Feature</code> // 查看 <code>Master</code> 和 <code>Feature</code> 分支的最优共同 <code>commit</code> 父节点。</p>
</li>
<li>
<p><code>git merge Feature</code> // 将 <code>Feature</code> 分支 <code>merge</code> 合并到当前分支 <code>Master</code>（无冲突时会直接提交）。</p>
</li>
<li>
<p><code>git merge -m &quot;merge test&quot; Feature</code> // 将 <code>Feature</code> 分支 <code>merge</code> 合并到当前分支 <code>Master</code>（无冲突时使用 <code>merge test</code> 注释直接提交）。</p>
</li>
<li>
<p><code>git merge --no-commit Feature</code> // 将 <code>Feature</code> 分支 <code>merge</code> 合并到当前分支 <code>Master</code>（不自动提交）。</p>
</li>
<li>
<p><code>git rebase Feature</code> // 将 <code>Feature</code> 分支 <code>rebase</code> 合并到当前分支 <code>Master</code>。<br>
<img src="https://faded.auspicious.space/post-images/1587126526914.png" alt="" loading="lazy"></p>
<ul>
<li>注1：<code>git rebase</code> 会先找出共同的祖先节点，从祖先节点把 <code>Feature</code> 分支的提交记录全都剪切下来，然后合到 <code>Master</code> 分支（合并前后 <code>commitID</code> 会不一样）。</li>
<li>注2：相对来说，<code>git merge</code> 处理冲突更直接，但会增加一些冗余的提交记录；而 <code>git rebase</code> 能够保证清晰线性的提交记录，但这也将合并的操作没有被记录下来。</li>
<li>注3：最好是用 <code>git rebase</code> 合并远程分支到本地，<code>git merge</code> 合并 <code>Feature</code> 分支到 <code>Master</code> 分支。</li>
<li>注4：在合并 <code>Feature</code> 分支到 <code>Master</code> 分支前，务必先执行 <code>git pull -r origin Feature</code> 来进行远程分支与本地分支的 <code>rebase</code> 合并。</li>
<li>注5：处于冲突状态（<code>conflict</code>）的文件为 <code>UU</code>（可通过 <code>git status -s --ignored</code> 来查找），手动处理完冲突后，然后使用 <code>git add</code> 该文件，最后继续执行 <code>git merge/rebase --continue</code> 来完成合并的提交工作。</li>
<li>注6：<code>README.md</code> 文件冲突内容如下<pre><code class="language-bash">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
123 456 789 000 111 222 333 444 555 ss  // 当前分支的内容
=======
123 456 789 000 ss tt  // Feature 分支的内容
&gt;&gt;&gt;&gt;&gt;&gt;&gt; Feature
</code></pre>
</li>
<li>注7：可以使用 <code>git mergetool</code> 来使用外部 <code>merge</code> 工具（可以在 <code>c:/users/&lt;用户名&gt;/.gitconfig</code> 文件配置 <code>beyond compare</code> 作为默认的 <code>mergetool</code>）来处理冲突。<br>
修改完当前文件后，可再次调用 <code>git mergetool</code> 来处理下一个冲突，直至全部处理完毕，然后使用 <code>git add</code> 该文件，最后继续执行 <code>git merge/rebase --continue</code> 来完成合并的提交工作。<pre><code class="language-bash">[merge]
    tool = bc3
[mergetool]
    prompt = false
[mergetool &quot;bc3&quot;]
    cmd = &quot;\&quot;e:/program files (x86)/beyond compare 3/bcomp.exe\&quot; \&quot;$LOCAL\&quot; \&quot;$REMOTE\&quot; \&quot;$BASE\&quot; \&quot;$MERGED\&quot;&quot;
</code></pre>
<img src="https://faded.auspicious.space/post-images/1587127706910.png" alt="" loading="lazy"></li>
</ul>
</li>
<li>
<p><code>git rebase /i Feature</code> // 将 <code>Feature</code> 分支采用手动交互方式 <code>rebase</code> 合并到当前分支 <code>Master</code>。</p>
<pre><code class="language-bash">pick 07c5abd Introduce OpenPGP and teach basic usage

pick de9b1eb Fix PostChecker::Post#urls
pick 3e7ee36 Hey kids, stop all the highlighting
pick fa20af3 git interactive rebase, squash, amend

# Rebase 8db7e8b..fa20af3 onto 8db7e8b
#
# Commands:
# p, pick = use commit
# r, reword = use commit, but edit the commit message
# e, edit = use commit, but stop for amending
# s, squash = use commit, but meld into previous commit
# f, fixup = like &quot;squash&quot;, but discard this commit's log message
# x, exec = run command (the rest of the line) using shell
#
# These lines can be re-ordered; they are executed from top to bottom.
#
# If you remove a line here THAT COMMIT WILL BE LOST.
#
# However, if you remove everything, the rebase will be aborted.
#
# Note that empty commits are commented out
</code></pre>
</li>
<li>
<p><code>git merge/rebase --abort</code> // 撤销当前 <code>merge</code> 或 <code>rebase</code> 操作。</p>
</li>
<li>
<p><code>git merge/rebase --skip</code> // 强制使用 <code>Feature</code> 分支的内容。</p>
</li>
<li>
<p><code>git merge/rebase --continue</code> // 手动处理完冲突后使用 <code>git add</code> 该文件，最后继续执行 <code>git merge/rebase --continue</code> 来完成合并的提交工作。</p>
</li>
<li>
<p><code>git merge origin/master</code> // <code>fetch</code> 完之后，可以将远程分支 <code>cache master</code> 分支 <code>merge</code> 合并到当前分支上。</p>
</li>
<li>
<p><code>git rebase origin/master</code> // <code>fetch</code> 完之后，可以将远程分支 <code>cache master</code> 分支 <code>rebase</code> 合并到当前分支上。</p>
</li>
<li>
<p><code>git rebase --onto master 76cada~</code> // 将当前分支从 <code>[76cada, HEAD]</code> 区间段的提交 <code>rebase</code> 合并到 <code>master</code> 上。</p>
</li>
<li>
<p><code>git cherry-pick 9a341e</code> // 将 <code>9a341e</code> 提交合入当前分支。若不冲突，则直接使用 <code>9a341e</code> 的提交信息进行 <code>commit</code>，否则要先进行冲突处理，然后继续执行 <code>git cherry-pick --continue</code> 来完成合并的提交工作。</p>
</li>
<li>
<p><code>git cherry-pick 371c2…971209</code> // 将 <code>(371c2, 971209]</code> 提交合入当前分支（每个提交都会在当前分支上创建一个 <code>commit</code>）。</p>
</li>
<li>
<p><code>git cherry-pick 371c2~…971209</code> // 将 <code>[371c2, 971209]</code> 提交合入当前分支（每个提交都会在当前分支上创建一个 <code>commit</code>）。</p>
</li>
<li>
<p><code>git cherry-pick -n 9a341e d2f99e</code> // 将 <code>9a341e</code> 和 <code>d2f99e</code> 提交合入当前分支（不提交），后续需要手动 <code>commit</code>。</p>
</li>
<li>
<p><code>git cherry-pick --abort</code> // 撤销当前 <code>cherry-pick</code> 操作。</p>
</li>
<li>
<p><code>git cherry-pick --quit</code> // 清理当前操作状态，不撤销修改强制退出 <code>cherry-pick</code> 操作过程。</p>
</li>
<li>
<p><code>git cherry-pick --continue</code> // 手动处理完冲突后，最后继续执行 <code>git cherry-pick --continue</code> 来完成合并的提交工作。</p>
</li>
</ul>
<h2 id="查看远程版本库">查看远程版本库</h2>
<ul>
<li><code>git remote -v</code> // 显示远程仓库的 <code>URL</code>。<br>
注：由于 <code>git</code> 是分布式的，所有远程仓库可能有很多个<pre><code class="language-bash">origin https://github.com/kekec/Test.git (fetch)
origin https://github.com/kekec/Test.git (push)
</code></pre>
</li>
<li><code>git remote -ls</code> // 查看远程仓库 <code>URL</code> 和分支信息<pre><code class="language-bash">From https://github.com/kekec/Test.git
fae0fc82d711425daa897a63137d7e1af09512ba HEAD
fae0fc82d711425daa897a63137d7e1af09512ba refs/heads/master
</code></pre>
</li>
<li><code>git remote</code> // 查看远程仓库名称，一般为 <code>origin</code>。</li>
<li><code>git remote rename origin test</code> // 将远程仓库名称从 <code>origin</code> 修改为 <code>test</code>。</li>
<li><code>git remote show origin</code> // 显示远程仓库的信息。<pre><code class="language-bash">* remote origin  
Fetch URL: https://github.com/kekec/Test.git  
Push URL: https://github.com/kekec/Test.git  
HEAD branch: master  
Remote branches:    
master tracked    
v3.1 tracked
Local branch configured for 'git pull':    
master merges with remote master
Local refs configured for 'git push':    
master pushes to master (fast-forwardable)    
v3.1 pushes to v3.1 (up to date)
</code></pre>
</li>
<li><code>git remote rm origin</code> // 删除 <code>.git/config</code> 文件中添加 <code>remote origin</code> 相关的信息。</li>
<li><code>git remote add origin https://github.com/kekec/Test.git</code> // 在 <code>.git/config</code> 文件中添加 <code>remote origin</code> 指向的远程仓库 <code>URL</code>（若已存在，则命令执行失败）。<pre><code class="language-bash">[remote &quot;origin&quot;]
    url = https://github.com/kekec/Test.git
    fetch = +refs/heads/*:refs/remotes/origin/*
</code></pre>
</li>
<li><code>git remote set-url origin https://github.com/kekec/Test.git</code> // 修改 <code>.git/config</code> 文件中添加 <code>remote origin</code> 指向的远程仓库 <code>URL</code>。</li>
<li><code>git remote prune origin</code> // 对于远程仓库不存在的分支，清除对应的远程分支 <code>cache</code>。</li>
</ul>
<h2 id="远程操作">远程操作</h2>
<ul>
<li><code>git clone https://github.com/kekec/Test.git</code> // 将 https://github.com/kekec/Test.git 上的当前分支克隆到本地（会创建一个名为 <code>Test</code> 目录，远程仓库名称使用默认名 <code>origin</code>）。</li>
<li><code>git clone https://github.com/kekec/Test.git MyProject</code> // 将 https://github.com/kekec/Test.git 上的当前分支克隆到本地（会创建一个名为 <code>MyProject</code> 目录，远程仓库名称使用默认名 <code>origin</code>）。</li>
<li><code>git clone -b v1.0 https://github.com/kekec/Test.git</code> // 将 https://github.com/kekec/Test.git 上的 <code>v1.0</code> 分支克隆到本地（会创建一个名为 <code>Test</code> 目录，远程仓库名称使用默认名 <code>origin</code>）。</li>
<li><code>git clone -b v1.0 https://github.com/kekec/Test.git d:\MyGame</code> // 将 https://github.com/kekec/Test.git 上的 <code>v1.0</code> 分支克隆到 <code>d:\MyGame</code> 目录（会在 <code>d:\MyGame</code> 中创建一个名为 <code>Test</code> 目录，远程仓库名称使用默认名 <code>origin</code>）。</li>
<li><code>git clone -o TestPrj https://github.com/kekec/Test.git</code> // 将 https://github.com/kekec/Test.git 上的当前分支克隆到本地（会创建一个名为 <code>Test</code> 目录，并将远程仓库名称设置为 <code>TestPrj</code>）。</li>
<li><code>git fetch origin master</code> // 从远程仓库拉取 <code>master</code> 分支状态的变化信息（工作区文件不会更新）。</li>
<li><code>git fetch</code> // 从远程仓库拉取所有分支和 <code>tag</code> 状态的变化信息（工作区文件不会更新）。</li>
<li><code>git fetch -p</code> // 从远程仓库拉取所有分支和 <code>tag</code> 状态的变化信息，并清除已被删除的远程分支和 <code>tag</code> 在本地的缓存（工作区文件不会更新）。</li>
<li><code>git fetch origin --tags</code> // 从远程仓库拉取所有 <code>tag</code> 到本地（工作区文件不会更新）。</li>
<li><code>git pull &lt;远程仓库名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</code>。</li>
<li><code>git pull origin master</code> // 先执行 <code>fetch</code>，然后将远程 <code>origin/master</code> 分支 <code>merge</code> 合并到当前分支（最后会更新 <code>origin/master</code>，<code>origin/HEAD</code> 指针到最新提交）。</li>
<li><code>git pull https://github.com/kekec/Test.git master</code> // 先执行 <code>fetch</code>，将远程 <code>origin/master</code> 分支 <code>merge</code> 合并到当前分支（最后不会更新 <code>origin/master</code>，<code>origin/HEAD</code> 指针到最新提交）。</li>
<li><code>git pull origin v1.0:master</code> // 先执行 <code>fetch</code>，然后将远程 <code>origin/v1.0</code> 分支 <code>merge</code> 合并到本地 <code>master</code> 分支。</li>
<li><code>git pull origin</code> // 先执行 <code>fetch</code>，然后将对应的远程分支 <code>merge</code> 合并到当前分支（当前分支需要预存远程分支的追踪关系）。</li>
<li><code>git pull</code> // 先执行 <code>fetch</code>，然后将对应的远程分支 <code>merge</code> 合并到当前分支（当前分支需要预存远程分支的追踪关系，而且当前分支只有一个远程仓库）。</li>
<li><code>git pull -p</code> // 先执行 <code>fetch</code>，然后将对应的远程分支 <code>merge</code> 合并到当前分支，并清除已被删除的远程分支和 <code>tag</code> 在本地的缓存。</li>
<li><code>git pull -r origin master</code> // 先执行 <code>fetch</code>，然后将远程 <code>origin/master</code> 分支 <code>rebase</code> 合并到 <code>master</code> 分支。</li>
<li><code>git push &lt;远程仓库名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</code>。</li>
<li><code>git push -u origin master</code> // 将本地仓库的修改 <code>push</code> 到 <code>origin</code> 所指向的远程仓库 <code>URL</code> 的 <code>master</code> 分支上，并在 <code>.git/config</code> 文件中记录当前分支与远程分支 <code>master</code> 的对应关系。</li>
<li><code>git push origin</code> // 将当前分支更新推送给对应的远端分支。</li>
<li><code>git push</code> // 将当前分支更新推送给对应的远端分支（当前分支只有一个远程仓库，可以省略仓库名 <code>origin</code>）。</li>
<li><code>git push origin -f</code> // 使用当前分支更新强行覆盖对应的远端分支（合入远端分支有冲突时，也使用当前分支更新）。</li>
<li><code>git push origin v1.0</code> // 将本地分支 <code>v1.0</code> 更新推送给对应的远端分支 <code>remotes/origin/v1.0</code>。</li>
<li><code>git push origin --all</code> // 将本地所有分支更新推送给各自对应的远端分支。</li>
<li><code>git push origin tag1.0</code> // 将本地标签 <code>tag1.0</code> 更新到远端标签 <code>tag1.0</code>。</li>
<li><code>git push origin --tags</code> // 将本地所有标签更新到对应的远端标签。</li>
<li><code>git push origin :v1.0</code> // 删除远端分支 <code>v1.0</code>。</li>
<li><code>git push origin :refs/tags/tag1.0</code> // 删除远程标签 <code>tag1.0</code>。</li>
<li><code>git push origin -d v1.0</code> // 删除远端分支 <code>v1.0</code> 功能同上。</li>
</ul>
<h2 id="储藏区">储藏区</h2>
<ul>
<li><code>git stash</code> // 将工作区中所有文件的修改备份压栈到储藏区，然后丢弃工作区与暂存区的所有文件的修改。</li>
<li><code>git stash pop</code> // 使用储藏区的栈顶处备份（<code>stash@{0}</code>）来恢复当前分支的工作区，并将栈顶备份移除。</li>
<li><code>git stash apply stash@{1}</code> // 使用储藏区的栈顶下面一个备份（<code>stash@{1}</code>）来恢复当前分支的工作区，但不移除储藏区中任何备份。</li>
<li><code>git stash list</code> // 查看储藏区栈列表。</li>
<li><code>git stash show -p stash@{0}</code> // 查看储藏区的栈顶处备份中各个文件的内容。</li>
<li><code>git stash drop</code> // 直接移除储藏区的栈顶处备份（不用于恢复当前分支的工作区）。</li>
<li><code>git stash clear</code> // 清除储藏区栈列表。</li>
</ul>
<h2 id="工作区">工作区</h2>
<ul>
<li><code>git clean -nd</code> // 探测工作区中哪些文件和目录（未追踪状态）会被删除。</li>
<li><code>git clean -fd</code> // 删除工作区中未追踪状态的文件和目录。</li>
</ul>
<h2 id="暂存区">暂存区</h2>
<ul>
<li><code>git ls-files</code> // 查询暂存区中的文件列表（递归子目录）。</li>
<li><code>git ls-files -s</code> // 查看暂存区中所有文件的 <code>blob</code> 数据块信息。</li>
<li><code>git ls-files -s -- README.md</code> // 查看暂存区中的 <code>README.md</code> 文件的 <code>blob</code> 数据块信息。</li>
</ul>
<h2 id="其他命令">其他命令</h2>
<ul>
<li><code>git fsck --full</code> // 列出所有未引用的 <code>blob</code>、<code>tree</code>、<code>commit</code> 对象。</li>
<li><code>git archive --format zip --output d:/file.zip master</code> // 将当前 <code>master</code> 分支所有文件使用 <code>zip</code> 压缩方式打包到 <code>d:/file.zip</code>。</li>
</ul>
<h1 id="git-瘦身">Git 瘦身</h1>
<ul>
<li><code>git count-objects -v</code> // 查看 <code>git</code> 对象的统计信息。</li>
<li><code>find .git/objects -type f -print0 | xargs -0 du -hk | sort -nr | head -5</code> // 查找 <code>git</code> 库中最大的 <code>5</code> 个文件（<code>du -hk</code> 中的 <code>k</code> 代表单位为 KB）。</li>
<li><code>find .git/objects -type f -size +1M -print0 | xargs -0 du -hm | sort -nr | head -5</code> // 查找 <code>git</code> 库中 <code>size</code> 超过 <code>1M</code> 的最大的 <code>5</code> 个文件（<code>du -hm</code> 中的 <code>m</code> 代表单位为 MB）。</li>
<li><code>git verify-pack -v .git/objects/pack/pack-b340eea7566df839294b71ec91a327ca2ece0b94.idx | sort -k 3 -nr | head -5</code> // 对压缩存储的 <code>git</code> 库查找最大的 <code>5</code> 个文件。</li>
<li><code>git filter-branch --force --index-filter 'git rm --cached --ignore-unmatch FramePro.cpp' --prune-empty --tag-name-filter cat -- --all</code> // 从 <code>git</code> 库的历史记录中彻底清理 <code>FramePro.cpp</code>。</li>
<li><code>git for-each-ref --format='delete %(refname)' refs/original | git update-ref --stdin</code> // 清理所有废弃的 <code>ref</code> 引用。</li>
<li><code>git gc --prune=now</code>
<ol>
<li>将所有的对象压缩存储到 <code>pack</code> 二进制文件中，以节省空间和提高效率。</li>
<li>移除与任何提交都不相关的陈旧对象。</li>
</ol>
</li>
<li><code>git reflog expire --expire=now --all</code> // 清除所有操作记录日志。<br>
除了使用 <code>git</code> 原生命令外，可以使用专门的工具 <code>BFG</code>（<code>Java</code> 实现）来对 <code>Git</code> 库瘦身。</li>
</ul>
<h1 id="经典-gitflow">经典 Gitflow</h1>
<figure data-type="image" tabindex="2"><img src="https://faded.auspicious.space/post-images/1587134458229.png" alt="" loading="lazy"></figure>
<ol>
<li><code>master</code> 分支存储了正式发布的历史（<code>master</code> 分支上的所有提交都会分配一个版本号）。</li>
<li><code>develop</code> 分支作为功能的集成分支。</li>
<li>每个新功能位于一个自己的 <code>Feature</code> 分支，该分支使用 <code>develop</code> 分支作为父分支。当新功能完成时，合并回 <code>develop</code> 分支。新功能提交应该从不直接与 <code>master</code> 分支交互。</li>
<li>一旦 <code>develop</code> 分支上有了做一次发布（或者说快到了既定的发布日）的足够功能，就从 <code>develop</code> 分支上 <code>fork</code> 一个 <code>release</code>分支。<br>
新建的分支用于开始发布循环，所以从这个时间点开始之后新的功能不能再加到这个分支上。 这个分支只应该做 <code>Bug</code> 修复、文档生成和其它面向发布任务。<br>
对外发布的工作完成后，发布分支会合并到 <code>master</code> 分支并分配一个版本号打好 <code>Tag</code>。另外，这些从新建发布分支以来的做的修改要合并回 <code>develop</code> 分支。</li>
<li><code>hotfix</code> 分支用于生成快速给产品发布版本（production releases）打补丁，修复完成，修改应该马上合并回 <code>master</code> 分支（打好 <code>Tag</code>）和 <code>develop</code> 分支（当前的发布分支）。</li>
</ol>
<h1 id="参考">参考</h1>
<ul>
<li><a href="https://github.com/bingoHuang/progit2-gitbook">Pro Git 第二版pdf</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2018/10/git-internals.html">Git 原理入门</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html">常用 Git 命令清单</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2014/06/git_remote.html">Git 远程操作详解</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2015/12/git-workflow.html">Git 工作流程</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2015/08/git-use-process.html">Git 使用规范流程</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2012/07/git.html">Git 分支管理策略</a></li>
<li><a href="http://guibin.iteye.com/blog/1014369">GIT 基本概念和用法总结</a></li>
<li><a href="http://blog.jobbole.com/76867/">Git 工作流指南：Gitflow 工作流</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Git——25个进阶技巧]]></title>
        <id>https://faded.auspicious.space/post/git-25-advanced-skills/</id>
        <link href="https://faded.auspicious.space/post/git-25-advanced-skills/">
        </link>
        <updated>2020-04-17T02:54:39.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p><a href="https://linux.cn/article-5418-1.html">25个 Git 进阶技巧</a></p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p><a href="https://linux.cn/article-5418-1.html">25个 Git 进阶技巧</a></p>
</blockquote>
<!-- more -->
<h1 id="基本技巧">基本技巧</h1>
<h2 id="1-安装后的第一步">1. 安装后的第一步</h2>
<p>在安装好 <code>git</code> 后，你第一件该做的事是设置你的名字和电子邮箱，因为每次提交都要用到这些信息：</p>
<pre><code class="language-bash">$ git config --global user.name &quot;Some One&quot;
$ git config --global user.email &quot;someone@gmail.com&quot;
</code></pre>
<h2 id="2-git-是基于指针的">2. Git 是基于指针的</h2>
<p>保存在 <code>git</code> 里的一切都是文件。当你创建一个提交的时候，会建立一个包含你的提交信息和相关数据（名字，邮件地址，日期/时间，前一个提交，等等）的文件，并把它链接到一个树文件中。这个树文件中包含了对象或其他树的列表。这里的提到的对象（或二进制大对象）是和本次提交相关的实际内容（它也是一个文件，另外，尽管文件名并没有包含在对象里，但是存储在树中）。所有这些文件都使用对象的 <code>SHA-1</code> 哈希值作为文件名。</p>
<p>用这种方式，分支和标签就是简单的文件（基本上是这样），包含指向该提交的 <code>SHA-1</code> 哈希值。使用这些索引会带来优秀的灵活性和速度，比如创建一个新分支就是简单地用分支名字和所分出的那个提交的 <code>SHA-1</code> 索引来创建一个文件。当然，你不需要自己做这些，而只要使用 <code>Git</code> 命令行工具（或者 GUI），但是实际上就是这么简单。</p>
<p>你也许听说过叫 <code>HEAD</code> 的索引。这只是简单的一个文件，包含了你当前指向的那个提交的 <code>SHA-1</code> 索引值。如果你正在解决一次合并冲突然后看到了 <code>HEAD</code>，这并不是一个特别的分支或分支上的一个必需的特殊位置，只是标明你当前所在位置。</p>
<p>所有的分支指针都保存在 <code>.git/refs/heads</code> 里，<code>HEAD</code> 在 <code>.git/HEAD</code> 里，而标签保存在 <code>.git/refs/tags</code> 里——自己可以随便进去看看。</p>
<h2 id="3-两个爸爸父节点-你没看错">3. 两个爸爸（父节点） - 你没看错！</h2>
<p>在历史中查看一个合并提交的信息时，你将看到有两个父节点（不同于工作副本上的常规提交的情况）。第一个父节点是你所在的分支，第二个是你合并过来的分支。</p>
<h2 id="4-合并冲突">4. 合并冲突</h2>
<p>目前我相信你碰到过合并冲突并且解决过。通常是编辑一下文件，去掉 <code>&lt;&lt;&lt;&lt;</code>，<code>====</code>，<code>&gt;&gt;&gt;&gt;</code> 标志，保留需要留下的代码。有时能够看到这两个修改之前的代码会很不错，比如，在这两个现在冲突的分支之前的改动。下面是一种方式：</p>
<pre><code class="language-bash">$ git diff --merge
diff --cc dummy.rb  
index 5175dde,0c65895..4a00477  
--- a/dummy.rb
+++ b/dummy.rb
@@@ -1,5 -1,5 +1,5 @@@
  class MyFoo
    def say
-     puts &quot;Bonjour&quot;
 -    puts &quot;Hello world&quot;
++    puts &quot;Annyong Haseyo&quot;
    end
  end
</code></pre>
<p>如果是二进制文件，比较差异就没那么简单了...通常你要做的就是测试这个二进制文件的两个版本来决定保留哪个（或者在二进制文件编辑器里手工复制冲突部分）。从一个特定分支获取文件拷贝（比如说你在合并 <code>master</code> 和 <code>feature123</code> 两个分支）：</p>
<pre><code class="language-bash">$ git checkout master flash/foo.fla # 或者...
$ git checkout feature132 flash/foo.fla
$ # 然后...
$ git add flash/foo.fla
</code></pre>
<p>另一种方式是通过 <code>git</code> 输出文件——你可以输出到另外的文件名，然后当你决定了要用哪个后，再将选定的正确文件复制为正常的文件名：</p>
<pre><code class="language-bash">$ git show master:flash/foo.fla &gt; master-foo.fla
$ git show feature132:flash/foo.fla &gt; feature132-foo.fla
$ # 检出master-foo.fla和feature132-foo.fla
$ # 假如说我们决定来自feature132的文件是正确的
$ rm flash/foo.fla
$ mv feature132-foo.fla flash/foo.fla
$ rm master-foo.fla
$ git add flash/foo.fla
</code></pre>
<p>更新：感谢 Carl 在原博客文章上评论里的提醒，你实际上可以用 <code>git checkout —ours flash/foo.fla</code> 和 <code>git checkout —theirs flash/foo.fla</code> 来检出特定版本的文件，而不用记住你在合并的分支名字。就我个人来说喜欢更精确一点，但这也是一种方式...</p>
<p>记着在解决完冲突后要将文件加入提交（像我上面做的那样）。</p>
<h1 id="服务器分支和标签">服务器，分支和标签</h1>
<h2 id="5-远端服务器">5. 远端服务器</h2>
<p><code>git</code> 的一个超强大的功能就是可以有不止一个远端服务器（实际上你一直都在一个本地仓库上工作）。你并不是一定都要有这些服务器的写权限，你可以有多个可以读取的服务器（用来合并他们的工作）然后写入到另外一个仓库。添加一个新的远端服务器很简单：</p>
<pre><code class="language-bash">$ git remote add john git@github.com:johnsomeone/someproject.git
</code></pre>
<p>如果你想查看远端服务器的信息可以这样做：</p>
<pre><code class="language-bash"># 显示每个远端服务器的URL
$ git remote -v 
# 提供更多详细信息
$ git remote show name 
</code></pre>
<p>你随时都可以查看本地分支和远端分支的差异：</p>
<pre><code class="language-bash">$ git diff master..john/master
</code></pre>
<p>你也可以查看没有在远端分支上的 <code>HEAD</code> 的改动：</p>
<pre><code class="language-bash">$ git log remote/branch..
# 注意：..后面没有结束的特定引用
</code></pre>
<h2 id="6-标签">6. 标签</h2>
<p>在 <code>git</code> 里有两种类型的标签——轻量级标签和带注释标签。记住<a href="#2-git-%E6%98%AF%E5%9F%BA%E4%BA%8E%E6%8C%87%E9%92%88%E7%9A%84">技巧 2</a> 里说过 <code>git</code> 是基于指针的，这两者之间的差异也很简单。轻量级标签只是一个简单的指向一次提交的带名字指针。你随时都可以将它指向另一个提交。带注释标签是一个指向标签对象的带名字指针，带有自己的信息和历史。因为有自己的信息，它可以根据需要用 <code>GPG</code> 签名。</p>
<p>建立这两种类型的标签都很简单（只有一个命令行开关的差异）</p>
<pre><code class="language-bash">$ git tag to-be-tested
$ git tag -a v1.1.0 # 会提示输入标签的信息
</code></pre>
<h2 id="7-建立分支">7. 建立分支</h2>
<p>在 <code>git</code> 里建立分支非常简单（而且像闪电一样快，因为它只需要创建一个小于 100 字节的文件）。用普通方式建立新分支并切换过去：</p>
<pre><code class="language-bash">$ git branch feature132
$ git checkout feature132
</code></pre>
<p>当然，如果你确定自己直接切换到新建的分支，可以用一个命令实现：</p>
<pre><code class="language-bash">$ git checkout -b feature132
</code></pre>
<p>如果你想重命名一个本地分支也很简单（可以显示发生了什么的较长的方式）：</p>
<pre><code class="language-bash">$ git checkout -b twitter-experiment feature132
$ git branch -d feature132
</code></pre>
<p>更新：你也可以（像 Brian Palmer 在原博客文章的评论里提出的）只用 <code>git branch</code> 的 <code>-m</code> 开关在一个命令里实现（像 Mike 提出的，如果你只指定了一个分支参数，就会重命名当前分支）：</p>
<pre><code class="language-bash">$ git branch -m twitter-experiment
$ git branch -m feature132 twitter-experiment
</code></pre>
<h2 id="8-合并分支">8. 合并分支</h2>
<p>也许在将来的某个时候，你希望将改动合并。有两种方式：</p>
<pre><code class="language-bash">$ git checkout master
$ git merge feature83 # 或者...
$ git rebase feature83
</code></pre>
<p><code>merge</code> 和 <code>rebase</code> 之间的差别是 <code>merge</code> 会尝试处理改动并建立一个新的混合了两者的提交。<code>rebase</code> 会尝试把你从一个分支最后一次分离后的所有改动，一个个加到该分支的 <code>HEAD</code> 上。不过，在已经将分支推到远端服务器后不要再 <code>rebase</code> 了 - 这会引起冲突/问题。</p>
<p>如果你不确定在哪些分支上还有独有的工作——所以你也不知道哪些分支需要合并而哪些可以删除，<code>git branch</code> 有两个开关可以帮你：</p>
<pre><code class="language-bash"># 显示已经全部合并到当前分支的分支
$ git branch --merged
# 显示没有合并到当前分支的分支
$ git branch --no-merged
</code></pre>
<h2 id="9-远端分支">9. 远端分支</h2>
<p>如果你在本地有一个分支希望推到远端服务器上，你可以用一行命令推送上去：</p>
<pre><code class="language-bash">$ git push origin twitter-experiment:refs/heads/twitter-experiment
# origin是我们服务器的名字，而twitter-experiment是分支名字
</code></pre>
<p>更新：感谢 Erlend 在原博客文章上的评论——这个实际上和 <code>git push origin twitter-experiment</code> 效果一样，不过使用完整的语法，你可以在两者之间使用不同的分支名（这样本地分支可以是 <code>add-ssl-support</code> 而远端是 issue-1723）。</p>
<p>如果你想在远端服务器上删除一个分支（注意分支名前面的冒号）：</p>
<pre><code class="language-bash">$ git push origin :twitter-experiment
</code></pre>
<p>如果你想查看所有远端分支的状态可以这样做：</p>
<pre><code class="language-bash">$ git remote show origin
</code></pre>
<p>这个命令可能会列出服务器上一些以前有过但现在已经不在了的分支。如果碰到这种情况你可以用下面的命令从你本地分支里清理掉：</p>
<pre><code class="language-bash">$ git remote prune
</code></pre>
<p>最后，如果你想在本地跟踪一个远端分支，普通的方式是：</p>
<pre><code class="language-bash">$ git branch --track myfeature origin/myfeature
$ git checkout myfeature
</code></pre>
<p>不过，新版的 <code>git</code> 在使用 <code>-b</code> 标记检出分支时会自动设定跟踪：</p>
<pre><code class="language-bash">$ git checkout -b myfeature origin/myfeature
</code></pre>
<h1 id="在储藏点索引和文件系统中保存内容">在储藏点，索引和文件系统中保存内容</h1>
<h2 id="10-储藏">10. 储藏</h2>
<p>在 <code>git</code> 里你可以把当前工作状态放进一个储藏堆栈中，然后可以再取出来。最简单的情形是下面这样：</p>
<pre><code class="language-bash">$ git stash
# 做点其他事情...
$ git stash pop
</code></pre>
<p>许多人建议使用 <code>git stash apply</code> 来代替 <code>pop</code>，不过如果这样做的话最后会遗留一个很长的储藏列表。而 <code>pop</code> 会在全部加载后自动从堆栈中移除。如果使用过 <code>git stash apply</code>，你也可以使用下面的命令从堆栈上移除最后一项：</p>
<pre><code class="language-bash">$ git stash drop
</code></pre>
<p><code>git</code> 会基于当前的提交信息自动创建评论。如果你更希望有自定义信息的话（因为它可能和前一个提交没有任何联系）：</p>
<pre><code class="language-bash">$ git stash save &quot;My stash message&quot;
</code></pre>
<p>如果你希望从列表中取出一个特定的储藏点（不一定非得是最后一个）可以先列出它们然后用下面的方式取出：</p>
<pre><code class="language-bash">$ git stash list
  stash@{0}: On master: Changed to German
  stash@{1}: On master: Language is now Italian
$ git stash apply stash@{1}
</code></pre>
<h2 id="11-交互式添加">11. 交互式添加</h2>
<p>在 <code>subversion</code> 的世界里你只能修改文件然后提交所有改动。而在 <code>git</code> 里你有强大得多的方式来提交部分文件或者甚至是部分补丁。提交部分文件或文件中的部分改动你需要进入交互式模式：</p>
<pre><code class="language-bash">$ git add -i
           staged     unstaged path
*** Commands ***
  1: status      2: update   3: revert   4: add untracked
  5: patch      6: diff     7: quit     8: help
What now&gt;  
</code></pre>
<p>这会让你进入一个基于菜单的交互式提示。你可以使用命令中的数字或高亮的字母（如果你在终端里打开了高亮的话）来进入相应的模式。然后就只是输入你希望操作的文件的数字了（你可以使用这样的格式，<code>1</code> 或者 <code>1-4</code> 或 <code>2,4,7</code>）。</p>
<p>如果你想进入补丁模式（交互式模式下按 <code>p</code> 或 <code>5</code>），你也可以直接进入：</p>
<pre><code class="language-bash">$ git add -p    
diff --git a/dummy.rb b/dummy.rb  
index 4a00477..f856fb0 100644  
--- a/dummy.rb
+++ b/dummy.rb
@@ -1,5 +1,5 @@
 class MyFoo
   def say
-    puts &quot;Annyong Haseyo&quot;
+    puts &quot;Guten Tag&quot;
   end
 end
Stage this hunk [y,n,q,a,d,/,e,?]?  
</code></pre>
<p>你可以看到下方会有一些选项供选择用来添加该文件的这个改动、该文件的所有改动，等等。使用 <code>?</code> 命令可以详细解释这些选项。</p>
<h2 id="12-从文件系统里保存取回改动">12. 从文件系统里保存/取回改动</h2>
<p>有些项目（比如 <code>Git</code> 项目本身）在 <code>git</code> 文件系统中直接保存额外文件而并没有将它们加入到版本控制中。<br>
让我们从在 <code>git</code> 中存储一个随机文件开始：</p>
<pre><code class="language-bash">$ echo &quot;Foo&quot; | git hash-object -w --stdin
51fc03a9bb365fae74fd2bf66517b30bf48020cb  
</code></pre>
<p>这样这个目标文件就已经保存到数据库中了，但是如果你没有设定一个指向它的指针的话它会被当做垃圾回收。最简单的方式是设定一个标签：</p>
<pre><code class="language-bash">$ git tag myfile 51fc03a9bb365fae74fd2bf66517b30bf48020cb
</code></pre>
<p>注意这里我们使用了标签 <code>myfile</code>。当我们需要使用这个文件的时候可以这样做：</p>
<pre><code class="language-bash">$ git cat-file blob myfile
</code></pre>
<p>这个对于一些工具文件很有用，开发者可能会用到（密码，<code>GPG</code> 密钥，等等）但是又不希望每次都检出到硬盘（尤其是在实际工作中）。</p>
<h1 id="日志以及有哪些改动">日志以及有哪些改动？</h1>
<h2 id="13-查看日志">13. 查看日志</h2>
<p>长时间使用 <code>Git</code> 的话，不会没用过 <code>git log</code> 来查看最近的提交。不过，有一些技巧来更好地应用。比如，你可以使用下面的命令来查看每次提交的具体改动：</p>
<pre><code class="language-bash">$ git log -p
</code></pre>
<p>或者你可以仅仅查看有哪些文件改动：</p>
<pre><code class="language-bash">$ git log --stat
</code></pre>
<p>有个很不错的别名你可以试试，会显示简短提交名和一个不错的分支图并在一行里显示提交信息（有点像 <code>gitk</code>，但是是在命令行下）：</p>
<pre><code class="language-bash">$ git config --global alias.lol &quot;log --pretty=oneline --abbrev-commit --graph --decorate&quot;
$ git lol
* 4d2409a (master) Oops, meant that to be in Korean
* 169b845 Hello world
</code></pre>
<h2 id="14-搜索日志">14. 搜索日志</h2>
<p>如果你想找特定提交者可以这样做：</p>
<pre><code class="language-bash">$ git log --author=Andy
</code></pre>
<p>更新：感谢 Johannes 的评论，我已经去掉了之前这里的一些有混淆的地方。</p>
<p>或者你想在提交信息里找一些相关字段：</p>
<pre><code class="language-bash">$ git log --grep=&quot;Something in the message&quot;
</code></pre>
<p>也有一个更强大的叫做 <code>pickaxe</code> 的命令用来查找包含了删除或添加的某个特定内容的提交（比如，该内容第一次出现或被删除）。这可以告诉你什么时候增加了一行（但这一行里的某个字符后面被改动过就不行了）：</p>
<pre><code class="language-bash">$ git log -S &quot;TODO: Check for admin status&quot;
</code></pre>
<p>假如你改动了一个特定的文件，比如 <code>lib/foo.rb</code></p>
<pre><code class="language-bash">$ git log lib/foo.rb
</code></pre>
<p>比如说你有一个 <code>feature/132</code> 分支和 <code>feature/145</code> 分支，然后你想看看这两个分支上不在 <code>master</code> 分支里的提交（注意符号 <code>^</code> 是不在的意思）：</p>
<pre><code class="language-bash">$ git log feature/132 feature/145 ^master
</code></pre>
<p>你也可以使用 <code>ActiveSupport</code> 格式的日期来缩小到某个日期范围：</p>
<pre><code class="language-bash">$ git log --since=2.months.ago --until=1.day.ago
</code></pre>
<p>默认情况下会用 <code>OR</code> 来组合查询，但你可以轻易地改为 <code>AND</code>（如果你有超过一条的查询标准）</p>
<pre><code class="language-bash">$ git log --since=2.months.ago --until=1.day.ago --author=andy -S &quot;something&quot; --all-match
</code></pre>
<h2 id="15-查看修改版本">15. 查看/修改版本</h2>
<p>有很多方式可以用来引用一个版本，看你记得哪个：</p>
<pre><code class="language-bash">$ git show 12a86bc38 # 根据版本
$ git show v1.0.1 # 根据标签
$ git show feature132 # 根据分支名
$ git show 12a86bc38^ # 一次提交的父节点
$ git show 12a86bc38~2 # 一次提交的祖父节点
$ git show feature132@{yesterday} # 时间相关
$ git show feature132@{2.hours.ago} # 时间相关
</code></pre>
<p>注意和之前部分有些不同，末尾 <code>^</code> 的意思是该提交的父节点——开始位置 <code>^</code> 的意思是不在这个分支。</p>
<h2 id="16-选择范围">16. 选择范围</h2>
<p>最简单的方式：</p>
<pre><code class="language-bash">$ git log origin/master..new
# [old]..[new] - 所有你还没有推送的提交
</code></pre>
<p>你也可以省略 <code>[new]</code>，将使用当前的 <code>HEAD</code>。</p>
<h1 id="时光回溯和后悔药">时光回溯和后悔药</h1>
<h2 id="17-重置改动">17. 重置改动</h2>
<p>如果你还没有提交的话可以用下面的命令轻松地取消改动：</p>
<pre><code class="language-bash">$ git reset HEAD lib/foo.rb
</code></pre>
<p>通常会使用 <code>unstage</code> 的别名，因为上面的看上去有些不直观。</p>
<pre><code class="language-bash">$ git config --global alias.unstage &quot;reset HEAD&quot;
$ git unstage lib/foo.rb
</code></pre>
<p>如果你已经提交了该文件，你可以做两件事 - 如果是最后一次提交你还可以改正：</p>
<pre><code class="language-bash">$ git commit --amend
</code></pre>
<p>这会取消最后一次提交，把工作分支回退到提交前标记了所有改动的状态，而且提交信息也都准备好可以修改或直接提交。</p>
<p>如果你已经提交过多次而且希望全部回退，你可以将分支重置到合适的位置。</p>
<pre><code class="language-bash">$ git checkout feature132
$ git reset --hard HEAD~2
</code></pre>
<p>如果你实际上希望将分支指向一个完全不同的 <code>SHA1</code>（也许你要将一个分支的 <code>HEAD</code> 替换到另一个分支，或者之后的某次提交）你可以使用下面的较长的方式：</p>
<pre><code class="language-bash">$ git checkout FOO
$ git reset --hard SHA
</code></pre>
<p>实际上有一个快速的方式（不需要先把你的工作分支切换到 <code>FOO</code> 再前进到 <code>SHA</code>）：</p>
<pre><code class="language-bash">$ git update-ref refs/heads/FOO SHA
</code></pre>
<h2 id="18-提交到了错误的分支">18. 提交到了错误的分支</h2>
<p>好吧，假如说你已经提交到了 <code>master</code>，但却应该创建一个叫 <code>experimental</code> 的主题分支更合适。要移动这些改动，你可以在当前位置创建分支，回退 <code>HEAD</code> 再检出新分支：</p>
<pre><code class="language-bash">$ git branch experimental   # 创建一个指向当前master的位置的指针
$ git reset --hard master~3 # 移动master分支的指针到3个版本之前
$ git checkout experimental
</code></pre>
<p>如果你的改动是在分支的分支的分支上会更复杂。那样你需要做的是将分支基础切换到其他地方：</p>
<pre><code class="language-bash">$ git branch newtopic STARTPOINT
$ git rebase oldtopic --onto newtopic
</code></pre>
<h2 id="19-交互式切换基础">19. 交互式切换基础</h2>
<p>这是一个我之前看过展示却没真正理解过的很赞的功能，现在觉得它就很简单了。假如说你提交了3次但是你希望更改顺序或编辑（或者合并）：</p>
<pre><code class="language-bash">$ git rebase -i master~3
</code></pre>
<p>然后这会启动你的编辑器并带有一些指令。你所要做的就是修改这些指令来选择/插入/编辑（或者删除）提交和保存/退出。然后在编辑完后你可以用 <code>git rebase --continue</code> 命令来让每一条指令生效。</p>
<p>如果你有修改，将会切换到你提交时所处的状态，之后你需要使用命令 <code>git commit --amend</code> 来编辑。</p>
<table>
<thead>
<tr>
<th>注意：在 <code>rebase</code> 的时候千万不要提交 - 只能先添加然后使用参数 <code>--continue</code>，<code>--skip</code> 或 <code>--abort</code>。</th>
</tr>
</thead>
<tbody></tbody>
</table>
<h2 id="20-清理">20. 清理</h2>
<p>如果你提交了一些内容到你的分支（也许你从 <code>SVN</code> 导入了一些旧仓库），然后你希望把某个文件从历史记录中全部删掉：</p>
<pre><code class="language-bash">$ git filter-branch --tree-filter 'rm -f *.class' HEAD
</code></pre>
<p>如果你已经推送到 <code>origin</code> 了，但之后提交了一些垃圾改动，你也可以在推送前在本地系统里这样做：</p>
<pre><code class="language-bash">$ git filter-branch --tree-filter 'rm -f *.class' origin/master..HEAD
</code></pre>
<h1 id="其他技巧">其他技巧</h1>
<h2 id="21-你查看过的前一个引用">21. 你查看过的前一个引用</h2>
<p>如果你知道自己之前查看过一个 <code>SHA-1</code>，但是随后做了一些重置/回退的操作，你可以使用 <code>reflog</code> 命令来列出最近查看过的 <code>SHA-1</code> 记录：</p>
<pre><code class="language-bash">$ git reflog
$ git log -g # 和上面一样，但是使用'log'格式输出
</code></pre>
<h2 id="22-分支命名">22. 分支命名</h2>
<p>一个可爱的小技巧 - 别忘了分支名并不限于 <code>a-z</code> 和 <code>0-9</code>。名字中可以用/和.将非常方便用来建立伪命名空间或版本，例如：</p>
<pre><code class="language-bash">$ # 生成版本132的改动历史
$ git shortlog release/132 ^release/131
$ # 贴上v1.0.1的标签
$ git tag v1.0.1 release/132
</code></pre>
<h2 id="23-找出谁是凶手">23. 找出谁是凶手</h2>
<p>通常找出来谁改动了某个文件里的某行代码会很有用。实现这个功能的最简单命令是：</p>
<pre><code class="language-bash">$ git blame FILE
</code></pre>
<p>有时候这些改动来自其他文件（如果你合并了两个文件，或者你移动了某个函数）所以你可以使用下面的命令：</p>
<pre><code class="language-bash">$ # 显示内容来自哪个文件
$ git blame -C FILE
</code></pre>
<p>有时候通过点击各个改动然后回到很早很早以前来跟踪改动会很不错。有一个很好的内建 GUI 命令来做这个：</p>
<pre><code class="language-bash">$ git gui blame FILE
</code></pre>
<h2 id="24-数据维护">24. 数据维护</h2>
<p>通常 <code>git</code> 不需要经常维护，它把自己照顾的很好。不过，你可以通过下面的命令查看数据统计：</p>
<pre><code class="language-bash">$ git count-objects -v
</code></pre>
<p>如果占用很多空间的话，你可以选择在你的本地仓库做垃圾回收。这不会影响推送或其他人，却会让一些命令运行更快而且减少空间占用：</p>
<pre><code class="language-bash">$ git gc
</code></pre>
<p>经常运行完整性检查也很有意义：</p>
<pre><code class="language-bash">$ git fsck --full
</code></pre>
<p>你也可以在末尾加上 <code>--auto</code> 参数（如果你在服务器上通过 <code>crontab</code> 经常/每天都运行这个命令的话），然后它只会在必要的时候才执行 fsck` 动作。</p>
<p>在检查的时候，看到 <code>dangling</code> 或 <code>unreachable</code> 是正常的，通常这是由回退 <code>HEAD</code> 或切换基础的结果。而看到 <code>missing</code> 或 <code>sha1 mismatch</code> 就不对了...找专业人士帮忙吧！</p>
<h2 id="25-恢复遗失的分支">25. 恢复遗失的分支</h2>
<p>如果你使用 <code>-D</code> 参数删除了 <code>experimental</code> 分支，可以用下面的命令重新建立：</p>
<pre><code class="language-bash">$ git branch experimental SHA1_OF_HASH
</code></pre>
<p>如果你最近访问过的话，你通常可以用 <code>git reflog</code> 来找到 <code>SHA1</code> 哈希值。</p>
<p>另一种方式是使用 <code>git fsck —lost-found</code>。其中一个 <code>dangling</code> 的提交就是丢失的 <code>HEAD</code>（它只是已删除分支的 <code>HEAD</code>，而 <code>HEAD</code> 被引用为当前的 <code>HEAD</code> 所以它并不处于 <code>dangling</code> 状态）。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Git——4 个阶段的撤销更改]]></title>
        <id>https://faded.auspicious.space/post/git-four-stages-of-reset/</id>
        <link href="https://faded.auspicious.space/post/git-four-stages-of-reset/">
        </link>
        <updated>2020-04-17T02:20:22.000Z</updated>
        <summary type="html"><![CDATA[<p>错误修改了代码不要紧，这里教你如何恢复以前的正确代码。</p>
]]></summary>
        <content type="html"><![CDATA[<p>错误修改了代码不要紧，这里教你如何恢复以前的正确代码。</p>
<!-- more -->
<blockquote>
<p><a href="https://www.fengerzh.com/git-reset/">Git的4个阶段的撤销更改</a></p>
</blockquote>
<figure data-type="image" tabindex="1"><img src="https://faded.auspicious.space/post-images/1587090203607.png" alt="" loading="lazy"></figure>
<p>虽然 <code>git</code> 诞生距今已有 12 年之久，网上各种关于 <code>git</code> 的介绍文章数不胜数，但是依然有很多人（包括我自己在内）对于它的功能不能完全掌握。以下的介绍只是基于我个人对于 <code>git</code> 的理解，并且可能生编硬造了一些不完全符合 <code>git</code> 说法的词语。目的只是为了让 <code>git</code> 通俗化，使初学者也能大概了解如何快速上手 <code>git</code>。同时，下面所有讨论，我们都假设只使用一个分支，也就是主分支 <code>master</code> 的情况，虽然这种作法并不符合 <code>git</code> 规范，但是现实情况中绝大部分用户是直接在 <code>master</code> 分支上进行工作的，所以在这里我们不去引入更加复杂的各种分支的情况，也不涉及标签 <code>tag</code> 的操作，只讲在最简单的主分支上如何回退。</p>
<h1 id="基本概念">基本概念</h1>
<h2 id="3-个步骤">3 个步骤</h2>
<p><img src="https://faded.auspicious.space/post-images/1587090327591.png" alt="" loading="lazy"><br>
正常情况下，我们的工作流就是 3 个步骤，对应上图中的 3 个箭头线：</p>
<pre><code class="language-bash">git add .
git commit -m &quot;comment&quot;
git push
</code></pre>
<ol>
<li><code>git add .</code> 把所有文件放入暂存区；</li>
<li><code>git commit</code> 把所有文件从暂存区提交进本地仓库；</li>
<li><code>git push</code> 把所有文件从本地仓库推送进远程仓库。</li>
</ol>
<h2 id="4-个区">4 个区</h2>
<p><code>git</code> 之所以令人费解，主要是它相比于 <code>svn</code> 等等传统的版本管理工具，多引入了一个暂存区（Stage）的概念，就因为多了这一个概念，而使很多人疑惑。其实，在初学者来说，每个区具体怎么工作的，我们完全不需要关心，而只要知道有这么 4 个区就够了：</p>
<ul>
<li>工作区（Working Area）</li>
<li>暂存区（Stage）</li>
<li>本地仓库（Local Repository）</li>
<li>远程仓库（Remote Repository）</li>
</ul>
<h2 id="5-种状态">5 种状态</h2>
<p>以上 4 个区，进入每一个区成功之后会产生一个状态，再加上最初始的一个状态，一共是 5 种状态。以下我们把这 5 种状态分别命名为：</p>
<ul>
<li>未修改（Origin）</li>
<li>已修改（Modified）</li>
<li>已暂存（Staged）</li>
<li>已提交（Committed）</li>
<li>已推送（Pushed）</li>
</ul>
<h1 id="检查修改">检查修改</h1>
<p>了解了基本概念之后，我们来谈一谈犯错误之后如何撤销的问题。首先，我们要了解如何检查这 3 个步骤当中每一个步骤修改了什么，然后才好判断有没有修改成功。检查修改的二级命令都相同，都是 <code>diff</code>，只是参数有所不同。</p>
<h2 id="已修改未暂存">已修改，未暂存</h2>
<pre><code class="language-bash">git diff
</code></pre>
<p>首先，我们来看一下，如果我们只是简单地在浏览器里保存了一下文件，但是还没有做 <code>git add .</code> 之前，我们如何检查有哪些修改。我们先随便拿一个文件来做一下实验：<br>
<img src="https://faded.auspicious.space/post-images/1587090638955.png" alt="" loading="lazy"><br>
我们在文件开头的第 2 行胡乱加了 4 个数字 <code>1234</code>，存盘，这时文件进入了<strong>已修改</strong>状态，但是还没有进入<strong>暂存区</strong>，我们运行 <code>git diff</code>，结果如下：</p>
<pre><code class="language-bash">diff --git a/index.md b/index.md
index 73ff1ba..1066758 100644
--- a/index.md
+++ b/index.md
@@ -1,5 +1,5 @@
 ---
-layout: main
+1234layout: main
 color: black
 ---
</code></pre>
<p><code>git diff</code> 的结果告诉我们哪些文件已经做了哪些修改。</p>
<h2 id="已暂存未提交">已暂存，未提交</h2>
<pre><code class="language-bash">git diff --cached
</code></pre>
<p>现在我们把修改放入<strong>暂存区</strong>看一下。先执行 <code>git add .</code>，然后执行 <code>git diff</code>，你会发现没有任何结果：<br>
<img src="https://faded.auspicious.space/post-images/1587090841347.png" alt="" loading="lazy"><br>
这说明 <code>git diff</code> 这个命令只检查我们的<strong>工作区</strong>和<strong>暂存区</strong>之间的差异，如果我们想看到<strong>暂存区</strong>和<strong>本地仓库</strong>之间的差异，就需要加一个参数 <code>git diff --cached</code>：</p>
<pre><code class="language-bash">diff --git a/index.md b/index.md
index 73ff1ba..1066758 100644
--- a/index.md
+++ b/index.md
@@ -1,5 +1,5 @@
 ---
-layout: main
+1234layout: main
 color: black
 ---
</code></pre>
<p>这时候我们看到的差异是<strong>暂存区</strong>和<strong>本地仓库</strong>之间的差异。</p>
<h2 id="已提交未推送">已提交，未推送</h2>
<pre><code class="language-bash">git diff master origin/master
</code></pre>
<p>现在，我们把修改从<strong>暂存区</strong>提交到<strong>本地仓库</strong>，再看一下差异。先执行 <code>git commit</code>，然后再执行 <code>git diff --cached</code>，没有差异，执行 <code>git diff master origin/master</code>，可以看到差异：<br>
<img src="https://faded.auspicious.space/post-images/1587091065745.png" alt="" loading="lazy"><br>
在这里，<code>master</code> 就是你的本地仓库，而 <code>origin/master</code> 就是你的远程仓库，<code>master</code> 是主分支的意思，因为我们都在主分支上工作，所以这里两边都是 <code>master</code>，而 <code>origin</code> 就代表远程。</p>
<h1 id="撤销修改">撤销修改</h1>
<p>了解清楚如何检查各种修改之后，我们开始尝试各种撤销操作。</p>
<h2 id="恢复已修改未暂存">恢复已修改，未暂存</h2>
<p>如果我们只是在编辑器里修改了文件，但还没有执行 <code>git add .</code>，这时候我们的文件还在<strong>工作区</strong>，并没有进入<strong>暂存区</strong>，我们可以用：</p>
<pre><code class="language-bash">git checkout .
</code></pre>
<p>或者</p>
<pre><code class="language-bash">git reset --hard
</code></pre>
<p>来进行撤销操作。<br>
<img src="https://faded.auspicious.space/post-images/1587091296924.png" alt="" loading="lazy"><br>
可以看到，在执行完 <code>git checkout .</code> 之后，修改已被撤销，<code>git diff</code> 没有任何内容了。</p>
<table>
<thead>
<tr>
<th>一对反义词 &gt; <code>git add .</code> 的反义词是 <code>git checkout .</code>。做完修改之后，如果你想向前走一步，让修改进入暂存区，就执行 <code>git add .</code>，如果你想向后退一步，撤销刚才的修改，就执行 <code>git checkout .</code>。</th>
</tr>
</thead>
<tbody></tbody>
</table>
<h2 id="恢复已暂存未提交">恢复已暂存，未提交</h2>
<p>你已经执行了 <code>git add .</code>，但还没有执行 <code>git commit -m &quot;comment&quot;</code>。这时候你意识到了错误，想要撤销，你可以执行：</p>
<pre><code class="language-bash">git reset
git checkout .
</code></pre>
<p>或者</p>
<pre><code class="language-bash">git reset --hard
</code></pre>
<p><code>git reset</code> 只是把修改退回到了 <code>git add .</code> 之前的状态，也就是说文件本身还处于<strong>已修改未暂存</strong>状态，你如果想退回<strong>未修改</strong>状态，还需要执行 <code>git checkout .</code>。</p>
<p>或许你已经注意到了，以上两个步骤都可以用同一个命令 <code>git reset --hard</code> 来完成。是的，就是这个强大的命令，可以一步到位地把你的修改完全恢复到<strong>未修改</strong>的状态。</p>
<h2 id="恢复已提交未推送">恢复已提交，未推送</h2>
<p>你的手太快，你既执行了 <code>git add .</code>，又执行了 <code>git commit</code>，这时候你的代码已经进入了你的<strong>本地仓库</strong>，然而你后悔了，怎么办？不要着急，还有办法。</p>
<pre><code class="language-bash">git reset --hard origin/master
</code></pre>
<p>还是这个 <code>git reset --hard</code> 命令，只不过这次多了一个参数 <code>origin/master</code>，正如我们上面讲过的，<code>origin/master</code> 代表<strong>远程仓库</strong>，既然你已经污染了你的<strong>本地仓库</strong>，那么就从<strong>远程仓库</strong>把代码取回来吧。</p>
<h2 id="已推送">已推送</h2>
<p>很不幸，你的手实在是太快了，你既 <code>git add</code> 了，又 <code>git commit</code> 了，并且还 <code>git push</code> 了，这时你的代码已经进入<strong>远程仓库</strong>。如果你想恢复的话，还好，由于你的<strong>本地仓库</strong>和<strong>远程仓库</strong>是等价的，你只需要先恢复<strong>本地仓库</strong>，再强制 <code>push</code> 到<strong>远程仓库</strong>就好了：</p>
<pre><code class="language-bash">git reset --hard HEAD^
git push -f
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://faded.auspicious.space/post-images/1587091677820.png" alt="" loading="lazy"></figure>
<h1 id="总结">总结</h1>
<p>以上 4 种状态的撤销我们都用到了同一个命令 <code>git reset --hard</code>，前 2 种状态的用法甚至完全一样，所以只要掌握了 <code>git reset --hard</code> 这个命令的用法，从此你再也不用担心提交错误了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JavaScript——发现闭包的强大威力]]></title>
        <id>https://faded.auspicious.space/post/javascript-discover-the-power-of-closures/</id>
        <link href="https://faded.auspicious.space/post/javascript-discover-the-power-of-closures/">
        </link>
        <updated>2020-04-15T04:57:02.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p><a href="https://juejin.im/post/5c4e6a90e51d4552266576d2">[译]发现 JavaScript 中闭包的强大威力</a></p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p><a href="https://juejin.im/post/5c4e6a90e51d4552266576d2">[译]发现 JavaScript 中闭包的强大威力</a></p>
</blockquote>
<!-- more -->
<p>闭包是一个可以访问外部作用域的内部函数，即使这个外部作用域已经执行结束。</p>
<h1 id="1-作用域">1 作用域</h1>
<p>作用域决定这个变量的生命周期及其可见性。 当我们创建了一个函数或者 <code>{}</code> 块，就会生成一个新的作用域。需要注意的是，通过 <code>var</code> 创建的变量只有函数作用域，而通过 <code>let</code> 和 <code>const</code> 创建的变量既有函数作用域，也有块作用域。</p>
<h1 id="2-嵌套作用域">2 嵌套作用域</h1>
<p>在 JavasScript 中函数里面可以嵌套函数，如下：</p>
<pre><code class="language-javascript">(function autorun(){
    let x = 1;
    function log(){ 
       console.log(x); 
    }
    log();
})();
</code></pre>
<p><code>log()</code> 即是一个嵌套在 <code>autorun()</code> 函数里面的函数。在 <code>log()</code> 函数里面可以通过外部函数访问到变量 <code>x</code>。此时，<code>log()</code> 函数就是一个闭包。</p>
<p>闭包就是内部函数，我们可以通过在一个函数内部或者 <code>{}</code> 块里面定义一个函数来创建闭包。</p>
<h2 id="21-外部函数作用域">2.1 外部函数作用域</h2>
<p>内部函数可以访问外部函数中定义的变量，即使外部函数已经执行完毕。如下：</p>
<pre><code class="language-javascript">(function autorun(){
    let x = 1;
    setTimeout(function log(){
      console.log(x);
    }, 10000);
})();
</code></pre>
<p>并且，内部函数还可以访问外部函数中定义的形参，如下：</p>
<pre><code class="language-javascript">(function autorun(p){
    let x = 1;
    setTimeout(function log(){
      console.log(x);//1
      console.log(p);//10
    }, 10000);
})(10);
</code></pre>
<h2 id="22-外部块作用域">2.2 外部块作用域</h2>
<p>内部函数可以访问外部块中定义的变量，即使外部块已执行完毕，如下：</p>
<pre><code class="language-javascript">{
    let x = 1;
    setTimeout(function log(){
      console.log(x);
    }, 10000);
}
</code></pre>
<h1 id="3-词法作用域">3 词法作用域</h1>
<p>词法作用域是指内部函数在定义的时候就决定了其外部作用域。</p>
<p>看如下代码：</p>
<pre><code class="language-javascript">(function autorun(){
    let x = 1;
    function log(){
      console.log(x);
    };
    
    function run(fn){
      let x = 100;
      fn();
    }
    
    run(log);//1
})();
</code></pre>
<p><code>log()</code> 函数是一个闭包，它在这里访问的是 <code>autorun()</code> 函数中的 <code>x</code> 变量，而不是 <code>run</code> 函数中的变量。</p>
<p>❗️<strong>闭包的外部作用域是在其定义的时候已决定，而不是执行的时候。</strong></p>
<p><code>autorun()</code> 的函数作用域即是 <code>log()</code> 函数的词法作用域。</p>
<h1 id="4-作用域链">4 作用域链</h1>
<p>每一个作用域都有对其父作用域的引用。当我们使用一个变量的时候，JavaScript 引擎 会通过变量名在当前作用域查找，若没有查找到，会一直沿着作用域链一直向上查找，直到 <code>global</code> 全局作用域。</p>
<p>示例如下：</p>
<pre><code class="language-javascript">let x0 = 0;
(function autorun1(){
 let x1 = 1;
  
 (function autorun2(){
   let x2 = 2;
  
   (function autorun3(){
     let x3 = 3;
      
     console.log(x0 + &quot; &quot; + x1 + &quot; &quot; + x2 + &quot; &quot; + x3);//0 1 2 3
    })();
  })();
})();
</code></pre>
<p>我们可以看到，<code>autorun3()</code> 这个内部函数可以访问其自身局部变量 <code>x3</code> ，也可以访问外部作用域中的 <code>x1</code> 和 <code>x2</code> 变量，以及全局作用域中的 <code>x0</code> 变量。即：闭包可以访问其外部（父）作用域中的定义的所有变量。</p>
<h2 id="41-外部作用域执行完毕后">4.1 外部作用域执行完毕后</h2>
<p>当外部作用域执行完毕后，内部函数还存活（仍在其他地方被引用）时，闭包才真正发挥其作用。譬如以下几种情况：</p>
<ul>
<li>在异步任务例如 <code>timer</code> 定时器，事件处理，<code>Ajax</code> 请求中被作为回调。</li>
<li>被外部函数作为返回结果返回，或者返回结果对象中引用该内部函数。</li>
</ul>
<p>考虑如下的几个示例：</p>
<h3 id="411-timer">4.1.1 Timer</h3>
<pre><code class="language-javascript">(function autorun(){
    let x = 1;
    setTimeout(function log(){
      console.log(x);
    }, 10000);
})();
</code></pre>
<p>变量 <code>x</code> 将一直存活着直到定时器的回调执行或者 <code>clearTimeout()</code> 被调用。<br>
如果这里使用的是 <code>setInterval()</code>，那么变量 <code>x</code> 将一直存活到 <code>clearInterval()</code> 被调用。</p>
<p><em>译者注：原文中说变量 <code>x</code> 一直存活到 <code>setTimeout()</code> 或者 <code>setInterval()</code> 被调用是错误的。</em></p>
<h3 id="412-event">4.1.2 Event</h3>
<pre><code class="language-javascript">(function autorun(){
    let x = 1;
    $(&quot;#btn&quot;).on(&quot;click&quot;, function log(){
      console.log(x);
    });
})();
</code></pre>
<p>当变量 <code>x</code> 在事件处理函数中被使用时，它将一直存活直到该事件处理函数被移除。</p>
<h3 id="413-ajax">4.1.3 Ajax</h3>
<pre><code class="language-javascript">(function autorun(){
    let x = 1;
    fetch(&quot;http://&quot;).then(function log(){
      console.log(x);
    });
})();
</code></pre>
<p>变量 <code>x</code> 将一直存活到接收到后端返回结果，回调函数被执行。</p>
<p>在已上几个示例中，我们可以看到，<code>log()</code> 函数在父函数执行完毕后还一直存活着，<code>log()</code> 函数就是一个闭包。</p>
<p>除了 <code>timer</code> 定时器，事件处理，<code>Ajax</code> 请求等比较常见的异步任务，还有其他的一些异步 API 比如 <code>HTML5 Geolocation</code>，<code>WebSockets</code>，<code>requestAnimationFrame()</code> 也将使用到闭包的这一特性。</p>
<p>变量的生命周期取决于闭包的生命周期。被闭包引用的外部作用域中的变量将一直存活直到闭包函数被销毁。如果一个变量被多个闭包所引用，那么直到所有的闭包被垃圾回收后，该变量才会被销毁。</p>
<h1 id="5-闭包与循环">5 闭包与循环</h1>
<p>闭包只存储外部变量的引用，而不会拷贝这些外部变量的值。 查看如下示例：</p>
<pre><code class="language-javascript">function initEvents(){
  for(var i=1; i&lt;=3; i++){
    $(&quot;#btn&quot; + i).click(function showNumber(){
      alert(i);//4
    });
  }
}
initEvents();
</code></pre>
<p>在这个示例中，我们创建了 3 个闭包，皆引用了同一个变量 <code>i</code>，且这三个闭包都是事件处理函数。由于变量 <code>i</code> 随着循环自增，因此最终输出的都是同样的值。</p>
<p>修复这个问题最简单的方法是在 <code>for</code> 语句块中使用 <code>let</code> 变量声明，这将在每次循环中为 <code>for</code> 语句块创建一个新的局部变量。如下：</p>
<pre><code class="language-javascript">function initEvents(){
  for(let i=1; i&lt;=3; i++){
    $(&quot;#btn&quot; + i).click(function showNumber(){
      alert(i); // 1 2 3
    });
  }
}
initEvents();
</code></pre>
<p>但是，如果变量声明在 <code>for</code> 语句块之外的话，即使用了 <code>let</code> 变量声明，所有的闭包还是会引用同一个变量，最终输出的还是同一个值。</p>
<h1 id="6-闭包与封装性">6 闭包与封装性</h1>
<p>封装性意味着信息隐藏。</p>
<h2 id="61-函数与私有状态">6.1 函数与私有状态</h2>
<p>通过闭包，我们可以创建拥有私有状态的函数，闭包使得状态被封装起来。</p>
<h2 id="62-工厂模式与私有原型对象">6.2 工厂模式与私有原型对象</h2>
<p>我们先来看一个通过原型创建对象的常规方式，如下：</p>
<pre><code class="language-javascript">let todoPrototype = {
  toString : function() {
    return this.id + &quot; &quot; + this.userName + &quot;: &quot; + this.title;
  }
}
function Todo(todo){
  let newTodo = Object.create(todoPrototype);
  Object.assign(newTodo, todo);
  return newTodo;
}
</code></pre>
<p>在这个例子中，<code>todoPrototype</code> 原型对象是一个全局对象。</p>
<p>我们可以通过闭包，只用创建原型对象一次，也能够被所有 <code>Todo</code> 函数调用所公用，并且保证其私有性。示例如下：</p>
<pre><code class="language-javascript">let Todo = (function createTodoFactory(){
  let todoPrototype = {
    toString : function() {
      return this.id + &quot; &quot; + this.userName + &quot;: &quot; + this.title;
    }
  }
  return function(todo){
    let newTodo = Object.create(todoPrototype);
    Object.assign(newTodo, todo);
    return newTodo;
  }
})();
let todo = Todo({id : 1, title: &quot;This is a title&quot;, userName: &quot;Cristi&quot;, completed: false });
</code></pre>
<p>这里，<code>Todo()</code> 就是一个拥有私有状态的函数。</p>
<h2 id="63-工厂模式与私有构造函数">6.3 工厂模式与私有构造函数</h2>
<p>查看如下代码：</p>
<pre><code class="language-javascript">let Todo = (function createTodoFactory(){
 function Todo(spec){
   Object.assign(this, spec);
 }
 
 return function(spec){
   let todo = new Todo(spec);
   return Object.freeze(todo);
 }
})();
</code></pre>
<p>这里，<code>Todo()</code> 工厂函数就是一个闭包。通过它，不管是否使用 <code>new</code>，我们都可以创建不可变对象，原型对象也只用创建一次，并且它是私有的。</p>
<pre><code class="language-javascript">let todo = Todo({title : &quot;A description&quot;});
todo.title = &quot;Another description&quot;; 
// Cannot assign to read only property 'title' of object
todo.toString = function() {};
//Cannot assign to read only property 'toString' of object
</code></pre>
<p>而且，在内存快照中，我们可以通过构造函数名来识别这些示例对象。<br>
<img src="https://faded.auspicious.space/post-images/1586954287441.png" alt="" loading="lazy"></p>
<h2 id="64-翻译功能与私有-map">6.4 翻译功能与私有 map</h2>
<p>通过闭包，我们可以创建一个 <code>map</code>，在所有翻译调用中被使用，且是私有的。</p>
<p>示例如下：</p>
<pre><code class="language-javascript">let translate = (function(){
  let translations = {};
  translations[&quot;yes&quot;] = &quot;oui&quot;;
  translations[&quot;no&quot;]  = &quot;non&quot;;
  
  return function(key){
    return translations[key];
  }
})();
translate(&quot;yes&quot;); //oui
</code></pre>
<h2 id="65-自增生成器函数">6.5 自增生成器函数</h2>
<p>通过闭包，我们可以创建自增生成器函数。同样，内部状态是私有的。示例如下：</p>
<pre><code class="language-javascript">function createAGenerate(count, increment) {
  return function(){
    count += increment;
    return count;
  }
}
let generateNextNumber = createAGenerate(0, 1);
console.log(generateNextNumber()); //1
console.log(generateNextNumber()); //2
console.log(generateNextNumber()); //3
let generateMultipleOfTen = createAGenerate(0, 10);
console.log(generateMultipleOfTen()); //10
console.log(generateMultipleOfTen()); //20
console.log(generateMultipleOfTen()); //30
</code></pre>
<p><em>译者注：原文中依次输出0,1,2,0,10,20是有误的，感谢@Round的指正</em></p>
<h2 id="66-对象与私有状态">6.6 对象与私有状态</h2>
<p>以上示例中，我们可以创建一个拥有私有状态的函数。同时，我们也可以创建多个拥有同一私有状态的函数。基于此，我们还可以创建一个拥有私有状态的对象。</p>
<p>示例如下：</p>
<pre><code class="language-javascript">function TodoStore(){
  let todos = [];
  
  function add(todo){
    todos.push(todo);
  }
  function get(){
    return todos.filter(isPriorityTodo).map(toTodoViewModel);
  }
  
  function isPriorityTodo(todo){
     return task.type === &quot;RE&quot; &amp;&amp; !task.completed;
  }
  
  function toTodoViewModel(todo) {
     return { id : todo.id, title : todo.title };
  }
  
  return Object.freeze({
    add,
    get
  });
}
</code></pre>
<p><code>TodoStore()</code> 函数返回了一个拥有私有状态的对象。在外部，我们无法访问私有的 <code>todos</code> 变量，并且 <code>add</code> 和 <code>get</code> 这两个闭包拥有相同的私有状态。在这里，<code>TodoStore()</code> 是一个工厂函数。</p>
<h2 id="67-闭包-vs-纯函数">6.7 闭包 vs 纯函数</h2>
<p>闭包就是那些引用了外部作用域中变量的函数。</p>
<p>为了更好的理解，我们将内部函数拆成闭包和纯函数两个方面：</p>
<ul>
<li>闭包是那些引用了外部作用域中变量的函数。</li>
<li>纯函数是那些没有引用外部作用域中变量的函数，它们通常返回一个值并且没有副作用。</li>
</ul>
<p>在上述例子中，<code>add()</code> 和 <code>get()</code> 函数是闭包，而 <code>isPriorityTodo()</code> 和 <code>toTodoViewModel()</code> 则是纯函数。</p>
<h1 id="7-闭包在函数式编程中的应用">7 闭包在函数式编程中的应用</h1>
<p>闭包在函数式编程中也应用广泛。譬如，<code>underscore</code> 源码中 <a href="https://underscorejs.org/#functions">函数相关小节</a> 中的所有函数都利用了闭包这一特性。</p>
<blockquote>
<p>A function decorator is a higher-order function that takes one function as an argument and returns another function, and the returned function is a variation of the argument function — <a href="https://leanpub.com/javascript-allonge/read#decorators">Javascript Allongé</a></p>
</blockquote>
<p>装饰器函数也使用了闭包的特性。</p>
<p>我们来看如下 <code>not</code> 这个简单的装饰器函数：</p>
<pre><code class="language-javascript">function not(fn){
  return function decorator(...args){
    return !fn.apply(this, args);
  }
}
</code></pre>
<p><code>decorator()</code> 函数引用了外部作用域的 <code>fn</code> 变量，因此它是一个闭包。</p>
<p>如果你想知道更多关于装饰器相关的知识，可以查看<a href="https://www.freecodecamp.org/news/here-are-a-few-function-decorators-you-can-write-from-scratch-488549fe8f86/">这篇文章</a>。</p>
<h1 id="8-垃圾回收">8 垃圾回收</h1>
<p>在 JavaScript 中，局部变量会随着函数的执行完毕而被销毁，除非还有指向他们的引用。当闭包本身也被垃圾回收之后，这些闭包中的私有状态随后也会被垃圾回收。通常我们可以通过切断闭包的引用来达到这一目的。</p>
<p>在这个例子中，我们首先创建了一个 <code>add()</code> 闭包。</p>
<pre><code class="language-javascript">let add = (function createAddClosure(){
    let arr = [];
    return function(obj){
       arr.push(obj);
    }
})();
</code></pre>
<p>随后，我们又定义了两个函数：</p>
<ul>
<li><code>addALotOfObjects()</code> 往闭包变量 <code>arr</code> 中加入对象。</li>
<li><code>clearAllObjects()</code> 将闭包函数置为 <code>null</code> 。</li>
</ul>
<p>并且两个函数皆作为事件处理函数：</p>
<pre><code class="language-javascript">function addALotOfObjects(){
    for(let i=1; i&lt;=10000;i++) {
       add(new Todo(i));
    }
}
function clearAllObjects(){
    if(add){
       add = null;
    }
}
$(&quot;#add&quot;).click(addALotOfObjects);
$(&quot;#clear&quot;).click(clearAllObjects);
</code></pre>
<p>当我点击 <code>Add</code> 按钮时，将往闭包变量 <code>arr</code> 中加入 10000 个 <code>todo</code> 对象，内存快照如下：<br>
<img src="https://faded.auspicious.space/post-images/1586954839826.png" alt="" loading="lazy"><br>
当我点击 <code>Clear</code> 按钮时，我们将闭包引用置为 <code>null</code>。随后，闭包变量 <code>arr</code> 将被垃圾回收，内存快照如下：<br>
<img src="https://faded.auspicious.space/post-images/1586954881968.png" alt="" loading="lazy"></p>
<h1 id="9-避免全局变量">9 避免全局变量</h1>
<p>在 JavaScript 中，我们很容易创建出全局变量。任何定义在函数和 <code>{}</code> 块之外的变量都是全局的，定义在全局作用域中的函数也是全局的。</p>
<p>这里以定义创建不同对象的工厂函数为例。为了避免将所有的工厂函数都放在全局作用域下，最简单的方法就是将他们挂在 <code>app</code> 全局变量下。</p>
<p>示例如下：</p>
<pre><code class="language-javascript">let app = Loader();
app.factory(function DataService(args){ return {}});
app.factory(function Helper(args){ return {}});
app.factory(function Mapper(args){ return {}});
app.factory(function Model(args){});
</code></pre>
<p><code>app.factory()</code> 方法还可以将不同的工厂函数归类到不同的模块中。下面这个示例就是将 <code>Timer</code> 工厂函数归类到 <code>tools</code> 模块下。</p>
<pre><code class="language-javascript">app.factory(&quot;tools&quot;)(function Timer(args){ return {}});
</code></pre>
<p>我们可以在 <code>app</code> 对象上暴露一个 <code>start</code> 方法来作为应用的入口点，通过回调函数中 <code>factories</code> 参数来访问这些工厂函数。这里 <code>start()</code> 函数只能被调用一次，如下：</p>
<pre><code class="language-javascript">app.start(function startApplication(factories){
  let helper = factories.Helper();
  
  let dataService = factories.DataService();
  let model = factories.Model({
      dataService : dataService,
      helper : helper,
      timer : factories.tools.Timer()
  });
});
</code></pre>
<blockquote>
<p>A Composition Root is a (preferably) unique location in an application where modules are composed together—Mark Seemann</p>
</blockquote>
<h2 id="91-loader-对象">9.1 loader 对象</h2>
<p>让我们来将 <code>app</code> 完善为一个 <code>loader</code> 对象，示例如下：</p>
<pre><code class="language-javascript">function Loader(){
  let modules = Object.create(null);
  let started = false;
  
  function getNamespaceModule(modulesText){
    let parent = modules;
    if(modulesText){
      let parts = modulesText.split('.');
      for(let i=0; i&lt;parts.length; i++){
        let part = parts[i];
        if (typeof parent[part] === &quot;undefined&quot;) {
          parent[part] = Object.create(null);
        }
        
        parent = parent[part];
      }
    }
    
    return parent;
  }
  
  function addFunction(namespace, fn){
    if(typeof(fn) !== &quot;function&quot;) {
      throw &quot;Only functions can be added&quot;;
    }
       
    let module = getNamespaceModule(namespace);
    let fnName = fn.name;    
    module[fnName] = fn;
  }
  
  function addNamespace(namespace){
    return function(fn){
      addFunction(namespace, fn)
    }
  }
  
  function factory(){
    if(typeof(arguments[0]) === &quot;string&quot;){
      return addNamespace(arguments[0]);
    } else {
      return addFunction(null, arguments[0]);
    }
  }
  
  function start(startApplication){
    if(started){
      throw &quot;App can be started only once&quot;;
    }
     
    startApplication(Object.freeze(modules));
    started = true;
  }
  
  return Object.freeze({
    factory,
    start
  });
};
let app = Loader();
</code></pre>
<p><code>factory()</code> 方法用于添加新的工厂函数到内部变量 <code>modules</code> 中。</p>
<p><code>start()</code> 方法则会调用回调函数，在回调函数中访问内部变量。</p>
<p>通过 <code>factory()</code> 定义工厂函数，将 <code>start()</code> 作为整个应用中调用各种工厂函数生成不同对象的唯一入口点，这是如此简洁优雅的方式。</p>
<p>在这里，<code>factory</code> 和 <code>start</code> 都是闭包。</p>
<h1 id="10-总结">10 总结</h1>
<p>闭包是一个可以访问外部作用域中变量的内部函数。</p>
<p>这些被引用的变量直到闭包被销毁时才会被销毁。</p>
<p>闭包使得 <code>timer</code> 定时器，事件处理，<code>Ajax</code> 请求等异步任务更加容易。</p>
<p>可以通过闭包来达到封装性。</p>
<p>最后，想获得更多关于 JavaScript 函数相关知识，可以查看以下文章：</p>
<ul>
<li><a href="https://medium.freecodecamp.org/discover-functional-programming-in-javascript-with-this-thorough-introduction-a2ad9af2d645">Discover Functional Programming in JavaScript with this thorough introduction</a></li>
<li><a href="https://medium.freecodecamp.org/discover-the-power-of-first-class-functions-fd0d7b599b69">Discover the power of first class functions</a></li>
<li><a href="https://medium.freecodecamp.org/how-point-free-composition-will-make-you-a-better-functional-programmer-33dcb910303a">How point-free composition will make you a better functional programmer</a></li>
<li><a href="https://medium.freecodecamp.org/here-are-a-few-function-decorators-you-can-write-from-scratch-488549fe8f86">Here are a few function decorators you can write from scratch</a></li>
<li><a href="https://medium.freecodecamp.org/make-your-code-easier-to-read-with-functional-programming-94fb8cc69f9d">Make your code easier to read with Functional Programming</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[忘记 jQuery 使用原生接口]]></title>
        <id>https://faded.auspicious.space/post/how-to-forget-about-jquery-and-start-using-native/</id>
        <link href="https://faded.auspicious.space/post/how-to-forget-about-jquery-and-start-using-native/">
        </link>
        <updated>2020-04-15T04:43:35.000Z</updated>
        <summary type="html"><![CDATA[<p><a href="https://www.jeffjade.com/2015/11/25/2015-11-31-jQuery-vs-javaScript/">jQuery VS JavaScript原生API</a></p>
]]></summary>
        <content type="html"><![CDATA[<p><a href="https://www.jeffjade.com/2015/11/25/2015-11-31-jQuery-vs-javaScript/">jQuery VS JavaScript原生API</a></p>
<!-- more -->
<h1 id="1-选择元素">1 选择元素</h1>
<pre><code class="language-javascript">// jQuery  
var els = $('.el');  
//==========================================================//
// 原生方法  
var els = document.querySelectorAll('.el');  
// 函数法  
var $ = function (el) {  
 return document.querySelectorAll(el);  
}  
var els = $('.el');
</code></pre>
<h1 id="2-创建元素">2 创建元素</h1>
<pre><code class="language-javascript">// jQuery  
var newEl = $('&lt;div/&gt;');  
//==========================================================//
// 原生方法  
var newEl = document.createElement('div');
</code></pre>
<h1 id="3-添加-移除-切换类">3 添加 / 移除 / 切换类</h1>
<pre><code class="language-javascript">// jQuery  
$('.el').addClass('class');  
$('.el').removeClass('class');  
$('.el').toggleClass('class');  
//==========================================================//
// 原生方法  
document.querySelector('.el').classList.add('class');  
document.querySelector('.el').classList.remove('class');
document.querySelector('.el').classList.toggle('class');
</code></pre>
<p>4 判断是否包含类</p>
<pre><code class="language-javascript">// jQuery
$('.el').hasClass('className');
$('.el').has('.className'); //也可以用来 判断是否包含某个元素
//==========================================================//
// 原生方法(1)
_hasClass(document.querySelector('.el'), className);
function _hasClass( elements,cName ){
    return !!elements.className.match( new RegExp( &quot;(\\s|^)&quot; + cName + &quot;(\\s|$)&quot;) );
};
// 原生方法(2)
if(el.classList.contains(&quot;someClass&quot;)){}
</code></pre>
<h1 id="5-添加事件监听器">5 添加事件监听器</h1>
<pre><code class="language-javascript">// jQuery  
$('.el').on('event', function() {
});  
//==========================================================//  
// 原生方法  
[].forEach.call(document.querySelectorAll('.el'), function (el) {  
  el.addEventListener('event', function() {
  }, false);
});
</code></pre>
<h2 id="原生-dom绑定事件-优化1-参考here">原生－DOM绑定事件－优化1 参考<a href="https://www.cnblogs.com/coffeedeveloper/p/4811850.html">HERE</a></h2>
<pre><code class="language-javascript">//DOM绑定事件-之自执行
var BindEvent = (function () {
  if ('addEventListener' in document) {
    return function (dom, event, handle, ex) {
      dom.addEventListener(event, handle, ex || false);
    }
  } else if ('attachEvent' in document) {
    return function (dom, event, handle) {
      dom.attachEvent('on' + event, handle);
    }
  } else {
    return function (dom, event, handle) {
      dom['on' + event] = handle;
    }
  }
})();```

## 原生－DOM绑定事件－优化2
```javascript
//DOM绑定事件-之惰性加载(调用方去触发BindEvent之时才去做初始化)//
var BindEvent = function (dom, event, handle, ex) {
  if ('addEventListener' in document) {
    BindEvent = function (dom, event, handle, ex) {
      dom.addEventListener(event, handle, ex || false);
    }
  } else if ('attachEvent' in document) {
trueBindEvent = function (dom, event, handle) {
      dom.attachEvent('on' + event, handle);
    }
  } else {
    BindEvent = function (dom, event, handle) {
      dom['on' + event] = handle;
    }
  }
  BindEvent(dom, event, handle, ex);
};
</code></pre>
<h1 id="6-设置-获取属性">6 设置 / 获取属性</h1>
<pre><code class="language-javascript">// jQuery  
$('.el').filter(':first').attr('key', 'value');  
$('.el').filter(':first').attr('key');  
//==========================================================//
// 原生方法  
document.querySelector('.el').setAttribute('key', 'value');  
document.querySelector('.el').getAttribute('key');
</code></pre>
<h1 id="7-附加内容append">7 附加内容（Append）</h1>
<pre><code class="language-javascript">// jQuery  
$('.el').append($('&lt;div/&gt;'));  
//==========================================================//
// 原生方法  
document.querySelector('.el').appendChild(document.createElement('div'));
</code></pre>
<h1 id="8-克隆元素">8 克隆元素</h1>
<pre><code class="language-javascript">// jQuery  
var clonedEl = $('.el').clone();  
//==========================================================//
// 原生方法  
var clonedEl = document.querySelector('.el').cloneNode(true);
</code></pre>
<h1 id="9-移除元素">9 移除元素</h1>
<pre><code class="language-javascript">// jQuery  
$('.el').remove();  
//==========================================================//
// 原生方法  
remove('.el');  
function remove(el) {  
  var toRemove = document.querySelector(el);  
  toRemove.parentNode.removeChild(toRemove);  
}
</code></pre>
<h1 id="10-获取父元素">10 获取父元素</h1>
<pre><code class="language-javascript">// jQuery  
$('.el').parent();  
//==========================================================//
// 原生方法  
document.querySelector('.el').parentNode;
</code></pre>
<h1 id="11-上一个-下一个元素">11 上一个 / 下一个元素</h1>
<pre><code class="language-javascript">// jQuery  
$('.el').prev();  
$('.el').next();  
//==========================================================//
// 原生方法  
document.querySelector('.el').previousElementSibling;  
document.querySelector('.el').nextElementSibling;
</code></pre>
<h1 id="12-修改css属性">12 修改CSS属性</h1>
<p>总是通过 <code>Javascript</code> 修改和检索 <code>CSS</code> 属性，这样会比使用 <code>jQuery CSS</code> 函数更加简单快速，并且没有任何不必要的代码。</p>
<pre><code class="language-javascript">//----设置CSS属性----
/* jQuery */
  $(el).css({
    background: &quot;#FF0000&quot;,
&quot;box-shadow&quot;: &quot;1px 1px 5px 5px red&quot;,
    width: &quot;100px&quot;,
    height: &quot;100px&quot;,
    display: &quot;block&quot;
  });
//==========================================================//
/* 原生 */
var el = document.querySelector(&quot;.main-content&quot;);
el.style.background = &quot;#FF0000&quot;;
el.style.width = &quot;100px&quot;;
el.style.height = &quot;100px&quot;;
el.style.display = &quot;block&quot;;
el.style.boxShadow = &quot;1px 1px 5px 5px red&quot;;
</code></pre>
<h1 id="13-xhr-或-ajax">13 XHR 或 Ajax</h1>
<pre><code class="language-javascript">// jQuery  
$.get('url', function (data) {  
});  
$.post('url', {data: data}, function (data) {  
});  
//==========================================================//
// 原生方法  
// get  
var xhr = new XMLHttpRequest();  
xhr.open('GET', url);  
xhr.onreadystatechange = function (data) {  
}  
xhr.send();  
// post  
var xhr = new XMLHttpRequest()  
xhr.open('POST', url);  
xhr.onreadystatechange = function (data) {  
}  
xhr.send({data: data});
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JavaScript——闭包实际场景应用]]></title>
        <id>https://faded.auspicious.space/post/javascript-closure-application-scenarios/</id>
        <link href="https://faded.auspicious.space/post/javascript-closure-application-scenarios/">
        </link>
        <updated>2020-04-15T04:18:49.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-函数防抖">1. 函数防抖</h1>
<p>比如要缩放窗口 触发 <code>onresize</code> 事件 需要在这时候做一件事情,但是我们希望拖动的时候只触发一次,比如：</p>
<pre><code class="language-javascript">window.onresize = function () {
    console.log('onresize')//只想触发一次
}
</code></pre>
<h2 id="一般方法">一般方法</h2>
<pre><code class="language-javascript">window.onresize = function () {
    debounce(fn, 1000)
}
var fn = function () {
    console.log('fn')
}
var time = ''
function debounce(fn, timeLong) {
    if (time) {
        clearTimeout(time)
        time = ''
    }

    time = setTimeout(function () {
        fn()
    }, timeLong)
}
</code></pre>
<h2 id="闭包">闭包</h2>
<pre><code class="language-javascript">window.onresize = debounce(fn, 500)
function debounce(fn) {
    var timer = null
    return function () {
        if (timer) {     //timer第一次执行后会保存在内存里 永远都是执行器 直到最后被触发
            clearTimeout(timer)
            timer = null
        }
        timer = setTimeout(function () {
            fn()
        }, 1000)
    }

}
var fn = function () {

    console.log('fn')
}
</code></pre>
<h1 id="2-使用闭包设计单例模式">2 使用闭包设计单例模式</h1>
<pre><code class="language-javascript">class CreateUser {
    constructor(name) {
        this.name = name;
        this.getName();
    }
    getName() {
        return this.name;
    }
}
// 代理实现单例模式
var ProxyMode = (function () {
    var instance = null;
    return function (name) {
        if (!instance) {
            instance = new CreateUser(name);
        }
        return instance;
    }
})();
// 测试单体模式的实例
var a = ProxyMode(&quot;aaa&quot;);
var b = ProxyMode(&quot;bbb&quot;);
// 因为单体模式是只实例化一次，所以下面的实例是相等的
console.log(a === b);    //true
</code></pre>
<h1 id="3-为多个组件独立属性">3 为多个组件独立属性</h1>
<p>假如我现在要在页面中使用 <code>Echarts</code>画 6 个线状图，需要 6 个容器。需要为每个容器元素声明一个独立 <code>id</code>，不然会混乱。</p>
<pre><code class="language-typescript">constructor(){
    this.state = { id: &quot;EchartsLine&quot; + Util.clourse() };
}
componentDidMount() {
    this.myEChart = echarts.init(document.getElementById(this.state.id));//不同 id  
}
</code></pre>
<pre><code class="language-html">&lt;div id={this.state.id} className='echarts-line'&gt;&lt;/div&gt;
</code></pre>
<pre><code class="language-javascript">clourse(){
    let clourse = (function () {
        var a = 1;
        return function () {
            return a++;
        }
    })(this);
    this.clourse = clourse;
}
//使用数字命名 不用害怕被篡改
</code></pre>
<h1 id="4-设置私有变量">4 设置私有变量</h1>
<p>内部属性在 <code>Java</code> 里使用 <code>private</code> 就可以，但是 <code>JS</code> 还没有这个东东。</p>
<pre><code class="language-javascript">let _width = Symbol();
class Private {
    constructor(s) {
        this[_width] = s
    }
    foo() {
        console.log(this[_width])
    }
}
var p = new Private(&quot;50&quot;);
p.foo();
console.log(p[_width]); //可以拿到
</code></pre>
<pre><code class="language-javascript">// 赋值到闭包里
let sque = (function () {
    let _width = Symbol();
    class Squery {
        constructor(s) {
            this[_width] = s
        }

        foo() {
            console.log(this[_width])
        }
    }
    return Squery
})();

let ss = new sque(20);
ss.foo();
console.log(ss[_width])
</code></pre>
<h1 id="5-拿到正确的值">5 拿到正确的值</h1>
<pre><code class="language-javascript">for (var i = 0; i &lt; 10; i++) {
    setTimeout(function () {
        console.log(i) // 10 个 10
    }, 1000)
}
</code></pre>
<p>遇到这种问题 如何用解决呢？</p>
<pre><code class="language-javascript">for (var i = 0; i &lt; 10; i++) {
    ((j) =&gt; {
        setTimeout(function () {
            console.log(j)//1-10
        }, 1000)
    })(i)
}
</code></pre>
<p>原理是 声明了10个自执行函数，保存当时的值到内部。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JavaScript——闭包简介]]></title>
        <id>https://faded.auspicious.space/post/javascript-closure-introduction/</id>
        <link href="https://faded.auspicious.space/post/javascript-closure-introduction/">
        </link>
        <updated>2020-04-15T03:39:06.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p><a href="https://juejin.im/post/5b081f8d6fb9a07a9b3664b6">闭包详解一</a></p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p><a href="https://juejin.im/post/5b081f8d6fb9a07a9b3664b6">闭包详解一</a></p>
</blockquote>
<!-- more -->
<h1 id="一-什么是闭包">一、什么是闭包</h1>
<p>《JavaScript高级程序设计》这样描述：</p>
<blockquote>
<p>闭包是指有权访问另一个函数作用域中的变量的函数；</p>
</blockquote>
<p>《JavaScript权威指南》这样描述：</p>
<blockquote>
<p>从技术的角度讲，所有的JavaScript函数都是闭包：它们都是对象，它们都关联到作用域链。</p>
</blockquote>
<p>《你不知道的JavaScript》这样描述：</p>
<blockquote>
<p><strong>当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。</strong></p>
</blockquote>
<p>我最认同的是《你不知道的JavaScript》中的描述，虽然前面的两种说法都没有错，但闭包应该是基于词法作用域书写代码时产生的自然结果，是一种现象！你也不用为了利用闭包而特意的创建，因为闭包的在你的代码中随处可见，只是你还不知道当时你写的那一段代码其实就产生了闭包。</p>
<h1 id="二-讲解闭包">二、讲解闭包</h1>
<p>上面已经说到，<strong>当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行</strong>。</p>
<p>看一段代码</p>
<pre><code class="language-javascript">function fn1() {
	var name = 'iceman';
	function fn2() {
		console.log(name);
	}
	fn2();
}
fn1();
</code></pre>
<p>如果是根据《JavaScript高级程序设计》和《JavaScript权威指南》来说，上面的代码已经产生闭包了。<code>fn2</code> 访问到了 <code>fn1</code> 的变量，满足了条件“有权访问另一个函数作用域中的变量的函数”，<code>fn2</code> 本身是个函数，所以满足了条件“所有的JavaScript函数都是闭包”。</p>
<p>这的确是闭包，但是这种方式定义的闭包不太好观察。</p>
<p>再看一段代码：</p>
<pre><code class="language-javascript">function fn1() {
	var name = 'iceman';
	function fn2() {
		console.log(name);
	}
	return fn2;
}
var fn3 = fn1();
fn3();
</code></pre>
<p>这样就清晰地展示了闭包：</p>
<ul>
<li><code>fn2</code> 的词法作用域能访问 <code>fn1</code>的作用域；</li>
<li>将 <code>fn2</code> 当做一个值返回；</li>
<li><code>fn1</code> 执行后，将 <code>fn2</code> 的引用赋值给 <code>fn3</code>；</li>
<li>执行 <code>fn3</code>，输出了变量 <code>name</code>。</li>
</ul>
<p>我们知道通过引用的关系，<code>fn3</code> 就是 <code>fn2</code> 函数本身。执行 <code>fn3</code> 能正常输出 <code>name</code>，这不就是 <code>fn2</code> 能记住并访问它所在的词法作用域，而且 <code>fn2</code> 函数的运行还是在当前词法作用域之外了。</p>
<p>正常来说，当 <code>fn1</code> 函数执行完毕之后，其作用域是会被销毁的，然后垃圾回收器会释放那段内存空间。而闭包却很神奇的将 <code>fn1</code> 的作用域存活了下来，<code>fn2</code> 依然持有该作用域的引用，这个引用就是闭包。</p>
<p>总结：<strong>某个函数在定义时的词法作用域之外的地方被调用，闭包可以使该函数极限访问定义时的词法作用域。</strong></p>
<p>注意：对函数值的传递可以通过其他的方式，并不一定值有返回该函数这一条路，比如可以用回调函数：</p>
<pre><code class="language-javascript">function fn1() {
	var name = 'iceman';
	function fn2() {
		console.log(name);
	}
	fn3(fn2);
}
function fn3(fn) {
	fn();
}
fn1();
</code></pre>
<p>本例中，将内部函数 <code>fn2</code> 传递给 <code>fn3</code>，当它在 <code>fn3</code> 中被运行时，它是可以访问到 <code>name</code>变量的。</p>
<p>所以无论通过哪种方式将内部的函数传递到所在的词法作用域以外，它都回持有对原始作用域的引用，无论在何处执行这个函数都会使用闭包。</p>
<h3 id="三-再次解释闭包">三、再次解释闭包</h3>
<p>以上的例子会让人觉得有点学院派了，但是闭包绝不仅仅是一个无用的概念，你写过的代码当中肯定有闭包的身影，比如类似如下的代码：</p>
<pre><code class="language-javascript">function waitSomeTime(msg, time) {
	setTimeout(function () {
		console.log(msg)
	}, time);
}
waitSomeTime('hello', 1000);
</code></pre>
<p>定时器中有一个匿名函数，该匿名函数就有涵盖 <code>waitSomeTime</code> 函数作用域的闭包，因此当 1 秒之后，该匿名函数能输出 <code>msg</code>。</p>
<p>另一个很经典的例子就是 <code>for</code> 循环中使用定时器延迟打印的问题：</p>
<pre><code class="language-javascript">for (var i = 1; i &lt;= 10; i++) {
	setTimeout(function () {
		console.log(i);
	}, 1000);
}
</code></pre>
<p>在这段代码中，我们对其的预期是输出 1~10，但却输出 10 次 11。这是因为 <code>setTimeout</code> 中的匿名函数执行的时候，<code>for</code> 循环都已经结束了，<code>for</code> 循环结束的条件是 <code>i</code> 大于 10，所以当然是输出 10 次 11 咯。</p>
<p>究其原因：<code>i</code> 是声明在全局作用中的，定时器中的匿名函数也是执行在全局作用域中，那当然是每次都输出 11 了。</p>
<p>原因知道了，解决起来就简单了，我们可以让i在每次迭代的时候，都产生一个私有的作用域，在这个私有的作用域中保存当前i的值。</p>
<pre><code class="language-javascript">for (var i = 1; i &lt;= 10; i++) {
	(function () {
		var j = i;
		setTimeout(function () {
			console.log(j);
		}, 1000);
	})();
}
</code></pre>
<p>这样就达到我们的预期了呀，让我们用一种比较优雅的写法改造一些，将每次迭代的i作为实参传递给自执行函数，自执行函数中用变量去接收：</p>
<pre><code class="language-javascript">for (var i = 1; i &lt;= 10; i++) {
	(function (j) {
		setTimeout(function () {
			console.log(j);
		}, 1000);
	})(i);
}
</code></pre>
<h1 id="四-闭包的应用">四、闭包的应用</h1>
<p>闭包的应用比较典型是定义模块，我们将操作函数暴露给外部，而细节隐藏在模块内部：</p>
<pre><code class="language-javascript">function module() {
	var arr = [];
	function add(val) {
		if (typeof val == 'number') {
			arr.push(val);
		}
	}
	function get(index) {
		if (index &lt; arr.length) {
			return arr[index]
		} else {
			return null;
		}
	}
	return {
		add: add,
		get: get
	}
}
var mod1 = module();
mod1.add(1);
mod1.add(2);
mod1.add('xxx');
console.log(mod1.get(2));
</code></pre>
]]></content>
    </entry>
</feed>