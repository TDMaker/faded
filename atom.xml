<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://faded.auspicious.space</id>
    <title>Typhoeus</title>
    <updated>2020-04-17T14:58:33.606Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://faded.auspicious.space"/>
    <link rel="self" href="https://faded.auspicious.space/atom.xml"/>
    <logo>https://faded.auspicious.space/images/avatar.png</logo>
    <icon>https://faded.auspicious.space/favicon.ico</icon>
    <rights>All rights reserved 2020, Typhoeus</rights>
    <entry>
        <title type="html"><![CDATA[Git——超详实教程与命令大全]]></title>
        <id>https://faded.auspicious.space/post/git-super-detailed-tutorials-and-commands/</id>
        <link href="https://faded.auspicious.space/post/git-super-detailed-tutorials-and-commands/">
        </link>
        <updated>2020-04-17T04:05:39.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p><a href="https://juejin.im/post/5bd2a0d8e51d457a4e0d4fd5">超详实Git简明教程与命令大全</a></p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p><a href="https://juejin.im/post/5bd2a0d8e51d457a4e0d4fd5">超详实Git简明教程与命令大全</a></p>
</blockquote>
<!-- more -->
<p><a href="https://git-scm.com/">Git</a>（wiki: <a href="https://en.wikipedia.org/wiki/Git">en</a>  <a href="https://zh.wikipedia.org/wiki/Git">chs</a> ）是一个免费开源的分布式版本控制系统，由 <code>Linux</code> 内核作者 Linus Torvalds 开发，大型开源项目 Linux Kernel、Android、Chromium、Mono、DotNet、UE4 等都使用 Git 管理项目著名 github 网站使用 Git 托管所有项目代码，Git 的代码也托管在 github 上，链接为：<a href="github.com/git">github.com/git</a> 与集中式版本控制系统（开源软件：SVN；免费软件：CVS；商业软件：微软的 VSS、IBM 的 Rational ClearCase）相比。</p>
<p><strong>Git 优点</strong>：</p>
<ol>
<li>本地是版本库的完整镜像，因此支持离线工作；</li>
<li>绝大多数操作都只需要访问本地文件和资源，而且与每个提交都是所有文件的完整副本，因此速度非常快；</li>
<li>强大快捷的分支功能，非常适合非线性开发过程。</li>
</ol>
<p><strong>Git 缺点</strong>：</p>
<ol>
<li>只能全量整体，而不能以子目录和分支为单位进行更新、提交等操作；</li>
<li>子目录和分支不能单独进行权限控制；</li>
<li>由于每个提交都是所有文件的完整副本，因此更占磁盘空间。</li>
</ol>
<p><img src="https://faded.auspicious.space/post-images/1587098525528.png" alt="" loading="lazy"><br>
注：SVN 等集中式版本控制系统存储每个文件与初始化版本的差异。<br>
<img src="https://faded.auspicious.space/post-images/1587098560926.png" alt="" loading="lazy"><br>
注：Git 每个提交都是所有文件的完整副本，使得 Git 在回溯到某个提交时，不会对所有文件执行差异计算还原，因此速度会非常快。</p>
<p>这使得源代码、配置文件等更适合用 Git 来管理，而资源等较大的二进制文件则容易导致版本库体积膨胀。</p>
<p>在项目实践中，对于资源等较大的二进制文件可以采用 <a href="https://git-lfs.github.com/">Git-LFS</a> 来管理，UE4 则是使用自己开发的 GitDependencies 来管理。</p>
<h1 id="基本概念">基本概念</h1>
<ul>
<li><code>origin</code>：默认远程版本库名。</li>
<li><code>master</code>：默认分支名。</li>
<li><code>origin/master</code>：远程默认分支名。</li>
<li><code>HEAD</code>：当前分支顶端 <code>Commit</code> 的别名，即当前分支最近的一个提交的 <code>SHA-1</code> 哈希值。</li>
<li><code>ORIG_HEAD</code>：上次 <code>HEAD</code> 指针的位置。注：当执行 <code>git reset / git pull / git merge</code> 命令时，<code>git</code> 会把老的 <code>HEAD</code> 拷贝到文件 <code>.git/ORIG_HEAD</code> 中，在后续命令中可以使用 <code>ORIG_HEAD</code> 引用这个提交。</li>
<li><code>commit</code>（提交）：每个 <code>commit</code> 都是全部文件的完整快照，并用一个 <code>commitID</code>（基于文件的内容或目录结构计算出来的 40 位十六进制的 <code>SHA-1</code> 哈希值） 来唯一标志。从某个角度上来说，Git 维护的就是一个 <code>commitID</code> 有向无环图。</li>
<li><code>detached HEAD</code>：<code>HEAD</code> 没有指向任何分支的状态。一般有以下几种情况会出现这种情况：
<ol>
<li>使用 <code>checkout</code> 命令跳到某个没有分支指着的 <code>commit</code> 时；</li>
<li><code>rebase</code> 处理冲突时所处的状态；</li>
<li>切换到某个远程分支 <code>cache</code> 上时。</li>
</ol>
</li>
</ul>
<p>在 Git 中，在执行命令时，一定要清楚：你在哪？对谁执行这个命令？ 本文使用 git 版本为：<code>git version 2.13.0.windows</code></p>
<p>运行命令行建议使用：<code>git bash</code>（可通过右键菜单 <code>Git Bash here</code> 来启动），主要有3个原因：</p>
<ol>
<li>在 <code>Windows</code> 的 <code>cmd</code> 下执行 <code>git log</code> 等需要显示多页内容的命令时，会导致 <code>cmd</code> 卡死（有时按 <code>Q</code> 键也没法退出）；</li>
<li><code>git bash</code> 中可以使用 <code>MinGW</code> 中自带的 <code>Linux</code> 环境下常用的命令工具；</li>
<li><code>git bash</code> 着色做得更好，利于阅读。</li>
</ol>
<h1 id="图解常见操作">图解常见操作</h1>
<ul>
<li><code>Working Directory</code>：即工作区。操作系统层面的目录树结构，也可以理解为一个 <code>tree</code> 目录对象。</li>
<li><code>Stage(Index)</code>：即暂存区，为等待 <code>Commit</code> 的文件列表。是以扁平的文件清单实现的，不过从理解层面上也可以理解为 <code>tree</code> 目录对象。</li>
<li><code>Local Repository</code>(History)：本地版本库。有向无环图，其每一个节点都是一个 <code>tree</code> 目录对象。</li>
<li><code>Remote Repository</code>：远程版本库。有向无环图，其每一个节点都是一个 <code>tree</code>目录对象。</li>
</ul>
<p><img src="https://faded.auspicious.space/post-images/1587099496728.png" alt="" loading="lazy"><br>
注：图中 <code>git checkout -- &lt;file&gt;</code> 1、2 步骤的含义是当在暂存区中有修改时，优先使用暂存区中的修改覆盖工作区。</p>
<h1 id="svn-命令对比一览">SVN 命令对比一览</h1>
<table>
<thead>
<tr>
<th>svn</th>
<th>git</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>svn checkout</td>
<td>git clone</td>
<td>检出项目</td>
</tr>
<tr>
<td>svn update</td>
<td>git fetch<br>git pull</td>
<td>更新</td>
</tr>
<tr>
<td>svn commit</td>
<td>git commit<br>git push</td>
<td>提交</td>
</tr>
<tr>
<td>svn add</td>
<td>git add</td>
<td>添加</td>
</tr>
<tr>
<td>svn mv</td>
<td>git mv</td>
<td>移动</td>
</tr>
<tr>
<td>svn rm</td>
<td>git rm</td>
<td>删除</td>
</tr>
<tr>
<td>svn status</td>
<td>git status</td>
<td>查看状态</td>
</tr>
<tr>
<td>svn log</td>
<td>git log</td>
<td>查看 log</td>
</tr>
<tr>
<td>svn diff</td>
<td>git diff</td>
<td>查看差异</td>
</tr>
<tr>
<td>svn revert</td>
<td>git checkout<br>git reset<br>git revert</td>
<td>撤销、丢弃修改</td>
</tr>
<tr>
<td>svn copy</td>
<td>git checkout -b/-B<br>git branch</td>
<td>创建分支</td>
</tr>
<tr>
<td>svn switch</td>
<td>git checkout</td>
<td>切换分支</td>
</tr>
<tr>
<td>svn copy</td>
<td>git tag</td>
<td>创建tag</td>
</tr>
<tr>
<td>svn merge</td>
<td>git merge<br>git rebase</td>
<td>分支合并</td>
</tr>
</tbody>
</table>
<h1 id="文件存储机制">文件存储机制</h1>
<p>Git 存储使用的是一个内容寻址的文件系统，其核心部分是一个简单的键值对（<code>key-value</code>）数据库，当向数据库中插入任意类型的内容，它会返回一个 40 位十六进制的 <code>SHA-1</code> 哈希值用作索引。在版本库中，Git 维护的数据结构有：以下 4 种对象及索引，并通过保存 <code>commitID</code> 有向无环图的 <code>log</code> 日志来维护与管理项目的修订版本和历史信息。</p>
<ul>
<li><code>blob</code> — 1 个 <code>blob</code> 保存 1 个文件的 1 个版本的数据。</li>
<li><code>tree</code> — 表示 1 个目录，记录着目录里所有文件 <code>blob</code> 哈希值、文件名子目录名及其他元数据。通过递归引用其他目录树，从而建立一个包含文件和子目录的完整层次结构。</li>
<li><code>commit</code>  — 1 个提交对象保存版本库中每一次变化的元数据，每个提交对象指向一个版本的 <code>git</code> 目录树对象。</li>
<li><code>tag</code> — 分为轻量标签和附注标签。轻量标签实际上是一个特定提交的引用，附注标签是存储在 <code>git</code> 中的一个完整可被校验的对象（保存在 <code>.git/refs/tags</code> 中），还包含打标签者的名字、E-mail、日志、注释等信息。</li>
</ul>
<p><code>git</code> 使用 <code>zlib</code> 将头部信息（对象类型：<code>blob</code> 或 <code>tree</code> 或 <code>commit</code> + 1 个空格 + 数据内容长度 + 1 个空字节）和对象数据拼接一起的内容进行压缩存储成一个文件。</p>
<p>压缩的文件被十六进制的 <code>SHA-1</code> 哈希值命名，该文件可以用 <code>pigz.exe -dz &lt;文件路径&gt;</code> 来解压查看。注：Windows 版的 <code>pigz.exe</code> 可以从<a href="https://sourceforge.net/projects/pigzforwindows/">这儿</a>下载。</p>
<p>40 位十六进制的 <code>SHA-1</code> 哈希值 <code>= sha1(&quot;blob/tree/commit &quot; + filesize + &quot;\0&quot; + data)</code>， 如：<code>sha1(&quot;blob 7\0foobar\n&quot;) = &quot;323fae03f4606ea9991df8befbb2fca795e648fa&quot;</code>   注：<code>\n</code> 的二进制为 <code>0a</code>。<br>
<img src="https://faded.auspicious.space/post-images/1587100311371.png" alt="" loading="lazy"></p>
<h1 id="底层命令剖析-git-对象">底层命令—剖析 Git 对象</h1>
<ul>
<li>
<p><code>find .git/objects -type f</code> // 用 <code>find</code> 命令查看 <code>.git/objects</code> 目录（递归子目录）中的所有文件。</p>
</li>
<li>
<p><code>git rev-list --objects --all</code> // 查看所有 <code>git</code> 对象的 <code>SHA-1</code> 哈希值与文件名的对应关系。</p>
</li>
<li>
<p><code>git rev-list --objects --all | grep 83c4fbc43a6f187d4e8a247a1c9aced872b2315d</code> // 查看 <code>SHA-1</code> 哈希值为 <code>83c4fbc43a6f187d4e8a247a1c9aced872b2315d</code> 的文件名。</p>
</li>
<li>
<p><code>echo &quot;Hello World!&quot; | git hash-object --stdin</code> // 计算内容为 <code>Hello World!</code> 文件的 <code>SHA-1</code> 哈希值。</p>
</li>
<li>
<p><code>echo &quot;Hello World!&quot; | git hash-object -w --stdin</code> // 计算内容为 <code>Hello World!</code> 文件的 <code>SHA-1</code> 哈希值并写入到当前 <code>git</code> 本地版本库中。</p>
</li>
<li>
<p><code>git hash-object README.txt</code> // 查看 <code>README.txt</code> 的 <code>SHA-1</code> 哈希值。</p>
</li>
<li>
<p><code>git hash-object -w README.txt</code> // 查看 <code>README.txt</code> 的 <code>SHA-1</code> 哈希值并写入到当前 <code>git</code> 本地版本库中。</p>
</li>
<li>
<p><code>git cat-file -p master^^{tree}</code> // 查看 <code>master</code> 分支 <code>HEAD</code> 指针 <code>git</code> 目录（<code>tree</code> 对象）下的各子目录（<code>tree</code> 对象）和文件（<code>blob</code> 对象）的 <code>SHA-1</code> 哈希值。</p>
<pre><code class="language-bash">100644 blob 7abd3a56703ad4a7120571967f5d06607b5e5502 README.txt
040000 tree 9f448c40e684dc38109574007c661277c815fb7e ss
</code></pre>
<p>注：<code>040000</code>：表示目录；<code>100644</code>：表示一般文件；<code>100755</code>：表示可执行文件；<code>120000</code>：表示符号链接。</p>
</li>
<li>
<p><code>git cat-file -p 7abd3a56703ad4a7120571967f5d06607b5e5502</code> // 查看 <code>SHA-1</code> 哈希值为 <code>7abd3a56703ad4a7120571967f5d06607b5e5502</code> 文件的内容。</p>
</li>
<li>
<p><code>git show 7abd3a56703ad4a7120571967f5d06607b5e5502</code> // 查看 <code>SHA-1</code> 哈希值为 <code>7abd3a56703ad4a7120571967f5d06607b5e5502</code> 文件的内容。</p>
</li>
<li>
<p><code>git cat-file -t f3961f5</code> // 查看 <code>f3961f5</code> 提交对象的类型：显示为 <code>commit</code>。</p>
</li>
<li>
<p><code>git cat-file -p f3961f5</code> // 查看 <code>f3961f5</code> 提交对象的信息：包含 <code>git</code> 目录（<code>tree</code> 对象）、上次提交对象的 <code>SHA-1</code> 哈希值及提交时 <code>Author</code>、<code>Date</code> 和注释信息。</p>
<pre><code class="language-bash">tree ead34240822030a3f71df4fc351057d80d7d83f8
parent 33d5bbc5d61b024aab5078e40548c4e3da808e0e
author nicochen &lt;nicochen@tencent.com&gt; 1537258258 +0800
committer nicochen &lt;nicochen@tencent.com&gt; 1537258258 +0800
123 desc txt
</code></pre>
</li>
<li>
<p><code>git cat-file -p tag1.0</code> // 查看轻量标签或附注标签 <code>tag1.0</code> 信息。</p>
</li>
<li>
<p><code>git cat-file tag tag1.0</code> // 查看附注标签 <code>tag1.0</code> 信息。</p>
</li>
<li>
<p><code>git ls-tree ead34240822030a3f71df4fc351057d80d7d83f8</code> // 查看 <code>tree</code> 目录对象 <code>ead34240822030a3f71df4fc351057d80d7d83f8</code> 中包含的 <code>blob</code> 文件对象和 <code>tree</code> 目录对象。</p>
</li>
<li>
<p><code>git ls-tree HEAD</code> // 查看 <code>HEAD</code> 所指向 <code>tree</code> 目录对象中包含的 <code>blob</code> 文件对象和 <code>tree</code> 目录对象。</p>
</li>
<li>
<p><code>git verify-pack -v .git/objects/pack/pack-a9282552b62cbe3f255fbb20374695a17c1ba2a2.idx</code> // 查看<code>pack-a9282552b62cbe3f255fbb20374695a17c1ba2a2.pack</code> 压缩包中的内容。</p>
</li>
<li>
<p><code>git update-index n.txt</code> // 将修改状态的 <code>n.txt</code> 文件添加到暂存区。</p>
</li>
<li>
<p><code>git update-index --add n.txt</code> // 将未追踪状态或修改状态的 <code>n.txt</code> 文件添加到暂存区。</p>
</li>
<li>
<p><code>git update-index --add --cacheinfo 100644 5d11580eed65ffd34b6786274a60460b3582aa7d n.txt</code>  // 使用类型为 <code>100644</code>、<code>SHA-1</code> 哈希值为 <code>5d11580eed65ffd34b6786274a60460b3582aa7d</code> 的信息将追踪状态或修改状态的 <code>n.txt</code> 添加到暂存区。</p>
</li>
<li>
<p><code>git write-tree</code>  // 将整个暂存区内容生成一个 <code>tree</code> 对象，并输出其 <code>SHA-1</code> 哈希值。</p>
</li>
<li>
<p><code>echo &quot;add n.txt&quot; | git commit-tree 31b7ca405196ca9e8fb4d5404b315bef9f2c841f -p HEAD</code> // 用 <code>git write-tree</code> 得到的<code>31b7ca405196ca9e8fb4d5404b315bef9f2c841f</code> 树对象创建一个注释为 <code>add n.txt</code> 的提交对象，并将提交对象的父亲设置为当前 <code>HEAD</code>。</p>
</li>
<li>
<p><code>git update-ref refs/heads/master 372aa8e425b57ca30e2974b8e7737133caaa0b7f</code>  // 若当前分支为 <code>master</code>，更新 <code>HEAD</code> 指向上面 <code>git commit-tree</code> 命令得到的 <code>372aa8e425b57ca30e2974b8e7737133caaa0b7f</code> 提交对象，此时用 <code>git log</code> 就可以看到这条 <code>commit</code> 记录。</p>
</li>
<li>
<p><code>git write-tree --prefix=ss</code> // 将暂存区中 <code>ss</code> 目录下的内容生成一个 <code>tree</code> 对象，并输出其 <code>SHA-1</code> 哈希值。</p>
</li>
<li>
<p><code>git update-ref -d refs/remotes/origin/v1.0</code> // 删除 <code>v1.0</code> 远程分支 <code>cache</code>。</p>
</li>
<li>
<p><code>git update-index --chmod=+x engine_mac.sh</code> // 为 <code>engine_mac.sh</code> 增加可执行权限（Linux、Unix、Mac OS X 系统上需要）。</p>
</li>
</ul>
<h1 id="命令大全">命令大全</h1>
<h2 id="查看命令帮助">查看命令帮助</h2>
<ul>
<li><code>git config --help</code> // 查看 <code>git config</code> 命令详细用法</li>
<li><code>git help config</code> // 功能同上</li>
</ul>
<h2 id="配置">配置</h2>
<ul>
<li><code>git config --global user.name &quot;kekec&quot;</code> // 配置提交用户名。</li>
<li><code>git config --global user.email &quot;kekec@qq.com&quot;</code> // 配置 E-mail 信息。</li>
<li><code>git config --global core.editor vim</code> // 配置默认文本编辑器，当 Git 需要你输入信息时会调用它。</li>
<li><code>git config --global alias.st status</code> // 为 <code>status</code> 配置别名 <code>st</code>，这样 <code>git status</code> 就可以写成 <code>git st</code>。</li>
<li><code>git config --list</code> // 查看当前仓库的所有配置信息（包括分支相关的信息）</li>
<li><code>git config user.name</code> // 查看当前仓库的用户名信息</li>
<li><code>git config -e --global</code> // 编辑全局配置文件（用户名和 E-mail 信息就记录在其中）  所在目录：<code>c:/users/&lt;用户名&gt;/.gitconfig</code>。</li>
<li><code>git config -e</code> // 编辑当前仓库的配置文件  所在目录：<code>.git\config</code>。</li>
</ul>
<h2 id="创建版本库">创建版本库</h2>
<ul>
<li><code>git init</code> // 在当前目录创建一个空的 <code>git</code> 代码库。</li>
<li><code>git init MyGame</code> // 在当前目录创建一个名为 <code>MyGame</code> 的文件夹，然后在其中创建一个空的 <code>git</code> 代码库。</li>
</ul>
<p>.git目录结构如下：<br>
<img src="https://faded.auspicious.space/post-images/1587103199628.png" alt="" loading="lazy"></p>
<ul>
<li>
<p><code>hooks</code>：不同操作时执行的 <code>hook</code> 脚本。</p>
</li>
<li>
<p><code>info/exclude</code>：与 <code>.gitignore</code> 文件（该文件需放在 <code>.git</code> 文件夹的同级目录中，Windows 下可通过命令行 <code>type nul &gt; .gitignore</code> 来创建）一样，用作文件过滤。不同的是：该文件不会提交到版本库，因此过滤只对本地生效，不影响其他人。</p>
<pre><code class="language-bash"># 忽略所有.so 结尾的文件
*.so
# 但 game.so 除外
!game.so
# 仅仅忽略项目根目录下的 README.md 文件，不包括 subdir/README.md
/README.md
# 忽略 .svn/ 目录下的所有文件
.svn/
# 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt
doc/*.txt
# 忽略 doc/ 目录下所有扩展名为 txt 的文件
doc/**/*.txt
</code></pre>
</li>
<li>
<p><code>logs/refs/heads</code>：各个本地分支的版本 <code>log</code> 记录。</p>
</li>
<li>
<p><code>logs/refs/remotes</code>：各个远程分支 <code>cache</code> 的 <code>log</code> 记录。</p>
</li>
<li>
<p><code>logs/refs/stash</code>：储藏区数据。</p>
</li>
<li>
<p><code>logs/HEAD</code>：<code>git</code> 操作记录。</p>
</li>
<li>
<p><code>objects</code>：2 级文件索引（把 <code>SHA-1</code> 哈希值拆成了：<code>2位+38位</code>），存储 <code>commit</code> 数据、<code>blob</code> 文件数据和 <code>tree</code> 目录数据。</p>
</li>
<li>
<p><code>objects/pack</code>：<code>pack</code> 文件为存储 <code>commit</code>、<code>tree</code> 目录及 <code>blob</code> 文件的压缩数据；<code>idx</code> 文件为 <code>pack</code> 文件中各数据对象的索引。</p>
</li>
<li>
<p><code>objects/info/packs</code>：该文件记录所有 <code>git</code> 库的 <code>pack</code> 文件列表。</p>
</li>
<li>
<p><code>refs/heads</code>：各个本地分支 <code>HEAD</code>。</p>
</li>
<li>
<p><code>refs/remotes</code>：各个远程分支 <code>cache</code> 的 <code>HEAD</code>。</p>
</li>
<li>
<p><code>refs/tags</code>：各个附注标签的信息。</p>
</li>
<li>
<p><code>COMMIT_EDITMSG</code>：上一次提交的注释。</p>
</li>
<li>
<p><code>config</code>：版本库相关的配置信息。</p>
</li>
<li>
<p><code>description</code>：仓库描述信息，供 <code>gitweb</code> 程序使用。</p>
</li>
<li>
<p><code>index</code>：暂存区相关的信息。</p>
</li>
<li>
<p><code>HEAD</code>：指向当前分支的最近提交（如：<code>ref: refs/heads/master</code>）。</p>
</li>
<li>
<p><code>ORIG_HEAD</code>：执行 <code>git merge / git pull / git reset</code> 操作时，会把调整为新值之前的先前版本的 <code>HEAD</code> 记录到 <code>OERG_HEAD</code> 中，用于恢复或回滚之前的状态。</p>
</li>
<li>
<p><code>FETCH_HEAD</code>：<code>git fech</code> 将所有抓取分支的 <code>HEAD</code> 记录到 <code>.git/FETCH_HEAD</code> 中。</p>
</li>
<li>
<p><code>MERGEHEAD</code>：正在合并进 <code>HEAD</code> 的 <code>commit id</code>。</p>
</li>
<li>
<p><code>packed-refs</code>：远程版本库 <code>cache</code> 和远程标签 <code>cache</code>。</p>
</li>
</ul>
<h2 id="日志与文件状态">日志与文件状态</h2>
<ul>
<li><code>git reflog</code> // 查看操作记录。<br>
注：每条操作记录使用 <code>HEAD@{n}</code> 来标识。</li>
<li><code>git show HEAD@{5}</code> // 查看索引为 5 的操作记录的详细信息。</li>
<li><code>git status</code> // 查看当前所处的分支暂存区和工作区的文件（会显示当前所处分支）。
<ul>
<li>注1：处于暂存区的文件状态:：<code>staged</code>（已暂存）；处于工作区的文件状态:：<code>untrack</code>（未跟踪）、<code>modified</code>（已修改）；</li>
<li>注2：工作区中的空目录不会被 <code>git</code> 追踪。</li>
</ul>
</li>
<li><code>git status -s --ignored</code> // 以简洁模式查看暂存区和工作区的文件（全部显示，不执行文件过滤）。</li>
<li><code>git status -uno</code> // 查看暂存区和工作区的非 <code>untrack</code>（未跟踪）状态文件。</li>
<li><code>git status -uall</code> // 查看暂存区和工作区的状态文件（递归子目录显示出里面的文件）。</li>
<li><code>git log</code> // 查看本地版本库提交记录（会显示当前所处分支，<code>HEAD</code> 指针指向哪个分支的哪条提交）。</li>
<li><code>git log --stat</code> // 查看本地版本库提交记录（会显示当前所处分支，<code>HEAD</code> 指针指向哪个分支的哪条提交和每次提交的文件变更简略统计信息）。</li>
<li><code>git log -- README.md</code> // 查看 <code>README.md</code> 文件的本地版本库提交记录。</li>
<li><code>git log --graph -- README.md</code> // 以图形化方式查看 <code>README.md</code> 文件的本地版本库提交记录。</li>
<li><code>git log -p README.md</code> // 查看 <code>README.md</code> 文件的本地版本库提交记录（显示出每次的修改内容）。</li>
<li><code>git log --grep &quot;test&quot;</code> // 显示注释中含有 <code>test</code> 字符串的提交。</li>
<li><code>git log --author=kekec</code> // 查看本地版本库中作者为 <code>kekec</code> 的提交记录。</li>
<li><code>git log -S &quot;SplitPath(FString&amp; str)&quot;</code> // 查看 <code>SplitPath(FString&amp; str)</code> 内容是什么时候加到项目中那些文件中去的。</li>
<li><code>git log --since=2.weeks</code> // 查看最近 2 周的提交记录。</li>
<li><code>git log --since=&quot;2 weeks 3 days 2 hours 30 minutes 59 seconds ago&quot;</code> // 查看 2 周 3 天 2 小时 30 分 59 秒以前的提交记录。</li>
<li><code>git log --after=&quot;2018-10-7&quot; --before=&quot;2018-10-12&quot;</code> // 查看 <code>2018.10.7~2018.10.12</code> 之间的提交记录。</li>
<li><code>git log --since=&quot;2018-10-7&quot; --until=&quot;2018-10-12&quot;</code> // 功能同上：<code>git log --after=&quot;2018-10-7&quot; --before=&quot;2018-10-12&quot;</code>。<br>
注：<code>--since</code>、<code>--until</code> 标记和 <code>--after</code>、<code>--before</code> 标记分别是等价的。</li>
<li><code>git whatchanged README.md</code> // 查看 <code>README.md</code> 文件的本地版本库提交记录（包括文件改名）。</li>
<li><code>git log --follow README.md</code> // 功能同上：<code>git whatchanged README.md</code>。</li>
<li><code>git log -3</code> // 查看最近 3 条本地版本库提交记录。</li>
<li><code>git log -3 --pretty --oneline</code> // 查看最近 3 条本地版本库提交记录（简洁模式，一行显示一个提交）。</li>
<li><code>git log --graph --oneline</code> // 以图形化简洁模式查看当前分支的本地版本库提交记录。</li>
<li><code>git log release --graph --oneline</code> // 以图形化简洁模式查看 <code>release</code> 分支的本地版本库提交记录。</li>
<li><code>git log --graph --oneline --no-merges</code> // 以图形化简洁模式查看当前分支的本地版本库提交记录（过滤 <code>merge</code> 过来的提交）。</li>
<li><code>git log --graph --oneline --merges</code> // 以图形化简洁模式查看当前分支的本地版本库提交记录（只显示有 2 个及以上父亲节点的提交）。</li>
<li><code>git log --graph --oneline --name-only</code> // 以图形化简洁模式查看当前分支的本地版本库提交记录（并显示每次提交的文件名称清单）。</li>
<li><code>git log --graph --oneline --name-status</code> // 以图形化简洁模式查看当前分支的本地版本库提交记录（并显示每次提交的文件状态、名称清单）。</li>
<li><code>git log --graph --oneline --stat</code> // 以图形化简洁模式查看当前分支的本地版本库提交记录（并显示每次提交的文件变化统计、各文件名及增删记录）。</li>
<li><code>git log --graph --oneline --shortstat</code> // 以图形化简洁模式查看当前分支的本地版本库提交记录（并显示每次提交的文件变化统计及增删记录）。</li>
<li><code>git log --graph --oneline --decorate --all</code> // 以图形化简洁模式查看所有分支的本地版本库提交记录树。</li>
<li><code>git log --graph --pretty=format:&quot;%H - %an, %ad : %s&quot;</code> // 自定义格式图形化查看所有分支的本地版本库提交记录树。
<ul>
<li><code>%H</code> 提交对象（<code>commit</code>）的完整哈希字串；</li>
<li><code>%h</code> 提交对象的简短哈希字串；</li>
<li><code>%T</code> 树对象（<code>tree</code>）的完整哈希字串；</li>
<li><code>%t</code> 树对象的简短哈希字串；</li>
<li><code>%P</code> 父对象（<code>parent</code>）的完整哈希字串；</li>
<li><code>%p</code> 父对象的简短哈希字串；</li>
<li><code>%an</code> 作者（<code>author</code>）的名字；</li>
<li><code>%ae</code> 作者的电子邮件地址；</li>
<li><code>%ad</code> 作者修订日期（可以用 <code>--date=</code> 选项定制格式）；</li>
<li><code>%ar</code> 作者修订日期，按多久以前的方式显示；</li>
<li><code>%cn</code> 提交者（<code>committer</code>）的名字；</li>
<li><code>%ce</code> 提交者的电子邮件地址；</li>
<li><code>%cd</code> 提交日期；</li>
<li><code>%cr</code> 提交日期，按多久以前的方式显示；</li>
<li><code>%s</code> 提交说明；</li>
</ul>
</li>
<li><code>git log master..v5.0</code> // 查看 <code>v5.0</code> 分支还未合并到 <code>master</code> 分支上的提交记录列表。</li>
<li><code>git log v5.0..master</code> // 查看 <code>master</code> 分支还未合并到 <code>v5.0</code> 分支上的提交记录列表。</li>
<li><code>git log master...v5.0</code> // <code>git log master..v5.0 + git log v5.0..master</code>。</li>
<li><code>git shortlog -sn</code> // 统计各个提交者的次数。</li>
<li><code>git blame README.md</code> // 显示 <code>README.md</code> 最近一次的修改信息。</li>
<li><code>git show 3a6c702376168aa15a2f3d7bc98000d07a70d023 README.md</code> // 查看 <code>README.md</code> 文件的 <code>3a6c702376168aa15a2f3d7bc98000d07a70d023</code> 提交的修改内容。</li>
<li><code>git show HEAD</code> // 查看最近一次提交的修改内容。</li>
<li><code>git show --name-only HEAD</code> // 查看最近一次提交的文件列表（不显示具体的修改内容）。</li>
</ul>
<h2 id="标签查看新建切换删除">标签（查看/新建/切换/删除）</h2>
<ul>
<li><code>git tag</code> // 列出所有的标签。</li>
<li><code>git tag -l 'tag1*'</code> // 列出所有 <code>tag1</code> 开头的标签。</li>
<li><code>git tag tag1.0</code> // 创建名为 <code>tag1.0</code> 的轻量标签。</li>
<li><code>git tag -a tag1.0 -m &quot;tag1.0 desc&quot;</code> // 添加 <code>tag1.0 desc</code> 注释并创建名为 <code>tag1.0</code> 的附注标签。</li>
<li><code>git tag tag2.0 abffefc5d82078cbaea7fcbb5106ab0c21cbeba9</code> // 在 <code>abffefc5d82078cbaea7fcbb5106ab0c21cbeba9</code> 提交处创建名为 <code>tag2.0</code> 的轻量标签。</li>
<li><code>git tag -a tag2.0 -m &quot;tag2.0 desc&quot; abffefc</code> // 在 <code>abffefc</code> 提交处创建名为 <code>tag2.0</code> 的附注标签。</li>
<li><code>git tag -d tag2.0</code> // 删除名为 <code>tag2.0</code> 的标签。</li>
<li><code>git show tag1.0</code> // 查看名为 <code>tag1.0</code> 相关的信息。</li>
<li><code>git ls-remote --tags</code> // 查看所有远端的标签。</li>
</ul>
<h2 id="分支查看新建切换删除">分支（查看/新建/切换/删除）</h2>
<ul>
<li><code>git branch</code> // 列出所有本地分支。</li>
<li><code>git branch -r</code> // 列出所有远程分支 <code>cache</code>。</li>
<li><code>git branch -a</code> // 列出所有本地分支和远程分支 <code>cache</code>。</li>
<li><code>git branch -av</code> // 列出所有本地分支和远程分支 <code>cache</code>（含简单说明）。</li>
<li><code>git branch -vv</code> // 查看所有本地分支和远程分支 <code>cache</code> 之间的追踪关系。</li>
<li><code>git branch v1.0</code> // 在当前分支的 <code>HAED</code> 指针下创建名为 <code>v1.0</code> 的分支（创建完不会切到 <code>v1.0</code> 分支上）。</li>
<li><code>git branch --track v1.0 origin/v1.0</code> // 若 <code>v1.0</code> 分支不存在则先新建，然后将其与远程分支 <code>origin/v1.0</code> 建立追踪关系。
<ul>
<li>远程分支 <code>origin/v1.0</code> 要存在，否则命令执行失败。</li>
<li>执行完不会切到 <code>v1.0</code> 分支上。</li>
</ul>
</li>
<li><code>git branch v2.0 372aa8e425b57ca30e2974b8e7737133caaa0b7f</code> // 在 <code>372aa8e425b57ca30e2974b8e7737133caaa0b7f</code> 提交处创建名为 <code>v2.0</code> 的分支（创建完不会切到 <code>v2.0</code> 分支上）。</li>
<li><code>git branch -m v1.0 x1.0</code> // 将分支 <code>v1.0</code> 重命名为 <code>x1.0</code>。</li>
<li><code>git checkout v1.0 // 切换到</code>v1.0<code>分支上（</code>v1.0` 分支不存在则命令执行失败）。</li>
<li><code>git checkout -b v1.0</code> // 创建并切换到 <code>v1.0</code> 分支上（<code>v1.0</code> 分支存在则命令执行失败）。</li>
<li><code>git checkout -B v1.0</code> // 不存在则创建，并切换到 <code>v1.0</code> 分支上。</li>
<li><code>git checkout -b v1.0 5a95f2d</code> // 在 <code>5a95f2d</code> 提交处创建并切换到 <code>v1.0</code> 的分支上。</li>
<li><code>git checkout -b v1.0 tag1.0</code> // 在标签 <code>tag1.0</code> 处创建并切换到 <code>v1.0</code> 的分支上。</li>
<li><code>git checkout -t origin/v1.0</code> // 创建并切换到 <code>origin/v1.0</code> 远程分支 <code>cache</code> 的名为 <code>v1.0</code> 本地分支上，并建立两者追踪关系（本地分支 <code>v1.0</code> 存在则命令执行失败）。</li>
<li><code>git checkout -b x1.0 -t origin/v1.0</code> // 创建并切换到 <code>origin/v1.0</code> 远程分支 <code>cache</code> 的名为 <code>x1.0</code> 本地分支上，并建立两者追踪关系（本地分支 <code>x1.0</code> 存在则命令执行失败）
<ul>
<li>注1：切换分支前，必须处理工作区（未追踪的文件不用处理）和暂存区的修改才能切换成功</li>
<li>注2：切换成功后，工作区会被设置成分支的内容</li>
<li>注3：不允许在远程分支 <code>cache</code> 上提交，需要创建对应关联的本地分支，然后在本地分支上进行提交。</li>
</ul>
</li>
<li><code>git checkout -f v1.0</code> // 强制切换到 <code>v1.0</code> 分支上，丢弃暂存区和工作区中的所有文件的修改（工作区中未追踪的文件不受影响）。</li>
<li><code>git checkout -f -B v1.0 origin/v1.0</code> // 不存在则创建，强制切换到 <code>v1.0</code> 分支上，丢弃暂存区和工作区中的所有文件的修改，并将 <code>HEAD</code> 指向 <code>origin/v1.0</code> 处（工作区中未追踪的文件不受影响）。</li>
<li><code>git checkout -</code> // 切换到上一次分支。</li>
<li><code>git branch -d v2.0</code> // 删除名为 <code>v2.0</code> 的分支（必须先切到其他分支上才能执行删除操作）。</li>
<li><code>git branch -D v2.0 // 强制删除名为</code>v2.0` 的分支（必须先切到其他分支上才能执行删除操作）。</li>
<li><code>git branch -dr origin/v2.0</code> // 删除远程分支 <code>origin/v2.0 cache</code>。</li>
</ul>
<h2 id="文件增加删除提交撤销">文件（增加/删除/提交/撤销）</h2>
<ul>
<li>
<p><code>git add README.md</code> // 将当前目录下的 <code>README.md</code> 文件加入到暂存区。</p>
</li>
<li>
<p><code>git add .</code> // 将当前目录下（递归子目录）所有文件加入到暂存区。</p>
</li>
<li>
<p><code>git add -u .</code> // 将当前目录下（递归子目录）所有追踪状态的文件加入到暂存区。</p>
</li>
<li>
<p><code>git add Doc/\*.txt</code> // 将当前目录的 <code>Doc</code> 文件夹下（递归子目录）所有 <code>txt</code> 后缀的文件加入到暂存区。</p>
</li>
<li>
<p><code>git rm README.md</code> // 删除工作区文件，并且将这次删除放入暂存区（若 <code>README.md</code> 在工作区或暂存区中有修改，命令会执行失败）。</p>
</li>
<li>
<p><code>git rm -f README.md</code> // 强制删除工作区文件，并且将这次删除放入暂存区（即使 <code>README.md</code> 在工作区或暂存区中有修改，也会执行删除操作）。</p>
</li>
<li>
<p><code>git rm --cached README.md</code> // 不删除工作区对应的文件，只将 <code>README.md</code> 删除放入暂存区以供提交。</p>
</li>
<li>
<p><code>git mv README.md test.md</code> // 将 <code>README.md</code> 改名为 <code>test.md</code>，并且将这个改名放入暂存区。</p>
</li>
<li>
<p><code>git commit -m &quot;desc&quot;</code> // 添加 <code>desc</code> 注释并将暂存区中的所有修改提交到本地仓库。</p>
</li>
<li>
<p><code>git commit README.md -m &quot;desc&quot;</code> // 添加 <code>desc</code> 注释并将暂存区中的 <code>README.md</code> 的修改提交到本地仓库。</p>
</li>
<li>
<p><code>git commit --amend -m &quot;desc&quot;</code> // 添加 <code>desc</code> 注释使用当前提交覆盖上一次的提交（若上一次提交包含 <code>1.txt</code> 和 <code>2.txt</code> 的修改，当前提交只包含 <code>1.txt</code> 的修改；执行命令后，本地版本库中为本次的 <code>1.txt</code> 和上一次 <code>2.txt</code>）。若没有提交内容，则用来改写上一次提交的日志信息。</p>
</li>
<li>
<p><code>git commit -m &quot;desc&quot; --amend README.txt</code> // 添加 <code>desc</code> 注释使用 <code>README.txt</code> 的当前提交覆盖上一次的提交。</p>
</li>
<li>
<p><code>git commit -a -m &quot;desc&quot;</code> // 添加 <code>desc</code> 注释并将工作区和暂存区中的所有修改提交到本地仓库。</p>
</li>
<li>
<p><code>git commit -am &quot;desc&quot;</code> // 功能同上。</p>
</li>
<li>
<p><code>git commit -c b5cad94d229e72bd7aff5fe2c6f022b29c30e7a8</code> // 拿 <code>372aa8e425b57ca30e2974b8e7737133caaa0b7f</code> 提交的信息（作者、提交者、注释、时间戳等）来提交当前修改。</p>
</li>
<li>
<p><code>git reset -- README.md</code> // 丢弃暂存区中的 <code>README.md</code> 文件的修改。</p>
</li>
<li>
<p><code>git reset README.md</code> // 功能如上，丢弃暂存区中的 <code>README.md</code> 文件的修改。</p>
</li>
<li>
<p><code>git reset b5cad94 README.md</code> // 使用本地版本库 <code>b5cad94</code> 提交处的 <code>README.md</code> 版本覆盖暂存区中的 <code>README.md</code>。</p>
</li>
<li>
<p><code>git reset</code> // 丢弃暂存区中的所有文件的修改（工作区不受影响）。</p>
</li>
<li>
<p><code>git reset --mixed</code> // <code>--mixed</code> 为缺省参数，命令与上面 <code>git reset</code> 一样。</p>
</li>
<li>
<p><code>git reset --hard</code> // 丢弃暂存区和工作区中的所有文件的修改（工作区中未追踪的文件不受影响）。</p>
</li>
<li>
<p><code>git reset --soft b5cad94d229e72bd7aff5fe2c6f022b29c30e7a8</code> // 仅将当前分支的。<code>HEAD</code> 指向 <code>372aa8e425b57ca30e2974b8e7737133caaa0b7f</code> 提交（暂存区和工作区中的所有文件的修改都不丢弃）。</p>
</li>
<li>
<p><code>git reset --soft HEAD~</code> // 仅将当前分支的 <code>HEAD</code> 指向上一次提交（暂存区和工作区中的所有文件的修改都不丢弃）。</p>
</li>
<li>
<p><code>git reset --soft HEAD~2</code> // 仅将当前分支的 <code>HEAD</code> 指向上两次提交（暂存区和工作区中的所有文件的修改都不丢弃）。</p>
</li>
<li>
<p><code>git reset --merge &lt;commit&gt;</code> // 在被污染的工作区中回滚 <code>merge</code> 或者 <code>pull</code>。</p>
<pre><code class="language-bash">$ git pull                         (1) 
Auto-merging nitfol 
Merge made by recursive. 
nitfol                |   20 +++++---- 
... 
$ git reset --merge ORIG_HEAD      (2)
</code></pre>
<ol>
<li>即便你已经在本地更改了一些你的工作区，你也可安全的 <code>git pull</code>，前提是你知道将要 <code>pull</code> 的内容不会覆盖你的工作区中的内容。</li>
<li><code>git pull</code> 完后，你发现这次 <code>pull</code> 下来的修改不满意，想要回滚到 <code>pull</code> 之前的状态，我们可以执行 <code>git reset --hard ORIG_HEAD</code>，但是这个命令有个副作用就是清空你的工作区，即丢弃你的本地未 <code>add</code> 的那些改变。</li>
</ol>
<p>为了避免丢弃工作区中的内容，可以使用 <code>git reset --merge ORIG_HEAD</code>，注意其中的<code>--hard</code> 换成了 <code>--merge</code>，这样就可以避免在回滚时清除工作区。</p>
</li>
<li>
<p><code>git reset --keep &lt;commit&gt;</code> // 保留工作区并丢弃一些之前的提交。<br>
假设你正在编辑一些文件，并且已经提交，接着继续工作，但是现在你发现当前在工作区中的内容应该属于另一个分支，与之前的提交没有什么关系。此时，可以开启一个新的分支，并且保留着工作区中的内容。</p>
<pre><code class="language-bash">$ git tag start 
$ git checkout -b branch1 
$ edit 
$ git commit ...                            (1) 
$ edit 
$ git checkout -b branch2                   (2) 
$ git reset --keep start                    (3)
</code></pre>
<ol>
<li>这次是把在 <code>branch1</code> 中的改变提交了。</li>
<li>此时发现，之前的提交不属于这个分支，此时新建了 <code>branch2</code> 分支，并切换到了 <code>branch2</code> 上。</li>
<li>此时可以用 <code>reset --keep</code> 把在 <code>start</code> 之后的提交清除掉，但是保持工作区不变。</li>
</ol>
</li>
<li>
<p><code>git checkout -- README.md</code> // <code>--</code> 符号非常重，否则就变成了切换到 <code>README.md</code> 分支了。<br>
// 当 <code>README.md</code> 在暂存区中有修改时，使用暂存区中的修改覆盖工作区中的 <code>README.md</code>。<br>
// 当 <code>README.md</code> 不在暂存区中时，使用本地版本库中的 <code>HEAD</code> 指针处的修改覆盖工作区中的 <code>README.md</code>。</p>
</li>
<li>
<p><code>git checkout -- .</code> // 使用暂存区和本地版本库来恢复当前目录（递归子目录）下的所有文件。<br>
注：若暂存区中有修改，优先使用暂存区。</p>
</li>
<li>
<p><code>git checkout HEAD README.md</code> // 使用本地版本库中的 <code>HEAD</code> 处提交覆盖暂存区和工作区中的 <code>README.md</code>。</p>
</li>
<li>
<p><code>git checkout 9a387f22ff949fa16336508adc2284384bd6a890 README.md</code> // 使用本地版本库中的 <code>9a387f22ff949fa16336508adc2284384bd6a890</code> 修改覆盖暂存区和工作区中的 <code>README.md</code>。</p>
</li>
<li>
<p><code>git checkout -b v2.0 tag2.0</code> // 在名为 <code>tag2.0</code> 的提交处创建并切换到 <code>v2.0</code> 分支上（<code>v2.0</code> 分支存在则命令执行失败）。</p>
</li>
<li>
<p><code>git revert --no-edit 3a6c702376168aa15a2f3d7bc98000d07a70d023</code> // 回滚 <code>3a6c702376168aa15a2f3d7bc98000d07a70d023</code> 提交，然后提交到本地仓库。</p>
</li>
<li>
<p><code>git revert HEAD~</code> // 回滚 <code>HEAD</code> 的上一次提交，然后会弹出 <code>vim</code> 环境编辑注释（输入 <code>:q</code> 直接使用默认注释内容、输入 <code>:q!</code> 放弃修改使用默认注释内容、输入 <code>:x</code> 或 <code>:wq</code> 保存当前修改的注释内容），然后提交到本地仓库。</p>
</li>
<li>
<p><code>git revert -n HEAD~3</code> // 回滚掉 <code>HEAD~3</code> 处的提交，不自动提交到本地仓库。</p>
</li>
<li>
<p><code>git revert -n HEAD~2..HEAD</code> // 回滚掉 <code>(HEAD~2, HEAD]</code> 之间的 2 次提交，不自动提交到本地仓库。<br>
注：<code>git reset</code> 是把 <code>HEAD</code> 向后移动来删除提交，而 <code>git revert</code> 是用一次新的提交来回滚之前的提交（<code>HEAD</code> 会继续前进）。</p>
</li>
</ul>
<h2 id="查看差异">查看差异</h2>
<ul>
<li><code>git diff README.md</code> // 查看当前目录下的 <code>README.md</code> 在工作区和暂存区之间的差异。</li>
<li><code>git diff --cached README.md</code> // 查看当前目录下的 <code>README.md</code> 在暂存区和本地仓库最后一次提交之间的差异。</li>
<li><code>git diff --cached 372aa8e425b57ca30e2974b8e7737133caaa0b7f README.md</code> // 查看当前目录下的 <code>README.md</code> 在暂存区和本地仓库的 <code>372aa8e425b57ca30e2974b8e7737133caaa0b7f</code> 提交之间的差异。</li>
<li><code>git diff HEAD README.md</code> // 查看当前目录下的 <code>README.md</code> 在工作区和本地仓库 <code>HEAD</code> 指针处提交之间的差异。</li>
<li><code>git diff 372aa8e425b57ca30e2974b8e7737133caaa0b7f README.md</code> // 查看当前目录下的 <code>README.md</code> 在工作区和本地仓库的 <code>372aa8e425b57ca30e2974b8e7737133caaa0b7f</code> 提交之间的差异。</li>
<li><code>git diff 372aa8e425b57ca30e2974b8e7737133caaa0b7f HEAD README.md</code> // 查看当前目录下的 <code>README.md</code> 在本地仓库的 <code>372aa8e425b57ca30e2974b8e7737133caaa0b7f</code> 提交和最后一次提交之间的差异。</li>
<li><code>git diff 372aa8e425b57ca30e2974b8e7737133caaa0b7f HEAD</code> // 查看本地仓库的 <code>372aa8e425b57ca30e2974b8e7737133caaa0b7f</code> 提交和最后一次提交之间的差异。</li>
<li><code>git diff 372aa8e b5cad94 README.md</code> // 查看当前目录下的 <code>README.md</code> 在本地仓库的 <code>372aa8e</code> 提交和 <code>b5cad94</code> 提交之间的差异<br>
注：可以将 <code>git diff</code> 换成 <code>git difftool</code> 来使用外部 <code>diff</code> 工具（可以在 <code>c:/users/&lt;用户名&gt;/.gitconfig</code> 文件配置 <code>beyond compare</code> 作为默认的 <code>difftool</code> 和 <code>mergetool</code>）来查看差异。<pre><code class="language-bash">[diff]
    tool = bc3
[difftool]
    prompt = false
[difftool &quot;bc3&quot;]
    cmd = &quot;\&quot;e:/program files (x86)/beyond compare 3/bcomp.exe\&quot; \&quot;$LOCAL\&quot; \&quot;$REMOTE\&quot;&quot;
</code></pre>
</li>
</ul>
<h2 id="分支合并">分支合并</h2>
<ul>
<li>
<p><code>git merge-base Master Feature</code> // 查看 <code>Master</code> 和 <code>Feature</code> 分支的最优共同 <code>commit</code> 父节点。</p>
</li>
<li>
<p><code>git merge Feature</code> // 将 <code>Feature</code> 分支 <code>merge</code> 合并到当前分支 <code>Master</code>（无冲突时会直接提交）。</p>
</li>
<li>
<p><code>git merge -m &quot;merge test&quot; Feature</code> // 将 <code>Feature</code> 分支 <code>merge</code> 合并到当前分支 <code>Master</code>（无冲突时使用 <code>merge test</code> 注释直接提交）。</p>
</li>
<li>
<p><code>git merge --no-commit Feature</code> // 将 <code>Feature</code> 分支 <code>merge</code> 合并到当前分支 <code>Master</code>（不自动提交）。</p>
</li>
<li>
<p><code>git rebase Feature</code> // 将 <code>Feature</code> 分支 <code>rebase</code> 合并到当前分支 <code>Master</code>。<br>
<img src="https://faded.auspicious.space/post-images/1587126526914.png" alt="" loading="lazy"></p>
<ul>
<li>注1：<code>git rebase</code> 会先找出共同的祖先节点，从祖先节点把 <code>Feature</code> 分支的提交记录全都剪切下来，然后合到 <code>Master</code> 分支（合并前后 <code>commitID</code> 会不一样）。</li>
<li>注2：相对来说，<code>git merge</code> 处理冲突更直接，但会增加一些冗余的提交记录；而 <code>git rebase</code> 能够保证清晰线性的提交记录，但这也将合并的操作没有被记录下来。</li>
<li>注3：最好是用 <code>git rebase</code> 合并远程分支到本地，<code>git merge</code> 合并 <code>Feature</code> 分支到 <code>Master</code> 分支。</li>
<li>注4：在合并 <code>Feature</code> 分支到 <code>Master</code> 分支前，务必先执行 <code>git pull -r origin Feature</code> 来进行远程分支与本地分支的 <code>rebase</code> 合并。</li>
<li>注5：处于冲突状态（<code>conflict</code>）的文件为 <code>UU</code>（可通过 <code>git status -s --ignored</code> 来查找），手动处理完冲突后，然后使用 <code>git add</code> 该文件，最后继续执行 <code>git merge/rebase --continue</code> 来完成合并的提交工作。</li>
<li>注6：<code>README.md</code> 文件冲突内容如下<pre><code class="language-bash">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
123 456 789 000 111 222 333 444 555 ss  // 当前分支的内容
=======
123 456 789 000 ss tt  // Feature 分支的内容
&gt;&gt;&gt;&gt;&gt;&gt;&gt; Feature
</code></pre>
</li>
<li>注7：可以使用 <code>git mergetool</code> 来使用外部 <code>merge</code> 工具（可以在 <code>c:/users/&lt;用户名&gt;/.gitconfig</code> 文件配置 <code>beyond compare</code> 作为默认的 <code>mergetool</code>）来处理冲突。<br>
修改完当前文件后，可再次调用 <code>git mergetool</code> 来处理下一个冲突，直至全部处理完毕，然后使用 <code>git add</code> 该文件，最后继续执行 <code>git merge/rebase --continue</code> 来完成合并的提交工作。<pre><code class="language-bash">[merge]
    tool = bc3
[mergetool]
    prompt = false
[mergetool &quot;bc3&quot;]
    cmd = &quot;\&quot;e:/program files (x86)/beyond compare 3/bcomp.exe\&quot; \&quot;$LOCAL\&quot; \&quot;$REMOTE\&quot; \&quot;$BASE\&quot; \&quot;$MERGED\&quot;&quot;
</code></pre>
<img src="https://faded.auspicious.space/post-images/1587127706910.png" alt="" loading="lazy"></li>
</ul>
</li>
<li>
<p><code>git rebase /i Feature</code> // 将 <code>Feature</code> 分支采用手动交互方式 <code>rebase</code> 合并到当前分支 <code>Master</code>。</p>
<pre><code class="language-bash">pick 07c5abd Introduce OpenPGP and teach basic usage

pick de9b1eb Fix PostChecker::Post#urls
pick 3e7ee36 Hey kids, stop all the highlighting
pick fa20af3 git interactive rebase, squash, amend

# Rebase 8db7e8b..fa20af3 onto 8db7e8b
#
# Commands:
# p, pick = use commit
# r, reword = use commit, but edit the commit message
# e, edit = use commit, but stop for amending
# s, squash = use commit, but meld into previous commit
# f, fixup = like &quot;squash&quot;, but discard this commit's log message
# x, exec = run command (the rest of the line) using shell
#
# These lines can be re-ordered; they are executed from top to bottom.
#
# If you remove a line here THAT COMMIT WILL BE LOST.
#
# However, if you remove everything, the rebase will be aborted.
#
# Note that empty commits are commented out
</code></pre>
</li>
<li>
<p><code>git merge/rebase --abort</code> // 撤销当前 <code>merge</code> 或 <code>rebase</code> 操作。</p>
</li>
<li>
<p><code>git merge/rebase --skip</code> // 强制使用 <code>Feature</code> 分支的内容。</p>
</li>
<li>
<p><code>git merge/rebase --continue</code> // 手动处理完冲突后使用 <code>git add</code> 该文件，最后继续执行 <code>git merge/rebase --continue</code> 来完成合并的提交工作。</p>
</li>
<li>
<p><code>git merge origin/master</code> // <code>fetch</code> 完之后，可以将远程分支 <code>cache master</code> 分支 <code>merge</code> 合并到当前分支上。</p>
</li>
<li>
<p><code>git rebase origin/master</code> // <code>fetch</code> 完之后，可以将远程分支 <code>cache master</code> 分支 <code>rebase</code> 合并到当前分支上。</p>
</li>
<li>
<p><code>git rebase --onto master 76cada~</code> // 将当前分支从 <code>[76cada, HEAD]</code> 区间段的提交 <code>rebase</code> 合并到 <code>master</code> 上。</p>
</li>
<li>
<p><code>git cherry-pick 9a341e</code> // 将 <code>9a341e</code> 提交合入当前分支。若不冲突，则直接使用 <code>9a341e</code> 的提交信息进行 <code>commit</code>，否则要先进行冲突处理，然后继续执行 <code>git cherry-pick --continue</code> 来完成合并的提交工作。</p>
</li>
<li>
<p><code>git cherry-pick 371c2…971209</code> // 将 <code>(371c2, 971209]</code> 提交合入当前分支（每个提交都会在当前分支上创建一个 <code>commit</code>）。</p>
</li>
<li>
<p><code>git cherry-pick 371c2~…971209</code> // 将 <code>[371c2, 971209]</code> 提交合入当前分支（每个提交都会在当前分支上创建一个 <code>commit</code>）。</p>
</li>
<li>
<p><code>git cherry-pick -n 9a341e d2f99e</code> // 将 <code>9a341e</code> 和 <code>d2f99e</code> 提交合入当前分支（不提交），后续需要手动 <code>commit</code>。</p>
</li>
<li>
<p><code>git cherry-pick --abort</code> // 撤销当前 <code>cherry-pick</code> 操作。</p>
</li>
<li>
<p><code>git cherry-pick --quit</code> // 清理当前操作状态，不撤销修改强制退出 <code>cherry-pick</code> 操作过程。</p>
</li>
<li>
<p><code>git cherry-pick --continue</code> // 手动处理完冲突后，最后继续执行 <code>git cherry-pick --continue</code> 来完成合并的提交工作。</p>
</li>
</ul>
<h2 id="查看远程版本库">查看远程版本库</h2>
<ul>
<li><code>git remote -v</code> // 显示远程仓库的 <code>URL</code>。<br>
注：由于 <code>git</code> 是分布式的，所有远程仓库可能有很多个<pre><code class="language-bash">origin https://github.com/kekec/Test.git (fetch)
origin https://github.com/kekec/Test.git (push)
</code></pre>
</li>
<li><code>git remote -ls</code> // 查看远程仓库 <code>URL</code> 和分支信息<pre><code class="language-bash">From https://github.com/kekec/Test.git
fae0fc82d711425daa897a63137d7e1af09512ba HEAD
fae0fc82d711425daa897a63137d7e1af09512ba refs/heads/master
</code></pre>
</li>
<li><code>git remote</code> // 查看远程仓库名称，一般为 <code>origin</code>。</li>
<li><code>git remote rename origin test</code> // 将远程仓库名称从 <code>origin</code> 修改为 <code>test</code>。</li>
<li><code>git remote show origin</code> // 显示远程仓库的信息。<pre><code class="language-bash">* remote origin  
Fetch URL: https://github.com/kekec/Test.git  
Push URL: https://github.com/kekec/Test.git  
HEAD branch: master  
Remote branches:    
master tracked    
v3.1 tracked
Local branch configured for 'git pull':    
master merges with remote master
Local refs configured for 'git push':    
master pushes to master (fast-forwardable)    
v3.1 pushes to v3.1 (up to date)
</code></pre>
</li>
<li><code>git remote rm origin</code> // 删除 <code>.git/config</code> 文件中添加 <code>remote origin</code> 相关的信息。</li>
<li><code>git remote add origin https://github.com/kekec/Test.git</code> // 在 <code>.git/config</code> 文件中添加 <code>remote origin</code> 指向的远程仓库 <code>URL</code>（若已存在，则命令执行失败）。<pre><code class="language-bash">[remote &quot;origin&quot;]
    url = https://github.com/kekec/Test.git
    fetch = +refs/heads/*:refs/remotes/origin/*
</code></pre>
</li>
<li><code>git remote set-url origin https://github.com/kekec/Test.git</code> // 修改 <code>.git/config</code> 文件中添加 <code>remote origin</code> 指向的远程仓库 <code>URL</code>。</li>
<li><code>git remote prune origin</code> // 对于远程仓库不存在的分支，清除对应的远程分支 <code>cache</code>。</li>
</ul>
<h2 id="远程操作">远程操作</h2>
<ul>
<li><code>git clone https://github.com/kekec/Test.git</code> // 将 https://github.com/kekec/Test.git 上的当前分支克隆到本地（会创建一个名为 <code>Test</code> 目录，远程仓库名称使用默认名 <code>origin</code>）。</li>
<li><code>git clone https://github.com/kekec/Test.git MyProject</code> // 将 https://github.com/kekec/Test.git 上的当前分支克隆到本地（会创建一个名为 <code>MyProject</code> 目录，远程仓库名称使用默认名 <code>origin</code>）。</li>
<li><code>git clone -b v1.0 https://github.com/kekec/Test.git</code> // 将 https://github.com/kekec/Test.git 上的 <code>v1.0</code> 分支克隆到本地（会创建一个名为 <code>Test</code> 目录，远程仓库名称使用默认名 <code>origin</code>）。</li>
<li><code>git clone -b v1.0 https://github.com/kekec/Test.git d:\MyGame</code> // 将 https://github.com/kekec/Test.git 上的 <code>v1.0</code> 分支克隆到 <code>d:\MyGame</code> 目录（会在 <code>d:\MyGame</code> 中创建一个名为 <code>Test</code> 目录，远程仓库名称使用默认名 <code>origin</code>）。</li>
<li><code>git clone -o TestPrj https://github.com/kekec/Test.git</code> // 将 https://github.com/kekec/Test.git 上的当前分支克隆到本地（会创建一个名为 <code>Test</code> 目录，并将远程仓库名称设置为 <code>TestPrj</code>）。</li>
<li><code>git fetch origin master</code> // 从远程仓库拉取 <code>master</code> 分支状态的变化信息（工作区文件不会更新）。</li>
<li><code>git fetch</code> // 从远程仓库拉取所有分支和 <code>tag</code> 状态的变化信息（工作区文件不会更新）。</li>
<li><code>git fetch -p</code> // 从远程仓库拉取所有分支和 <code>tag</code> 状态的变化信息，并清除已被删除的远程分支和 <code>tag</code> 在本地的缓存（工作区文件不会更新）。</li>
<li><code>git fetch origin --tags</code> // 从远程仓库拉取所有 <code>tag</code> 到本地（工作区文件不会更新）。</li>
<li><code>git pull &lt;远程仓库名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</code>。</li>
<li><code>git pull origin master</code> // 先执行 <code>fetch</code>，然后将远程 <code>origin/master</code> 分支 <code>merge</code> 合并到当前分支（最后会更新 <code>origin/master</code>，<code>origin/HEAD</code> 指针到最新提交）。</li>
<li><code>git pull https://github.com/kekec/Test.git master</code> // 先执行 <code>fetch</code>，将远程 <code>origin/master</code> 分支 <code>merge</code> 合并到当前分支（最后不会更新 <code>origin/master</code>，<code>origin/HEAD</code> 指针到最新提交）。</li>
<li><code>git pull origin v1.0:master</code> // 先执行 <code>fetch</code>，然后将远程 <code>origin/v1.0</code> 分支 <code>merge</code> 合并到本地 <code>master</code> 分支。</li>
<li><code>git pull origin</code> // 先执行 <code>fetch</code>，然后将对应的远程分支 <code>merge</code> 合并到当前分支（当前分支需要预存远程分支的追踪关系）。</li>
<li><code>git pull</code> // 先执行 <code>fetch</code>，然后将对应的远程分支 <code>merge</code> 合并到当前分支（当前分支需要预存远程分支的追踪关系，而且当前分支只有一个远程仓库）。</li>
<li><code>git pull -p</code> // 先执行 <code>fetch</code>，然后将对应的远程分支 <code>merge</code> 合并到当前分支，并清除已被删除的远程分支和 <code>tag</code> 在本地的缓存。</li>
<li><code>git pull -r origin master</code> // 先执行 <code>fetch</code>，然后将远程 <code>origin/master</code> 分支 <code>rebase</code> 合并到 <code>master</code> 分支。</li>
<li><code>git push &lt;远程仓库名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</code>。</li>
<li><code>git push -u origin master</code> // 将本地仓库的修改 <code>push</code> 到 <code>origin</code> 所指向的远程仓库 <code>URL</code> 的 <code>master</code> 分支上，并在 <code>.git/config</code> 文件中记录当前分支与远程分支 <code>master</code> 的对应关系。</li>
<li><code>git push origin</code> // 将当前分支更新推送给对应的远端分支。</li>
<li><code>git push</code> // 将当前分支更新推送给对应的远端分支（当前分支只有一个远程仓库，可以省略仓库名 <code>origin</code>）。</li>
<li><code>git push origin -f</code> // 使用当前分支更新强行覆盖对应的远端分支（合入远端分支有冲突时，也使用当前分支更新）。</li>
<li><code>git push origin v1.0</code> // 将本地分支 <code>v1.0</code> 更新推送给对应的远端分支 <code>remotes/origin/v1.0</code>。</li>
<li><code>git push origin --all</code> // 将本地所有分支更新推送给各自对应的远端分支。</li>
<li><code>git push origin tag1.0</code> // 将本地标签 <code>tag1.0</code> 更新到远端标签 <code>tag1.0</code>。</li>
<li><code>git push origin --tags</code> // 将本地所有标签更新到对应的远端标签。</li>
<li><code>git push origin :v1.0</code> // 删除远端分支 <code>v1.0</code>。</li>
<li><code>git push origin :refs/tags/tag1.0</code> // 删除远程标签 <code>tag1.0</code>。</li>
<li><code>git push origin -d v1.0</code> // 删除远端分支 <code>v1.0</code> 功能同上。</li>
</ul>
<h2 id="储藏区">储藏区</h2>
<ul>
<li><code>git stash</code> // 将工作区中所有文件的修改备份压栈到储藏区，然后丢弃工作区与暂存区的所有文件的修改。</li>
<li><code>git stash pop</code> // 使用储藏区的栈顶处备份（<code>stash@{0}</code>）来恢复当前分支的工作区，并将栈顶备份移除。</li>
<li><code>git stash apply stash@{1}</code> // 使用储藏区的栈顶下面一个备份（<code>stash@{1}</code>）来恢复当前分支的工作区，但不移除储藏区中任何备份。</li>
<li><code>git stash list</code> // 查看储藏区栈列表。</li>
<li><code>git stash show -p stash@{0}</code> // 查看储藏区的栈顶处备份中各个文件的内容。</li>
<li><code>git stash drop</code> // 直接移除储藏区的栈顶处备份（不用于恢复当前分支的工作区）。</li>
<li><code>git stash clear</code> // 清除储藏区栈列表。</li>
</ul>
<h2 id="工作区">工作区</h2>
<ul>
<li><code>git clean -nd</code> // 探测工作区中哪些文件和目录（未追踪状态）会被删除。</li>
<li><code>git clean -fd</code> // 删除工作区中未追踪状态的文件和目录。</li>
</ul>
<h2 id="暂存区">暂存区</h2>
<ul>
<li><code>git ls-files</code> // 查询暂存区中的文件列表（递归子目录）。</li>
<li><code>git ls-files -s</code> // 查看暂存区中所有文件的 <code>blob</code> 数据块信息。</li>
<li><code>git ls-files -s -- README.md</code> // 查看暂存区中的 <code>README.md</code> 文件的 <code>blob</code> 数据块信息。</li>
</ul>
<h2 id="其他命令">其他命令</h2>
<ul>
<li><code>git fsck --full</code> // 列出所有未引用的 <code>blob</code>、<code>tree</code>、<code>commit</code> 对象。</li>
<li><code>git archive --format zip --output d:/file.zip master</code> // 将当前 <code>master</code> 分支所有文件使用 <code>zip</code> 压缩方式打包到 <code>d:/file.zip</code>。</li>
</ul>
<h1 id="git-瘦身">Git 瘦身</h1>
<ul>
<li><code>git count-objects -v</code> // 查看 <code>git</code> 对象的统计信息。</li>
<li><code>find .git/objects -type f -print0 | xargs -0 du -hk | sort -nr | head -5</code> // 查找 <code>git</code> 库中最大的 <code>5</code> 个文件（<code>du -hk</code> 中的 <code>k</code> 代表单位为 KB）。</li>
<li><code>find .git/objects -type f -size +1M -print0 | xargs -0 du -hm | sort -nr | head -5</code> // 查找 <code>git</code> 库中 <code>size</code> 超过 <code>1M</code> 的最大的 <code>5</code> 个文件（<code>du -hm</code> 中的 <code>k</code> 代表单位为 MB）。</li>
<li><code>git verify-pack -v .git/objects/pack/pack-b340eea7566df839294b71ec91a327ca2ece0b94.idx | sort -k 3 -nr | head -5</code> // 对压缩存储的 <code>git</code> 库查找最大的 <code>5</code> 个文件。</li>
<li><code>git filter-branch --force --index-filter 'git rm --cached --ignore-unmatch FramePro.cpp' --prune-empty --tag-name-filter cat -- --all</code> // 从 <code>git</code> 库的历史记录中彻底清理 <code>FramePro.cpp</code>。</li>
<li><code>git for-each-ref --format='delete %(refname)' refs/original | git update-ref --stdin</code> // 清理所有废弃的 <code>ref</code> 引用。</li>
<li><code>git gc --prune=now</code>
<ol>
<li>将所有的对象压缩存储到 <code>pack</code> 二进制文件中，以节省空间和提高效率。</li>
<li>移除与任何提交都不相关的陈旧对象。</li>
</ol>
</li>
<li><code>git reflog expire --expire=now --all</code> // 清除所有操作记录日志。<br>
除了使用 <code>git</code> 原生命令外，可以使用专门的工具 <code>BFG</code>（<code>Java</code> 实现）来对 <code>Git</code> 库瘦身。</li>
</ul>
<h1 id="经典-gitflow">经典 Gitflow</h1>
<figure data-type="image" tabindex="2"><img src="https://faded.auspicious.space/post-images/1587134458229.png" alt="" loading="lazy"></figure>
<ol>
<li><code>master</code> 分支存储了正式发布的历史（<code>master</code> 分支上的所有提交都会分配一个版本号）。</li>
<li><code>develop</code> 分支作为功能的集成分支。</li>
<li>每个新功能位于一个自己的 <code>Feature</code> 分支，该分支使用 <code>develop</code> 分支作为父分支。当新功能完成时，合并回 <code>develop</code> 分支。新功能提交应该从不直接与 <code>master</code> 分支交互。</li>
<li>一旦 <code>develop</code> 分支上有了做一次发布（或者说快到了既定的发布日）的足够功能，就从 <code>develop</code> 分支上 <code>fork</code> 一个 <code>release</code>分支。<br>
新建的分支用于开始发布循环，所以从这个时间点开始之后新的功能不能再加到这个分支上。 这个分支只应该做 <code>Bug</code> 修复、文档生成和其它面向发布任务。<br>
对外发布的工作完成后，发布分支会合并到 <code>master</code> 分支并分配一个版本号打好 <code>Tag</code>。另外，这些从新建发布分支以来的做的修改要合并回 <code>develop</code> 分支。</li>
<li><code>hotfix</code> 分支用于生成快速给产品发布版本（production releases）打补丁，修复完成，修改应该马上合并回 <code>master</code> 分支（打好 <code>Tag</code>）和 <code>develop</code> 分支（当前的发布分支）。</li>
</ol>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://github.com/bingoHuang/progit2-gitbook">Pro Git 第二版pdf</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2018/10/git-internals.html">Git 原理入门</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html">常用 Git 命令清单</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2014/06/git_remote.html">Git 远程操作详解</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2015/12/git-workflow.html">Git 工作流程</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2015/08/git-use-process.html">Git 使用规范流程</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2012/07/git.html">Git 分支管理策略</a></li>
<li><a href="http://guibin.iteye.com/blog/1014369">GIT 基本概念和用法总结</a></li>
<li><a href="http://blog.jobbole.com/76867/">Git 工作流指南：Gitflow 工作流</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Git——25个进阶技巧]]></title>
        <id>https://faded.auspicious.space/post/git-25-advanced-skills/</id>
        <link href="https://faded.auspicious.space/post/git-25-advanced-skills/">
        </link>
        <updated>2020-04-17T02:54:39.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p><a href="https://linux.cn/article-5418-1.html">25个 Git 进阶技巧</a></p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p><a href="https://linux.cn/article-5418-1.html">25个 Git 进阶技巧</a></p>
</blockquote>
<!-- more -->
<h1 id="基本技巧">基本技巧</h1>
<h2 id="1-安装后的第一步">1. 安装后的第一步</h2>
<p>在安装好 <code>git</code> 后，你第一件该做的事是设置你的名字和电子邮箱，因为每次提交都要用到这些信息：</p>
<pre><code class="language-bash">$ git config --global user.name &quot;Some One&quot;
$ git config --global user.email &quot;someone@gmail.com&quot;
</code></pre>
<h2 id="2-git-是基于指针的">2. Git 是基于指针的</h2>
<p>保存在 <code>git</code> 里的一切都是文件。当你创建一个提交的时候，会建立一个包含你的提交信息和相关数据（名字，邮件地址，日期/时间，前一个提交，等等）的文件，并把它链接到一个树文件中。这个树文件中包含了对象或其他树的列表。这里的提到的对象（或二进制大对象）是和本次提交相关的实际内容（它也是一个文件，另外，尽管文件名并没有包含在对象里，但是存储在树中）。所有这些文件都使用对象的 <code>SHA-1</code> 哈希值作为文件名。</p>
<p>用这种方式，分支和标签就是简单的文件（基本上是这样），包含指向该提交的 <code>SHA-1</code> 哈希值。使用这些索引会带来优秀的灵活性和速度，比如创建一个新分支就是简单地用分支名字和所分出的那个提交的 <code>SHA-1</code> 索引来创建一个文件。当然，你不需要自己做这些，而只要使用 <code>Git</code> 命令行工具（或者 GUI），但是实际上就是这么简单。</p>
<p>你也许听说过叫 <code>HEAD</code> 的索引。这只是简单的一个文件，包含了你当前指向的那个提交的 <code>SHA-1</code> 索引值。如果你正在解决一次合并冲突然后看到了 <code>HEAD</code>，这并不是一个特别的分支或分支上的一个必需的特殊位置，只是标明你当前所在位置。</p>
<p>所有的分支指针都保存在 <code>.git/refs/heads</code> 里，<code>HEAD</code> 在 <code>.git/HEAD</code> 里，而标签保存在 <code>.git/refs/tags</code> 里——自己可以随便进去看看。</p>
<h2 id="3-两个爸爸父节点-你没看错">3. 两个爸爸（父节点） - 你没看错！</h2>
<p>在历史中查看一个合并提交的信息时，你将看到有两个父节点（不同于工作副本上的常规提交的情况）。第一个父节点是你所在的分支，第二个是你合并过来的分支。</p>
<h2 id="4-合并冲突">4. 合并冲突</h2>
<p>目前我相信你碰到过合并冲突并且解决过。通常是编辑一下文件，去掉 <code>&lt;&lt;&lt;&lt;</code>，<code>====</code>，<code>&gt;&gt;&gt;&gt;</code> 标志，保留需要留下的代码。有时能够看到这两个修改之前的代码会很不错，比如，在这两个现在冲突的分支之前的改动。下面是一种方式：</p>
<pre><code class="language-bash">$ git diff --merge
diff --cc dummy.rb  
index 5175dde,0c65895..4a00477  
--- a/dummy.rb
+++ b/dummy.rb
@@@ -1,5 -1,5 +1,5 @@@
  class MyFoo
    def say
-     puts &quot;Bonjour&quot;
 -    puts &quot;Hello world&quot;
++    puts &quot;Annyong Haseyo&quot;
    end
  end
</code></pre>
<p>如果是二进制文件，比较差异就没那么简单了...通常你要做的就是测试这个二进制文件的两个版本来决定保留哪个（或者在二进制文件编辑器里手工复制冲突部分）。从一个特定分支获取文件拷贝（比如说你在合并 <code>master</code> 和 <code>feature123</code> 两个分支）：</p>
<pre><code class="language-bash">$ git checkout master flash/foo.fla # 或者...
$ git checkout feature132 flash/foo.fla
$ # 然后...
$ git add flash/foo.fla
</code></pre>
<p>另一种方式是通过 <code>git</code> 输出文件——你可以输出到另外的文件名，然后当你决定了要用哪个后，再将选定的正确文件复制为正常的文件名：</p>
<pre><code class="language-bash">$ git show master:flash/foo.fla &gt; master-foo.fla
$ git show feature132:flash/foo.fla &gt; feature132-foo.fla
$ # 检出master-foo.fla和feature132-foo.fla
$ # 假如说我们决定来自feature132的文件是正确的
$ rm flash/foo.fla
$ mv feature132-foo.fla flash/foo.fla
$ rm master-foo.fla
$ git add flash/foo.fla
</code></pre>
<p>更新：感谢 Carl 在原博客文章上评论里的提醒，你实际上可以用 <code>git checkout —ours flash/foo.fla</code> 和 <code>git checkout —theirs flash/foo.fla</code> 来检出特定版本的文件，而不用记住你在合并的分支名字。就我个人来说喜欢更精确一点，但这也是一种方式...</p>
<p>记着在解决完冲突后要将文件加入提交（像我上面做的那样）。</p>
<h1 id="服务器分支和标签">服务器，分支和标签</h1>
<h2 id="5-远端服务器">5. 远端服务器</h2>
<p><code>git</code> 的一个超强大的功能就是可以有不止一个远端服务器（实际上你一直都在一个本地仓库上工作）。你并不是一定都要有这些服务器的写权限，你可以有多个可以读取的服务器（用来合并他们的工作）然后写入到另外一个仓库。添加一个新的远端服务器很简单：</p>
<pre><code class="language-bash">$ git remote add john git@github.com:johnsomeone/someproject.git
</code></pre>
<p>如果你想查看远端服务器的信息可以这样做：</p>
<pre><code class="language-bash"># 显示每个远端服务器的URL
$ git remote -v 
# 提供更多详细信息
$ git remote show name 
</code></pre>
<p>你随时都可以查看本地分支和远端分支的差异：</p>
<pre><code class="language-bash">$ git diff master..john/master
</code></pre>
<p>你也可以查看没有在远端分支上的 <code>HEAD</code> 的改动：</p>
<pre><code class="language-bash">$ git log remote/branch..
# 注意：..后面没有结束的特定引用
</code></pre>
<h2 id="6-标签">6. 标签</h2>
<p>在 <code>git</code> 里有两种类型的标签——轻量级标签和带注释标签。记住<a href="#2-git-%E6%98%AF%E5%9F%BA%E4%BA%8E%E6%8C%87%E9%92%88%E7%9A%84">技巧 2</a> 里说过 <code>git</code> 是基于指针的，这两者之间的差异也很简单。轻量级标签只是一个简单的指向一次提交的带名字指针。你随时都可以将它指向另一个提交。带注释标签是一个指向标签对象的带名字指针，带有自己的信息和历史。因为有自己的信息，它可以根据需要用 <code>GPG</code> 签名。</p>
<p>建立这两种类型的标签都很简单（只有一个命令行开关的差异）</p>
<pre><code class="language-bash">$ git tag to-be-tested
$ git tag -a v1.1.0 # 会提示输入标签的信息
</code></pre>
<h2 id="7-建立分支">7. 建立分支</h2>
<p>在 <code>git</code> 里建立分支非常简单（而且像闪电一样快，因为它只需要创建一个小于 100 字节的文件）。用普通方式建立新分支并切换过去：</p>
<pre><code class="language-bash">$ git branch feature132
$ git checkout feature132
</code></pre>
<p>当然，如果你确定自己直接切换到新建的分支，可以用一个命令实现：</p>
<pre><code class="language-bash">$ git checkout -b feature132
</code></pre>
<p>如果你想重命名一个本地分支也很简单（可以显示发生了什么的较长的方式）：</p>
<pre><code class="language-bash">$ git checkout -b twitter-experiment feature132
$ git branch -d feature132
</code></pre>
<p>更新：你也可以（像 Brian Palmer 在原博客文章的评论里提出的）只用 <code>git branch</code> 的 <code>-m</code> 开关在一个命令里实现（像 Mike 提出的，如果你只指定了一个分支参数，就会重命名当前分支）：</p>
<pre><code class="language-bash">$ git branch -m twitter-experiment
$ git branch -m feature132 twitter-experiment
</code></pre>
<h2 id="8-合并分支">8. 合并分支</h2>
<p>也许在将来的某个时候，你希望将改动合并。有两种方式：</p>
<pre><code class="language-bash">$ git checkout master
$ git merge feature83 # 或者...
$ git rebase feature83
</code></pre>
<p><code>merge</code> 和 <code>rebase</code> 之间的差别是 <code>merge</code> 会尝试处理改动并建立一个新的混合了两者的提交。<code>rebase</code> 会尝试把你从一个分支最后一次分离后的所有改动，一个个加到该分支的 <code>HEAD</code> 上。不过，在已经将分支推到远端服务器后不要再 <code>rebase</code> 了 - 这会引起冲突/问题。</p>
<p>如果你不确定在哪些分支上还有独有的工作——所以你也不知道哪些分支需要合并而哪些可以删除，<code>git branch</code> 有两个开关可以帮你：</p>
<pre><code class="language-bash"># 显示已经全部合并到当前分支的分支
$ git branch --merged
# 显示没有合并到当前分支的分支
$ git branch --no-merged
</code></pre>
<h2 id="9-远端分支">9. 远端分支</h2>
<p>如果你在本地有一个分支希望推到远端服务器上，你可以用一行命令推送上去：</p>
<pre><code class="language-bash">$ git push origin twitter-experiment:refs/heads/twitter-experiment
# origin是我们服务器的名字，而twitter-experiment是分支名字
</code></pre>
<p>更新：感谢 Erlend 在原博客文章上的评论——这个实际上和 <code>git push origin twitter-experiment</code> 效果一样，不过使用完整的语法，你可以在两者之间使用不同的分支名（这样本地分支可以是 <code>add-ssl-support</code> 而远端是 issue-1723）。</p>
<p>如果你想在远端服务器上删除一个分支（注意分支名前面的冒号）：</p>
<pre><code class="language-bash">$ git push origin :twitter-experiment
</code></pre>
<p>如果你想查看所有远端分支的状态可以这样做：</p>
<pre><code class="language-bash">$ git remote show origin
</code></pre>
<p>这个命令可能会列出服务器上一些以前有过但现在已经不在了的分支。如果碰到这种情况你可以用下面的命令从你本地分支里清理掉：</p>
<pre><code class="language-bash">$ git remote prune
</code></pre>
<p>最后，如果你想在本地跟踪一个远端分支，普通的方式是：</p>
<pre><code class="language-bash">$ git branch --track myfeature origin/myfeature
$ git checkout myfeature
</code></pre>
<p>不过，新版的 <code>git</code> 在使用 <code>-b</code> 标记检出分支时会自动设定跟踪：</p>
<pre><code class="language-bash">$ git checkout -b myfeature origin/myfeature
</code></pre>
<h1 id="在储藏点索引和文件系统中保存内容">在储藏点，索引和文件系统中保存内容</h1>
<h2 id="10-储藏">10. 储藏</h2>
<p>在 <code>git</code> 里你可以把当前工作状态放进一个储藏堆栈中，然后可以再取出来。最简单的情形是下面这样：</p>
<pre><code class="language-bash">$ git stash
# 做点其他事情...
$ git stash pop
</code></pre>
<p>许多人建议使用 <code>git stash apply</code> 来代替 <code>pop</code>，不过如果这样做的话最后会遗留一个很长的储藏列表。而 <code>pop</code> 会在全部加载后自动从堆栈中移除。如果使用过 <code>git stash apply</code>，你也可以使用下面的命令从堆栈上移除最后一项：</p>
<pre><code class="language-bash">$ git stash drop
</code></pre>
<p><code>git</code> 会基于当前的提交信息自动创建评论。如果你更希望有自定义信息的话（因为它可能和前一个提交没有任何联系）：</p>
<pre><code class="language-bash">$ git stash save &quot;My stash message&quot;
</code></pre>
<p>如果你希望从列表中取出一个特定的储藏点（不一定非得是最后一个）可以先列出它们然后用下面的方式取出：</p>
<pre><code class="language-bash">$ git stash list
  stash@{0}: On master: Changed to German
  stash@{1}: On master: Language is now Italian
$ git stash apply stash@{1}
</code></pre>
<h2 id="11-交互式添加">11. 交互式添加</h2>
<p>在 <code>subversion</code> 的世界里你只能修改文件然后提交所有改动。而在 <code>git</code> 里你有强大得多的方式来提交部分文件或者甚至是部分补丁。提交部分文件或文件中的部分改动你需要进入交互式模式：</p>
<pre><code class="language-bash">$ git add -i
           staged     unstaged path
*** Commands ***
  1: status      2: update   3: revert   4: add untracked
  5: patch      6: diff     7: quit     8: help
What now&gt;  
</code></pre>
<p>这会让你进入一个基于菜单的交互式提示。你可以使用命令中的数字或高亮的字母（如果你在终端里打开了高亮的话）来进入相应的模式。然后就只是输入你希望操作的文件的数字了（你可以使用这样的格式，<code>1</code> 或者 <code>1-4</code> 或 <code>2,4,7</code>）。</p>
<p>如果你想进入补丁模式（交互式模式下按 <code>p</code> 或 <code>5</code>），你也可以直接进入：</p>
<pre><code class="language-bash">$ git add -p    
diff --git a/dummy.rb b/dummy.rb  
index 4a00477..f856fb0 100644  
--- a/dummy.rb
+++ b/dummy.rb
@@ -1,5 +1,5 @@
 class MyFoo
   def say
-    puts &quot;Annyong Haseyo&quot;
+    puts &quot;Guten Tag&quot;
   end
 end
Stage this hunk [y,n,q,a,d,/,e,?]?  
</code></pre>
<p>你可以看到下方会有一些选项供选择用来添加该文件的这个改动、该文件的所有改动，等等。使用 <code>?</code> 命令可以详细解释这些选项。</p>
<h2 id="12-从文件系统里保存取回改动">12. 从文件系统里保存/取回改动</h2>
<p>有些项目（比如 <code>Git</code> 项目本身）在 <code>git</code> 文件系统中直接保存额外文件而并没有将它们加入到版本控制中。<br>
让我们从在 <code>git</code> 中存储一个随机文件开始：</p>
<pre><code class="language-bash">$ echo &quot;Foo&quot; | git hash-object -w --stdin
51fc03a9bb365fae74fd2bf66517b30bf48020cb  
</code></pre>
<p>这样这个目标文件就已经保存到数据库中了，但是如果你没有设定一个指向它的指针的话它会被当做垃圾回收。最简单的方式是设定一个标签：</p>
<pre><code class="language-bash">$ git tag myfile 51fc03a9bb365fae74fd2bf66517b30bf48020cb
</code></pre>
<p>注意这里我们使用了标签 <code>myfile</code>。当我们需要使用这个文件的时候可以这样做：</p>
<pre><code class="language-bash">$ git cat-file blob myfile
</code></pre>
<p>这个对于一些工具文件很有用，开发者可能会用到（密码，<code>GPG</code> 密钥，等等）但是又不希望每次都检出到硬盘（尤其是在实际工作中）。</p>
<h1 id="日志以及有哪些改动">日志以及有哪些改动？</h1>
<h2 id="13-查看日志">13. 查看日志</h2>
<p>长时间使用 <code>Git</code> 的话，不会没用过 <code>git log</code> 来查看最近的提交。不过，有一些技巧来更好地应用。比如，你可以使用下面的命令来查看每次提交的具体改动：</p>
<pre><code class="language-bash">$ git log -p
</code></pre>
<p>或者你可以仅仅查看有哪些文件改动：</p>
<pre><code class="language-bash">$ git log --stat
</code></pre>
<p>有个很不错的别名你可以试试，会显示简短提交名和一个不错的分支图并在一行里显示提交信息（有点像 <code>gitk</code>，但是是在命令行下）：</p>
<pre><code class="language-bash">$ git config --global alias.lol &quot;log --pretty=oneline --abbrev-commit --graph --decorate&quot;
$ git lol
* 4d2409a (master) Oops, meant that to be in Korean
* 169b845 Hello world
</code></pre>
<h2 id="14-搜索日志">14. 搜索日志</h2>
<p>如果你想找特定提交者可以这样做：</p>
<pre><code class="language-bash">$ git log --author=Andy
</code></pre>
<p>更新：感谢 Johannes 的评论，我已经去掉了之前这里的一些有混淆的地方。</p>
<p>或者你想在提交信息里找一些相关字段：</p>
<pre><code class="language-bash">$ git log --grep=&quot;Something in the message&quot;
</code></pre>
<p>也有一个更强大的叫做 <code>pickaxe</code> 的命令用来查找包含了删除或添加的某个特定内容的提交（比如，该内容第一次出现或被删除）。这可以告诉你什么时候增加了一行（但这一行里的某个字符后面被改动过就不行了）：</p>
<pre><code class="language-bash">$ git log -S &quot;TODO: Check for admin status&quot;
</code></pre>
<p>假如你改动了一个特定的文件，比如 <code>lib/foo.rb</code></p>
<pre><code class="language-bash">$ git log lib/foo.rb
</code></pre>
<p>比如说你有一个 <code>feature/132</code> 分支和 <code>feature/145</code> 分支，然后你想看看这两个分支上不在 <code>master</code> 分支里的提交（注意符号 <code>^</code> 是不在的意思）：</p>
<pre><code class="language-bash">$ git log feature/132 feature/145 ^master
</code></pre>
<p>你也可以使用 <code>ActiveSupport</code> 格式的日期来缩小到某个日期范围：</p>
<pre><code class="language-bash">$ git log --since=2.months.ago --until=1.day.ago
</code></pre>
<p>默认情况下会用 <code>OR</code> 来组合查询，但你可以轻易地改为 <code>AND</code>（如果你有超过一条的查询标准）</p>
<pre><code class="language-bash">$ git log --since=2.months.ago --until=1.day.ago --author=andy -S &quot;something&quot; --all-match
</code></pre>
<h2 id="15-查看修改版本">15. 查看/修改版本</h2>
<p>有很多方式可以用来引用一个版本，看你记得哪个：</p>
<pre><code class="language-bash">$ git show 12a86bc38 # 根据版本
$ git show v1.0.1 # 根据标签
$ git show feature132 # 根据分支名
$ git show 12a86bc38^ # 一次提交的父节点
$ git show 12a86bc38~2 # 一次提交的祖父节点
$ git show feature132@{yesterday} # 时间相关
$ git show feature132@{2.hours.ago} # 时间相关
</code></pre>
<p>注意和之前部分有些不同，末尾 <code>^</code> 的意思是该提交的父节点——开始位置 <code>^</code> 的意思是不在这个分支。</p>
<h2 id="16-选择范围">16. 选择范围</h2>
<p>最简单的方式：</p>
<pre><code class="language-bash">$ git log origin/master..new
# [old]..[new] - 所有你还没有推送的提交
</code></pre>
<p>你也可以省略 <code>[new]</code>，将使用当前的 <code>HEAD</code>。</p>
<h1 id="时光回溯和后悔药">时光回溯和后悔药</h1>
<h2 id="17-重置改动">17. 重置改动</h2>
<p>如果你还没有提交的话可以用下面的命令轻松地取消改动：</p>
<pre><code class="language-bash">$ git reset HEAD lib/foo.rb
</code></pre>
<p>通常会使用 <code>unstage</code> 的别名，因为上面的看上去有些不直观。</p>
<pre><code class="language-bash">$ git config --global alias.unstage &quot;reset HEAD&quot;
$ git unstage lib/foo.rb
</code></pre>
<p>如果你已经提交了该文件，你可以做两件事 - 如果是最后一次提交你还可以改正：</p>
<pre><code class="language-bash">$ git commit --amend
</code></pre>
<p>这会取消最后一次提交，把工作分支回退到提交前标记了所有改动的状态，而且提交信息也都准备好可以修改或直接提交。</p>
<p>如果你已经提交过多次而且希望全部回退，你可以将分支重置到合适的位置。</p>
<pre><code class="language-bash">$ git checkout feature132
$ git reset --hard HEAD~2
</code></pre>
<p>如果你实际上希望将分支指向一个完全不同的 <code>SHA1</code>（也许你要将一个分支的 <code>HEAD</code> 替换到另一个分支，或者之后的某次提交）你可以使用下面的较长的方式：</p>
<pre><code class="language-bash">$ git checkout FOO
$ git reset --hard SHA
</code></pre>
<p>实际上有一个快速的方式（不需要先把你的工作分支切换到 <code>FOO</code> 再前进到 <code>SHA</code>）：</p>
<pre><code class="language-bash">$ git update-ref refs/heads/FOO SHA
</code></pre>
<h2 id="18-提交到了错误的分支">18. 提交到了错误的分支</h2>
<p>好吧，假如说你已经提交到了 <code>master</code>，但却应该创建一个叫 <code>experimental</code> 的主题分支更合适。要移动这些改动，你可以在当前位置创建分支，回退 <code>HEAD</code> 再检出新分支：</p>
<pre><code class="language-bash">$ git branch experimental   # 创建一个指向当前master的位置的指针
$ git reset --hard master~3 # 移动master分支的指针到3个版本之前
$ git checkout experimental
</code></pre>
<p>如果你的改动是在分支的分支的分支上会更复杂。那样你需要做的是将分支基础切换到其他地方：</p>
<pre><code class="language-bash">$ git branch newtopic STARTPOINT
$ git rebase oldtopic --onto newtopic
</code></pre>
<h2 id="19-交互式切换基础">19. 交互式切换基础</h2>
<p>这是一个我之前看过展示却没真正理解过的很赞的功能，现在觉得它就很简单了。假如说你提交了3次但是你希望更改顺序或编辑（或者合并）：</p>
<pre><code class="language-bash">$ git rebase -i master~3
</code></pre>
<p>然后这会启动你的编辑器并带有一些指令。你所要做的就是修改这些指令来选择/插入/编辑（或者删除）提交和保存/退出。然后在编辑完后你可以用 <code>git rebase --continue</code> 命令来让每一条指令生效。</p>
<p>如果你有修改，将会切换到你提交时所处的状态，之后你需要使用命令 <code>git commit --amend</code> 来编辑。</p>
<table>
<thead>
<tr>
<th>注意：在 <code>rebase</code> 的时候千万不要提交 - 只能先添加然后使用参数 <code>--continue</code>，<code>--skip</code> 或 <code>--abort</code>。</th>
</tr>
</thead>
<tbody></tbody>
</table>
<h2 id="20-清理">20. 清理</h2>
<p>如果你提交了一些内容到你的分支（也许你从 <code>SVN</code> 导入了一些旧仓库），然后你希望把某个文件从历史记录中全部删掉：</p>
<pre><code class="language-bash">$ git filter-branch --tree-filter 'rm -f *.class' HEAD
</code></pre>
<p>如果你已经推送到 <code>origin</code> 了，但之后提交了一些垃圾改动，你也可以在推送前在本地系统里这样做：</p>
<pre><code class="language-bash">$ git filter-branch --tree-filter 'rm -f *.class' origin/master..HEAD
</code></pre>
<h1 id="其他技巧">其他技巧</h1>
<h2 id="21-你查看过的前一个引用">21. 你查看过的前一个引用</h2>
<p>如果你知道自己之前查看过一个 <code>SHA-1</code>，但是随后做了一些重置/回退的操作，你可以使用 <code>reflog</code> 命令来列出最近查看过的 <code>SHA-1</code> 记录：</p>
<pre><code class="language-bash">$ git reflog
$ git log -g # 和上面一样，但是使用'log'格式输出
</code></pre>
<h2 id="22-分支命名">22. 分支命名</h2>
<p>一个可爱的小技巧 - 别忘了分支名并不限于 <code>a-z</code> 和 <code>0-9</code>。名字中可以用/和.将非常方便用来建立伪命名空间或版本，例如：</p>
<pre><code class="language-bash">$ # 生成版本132的改动历史
$ git shortlog release/132 ^release/131
$ # 贴上v1.0.1的标签
$ git tag v1.0.1 release/132
</code></pre>
<h2 id="23-找出谁是凶手">23. 找出谁是凶手</h2>
<p>通常找出来谁改动了某个文件里的某行代码会很有用。实现这个功能的最简单命令是：</p>
<pre><code class="language-bash">$ git blame FILE
</code></pre>
<p>有时候这些改动来自其他文件（如果你合并了两个文件，或者你移动了某个函数）所以你可以使用下面的命令：</p>
<pre><code class="language-bash">$ # 显示内容来自哪个文件
$ git blame -C FILE
</code></pre>
<p>有时候通过点击各个改动然后回到很早很早以前来跟踪改动会很不错。有一个很好的内建 GUI 命令来做这个：</p>
<pre><code class="language-bash">$ git gui blame FILE
</code></pre>
<h2 id="24-数据维护">24. 数据维护</h2>
<p>通常 <code>git</code> 不需要经常维护，它把自己照顾的很好。不过，你可以通过下面的命令查看数据统计：</p>
<pre><code class="language-bash">$ git count-objects -v
</code></pre>
<p>如果占用很多空间的话，你可以选择在你的本地仓库做垃圾回收。这不会影响推送或其他人，却会让一些命令运行更快而且减少空间占用：</p>
<pre><code class="language-bash">$ git gc
</code></pre>
<p>经常运行完整性检查也很有意义：</p>
<pre><code class="language-bash">$ git fsck --full
</code></pre>
<p>你也可以在末尾加上 <code>--auto</code> 参数（如果你在服务器上通过 <code>crontab</code> 经常/每天都运行这个命令的话），然后它只会在必要的时候才执行 fsck` 动作。</p>
<p>在检查的时候，看到 <code>dangling</code> 或 <code>unreachable</code> 是正常的，通常这是由回退 <code>HEAD</code> 或切换基础的结果。而看到 <code>missing</code> 或 <code>sha1 mismatch</code> 就不对了...找专业人士帮忙吧！</p>
<h2 id="25-恢复遗失的分支">25. 恢复遗失的分支</h2>
<p>如果你使用 <code>-D</code> 参数删除了 <code>experimental</code> 分支，可以用下面的命令重新建立：</p>
<pre><code class="language-bash">$ git branch experimental SHA1_OF_HASH
</code></pre>
<p>如果你最近访问过的话，你通常可以用 <code>git reflog</code> 来找到 <code>SHA1</code> 哈希值。</p>
<p>另一种方式是使用 <code>git fsck —lost-found</code>。其中一个 <code>dangling</code> 的提交就是丢失的 <code>HEAD</code>（它只是已删除分支的 <code>HEAD</code>，而 <code>HEAD</code> 被引用为当前的 <code>HEAD</code> 所以它并不处于 <code>dangling</code> 状态）。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Git——4 个阶段的撤销更改]]></title>
        <id>https://faded.auspicious.space/post/git-four-stages-of-reset/</id>
        <link href="https://faded.auspicious.space/post/git-four-stages-of-reset/">
        </link>
        <updated>2020-04-17T02:20:22.000Z</updated>
        <summary type="html"><![CDATA[<p>错误修改了代码不要紧，这里教你如何恢复以前的正确代码。</p>
]]></summary>
        <content type="html"><![CDATA[<p>错误修改了代码不要紧，这里教你如何恢复以前的正确代码。</p>
<!-- more -->
<blockquote>
<p><a href="https://www.fengerzh.com/git-reset/">Git的4个阶段的撤销更改</a></p>
</blockquote>
<figure data-type="image" tabindex="1"><img src="https://faded.auspicious.space/post-images/1587090203607.png" alt="" loading="lazy"></figure>
<p>虽然 <code>git</code> 诞生距今已有 12 年之久，网上各种关于 <code>git</code> 的介绍文章数不胜数，但是依然有很多人（包括我自己在内）对于它的功能不能完全掌握。以下的介绍只是基于我个人对于 <code>git</code> 的理解，并且可能生编硬造了一些不完全符合 <code>git</code> 说法的词语。目的只是为了让 <code>git</code> 通俗化，使初学者也能大概了解如何快速上手 <code>git</code>。同时，下面所有讨论，我们都假设只使用一个分支，也就是主分支 <code>master</code> 的情况，虽然这种作法并不符合 <code>git</code> 规范，但是现实情况中绝大部分用户是直接在 <code>master</code> 分支上进行工作的，所以在这里我们不去引入更加复杂的各种分支的情况，也不涉及标签 <code>tag</code> 的操作，只讲在最简单的主分支上如何回退。</p>
<h1 id="基本概念">基本概念</h1>
<h2 id="3-个步骤">3 个步骤</h2>
<p><img src="https://faded.auspicious.space/post-images/1587090327591.png" alt="" loading="lazy"><br>
正常情况下，我们的工作流就是 3 个步骤，对应上图中的 3 个箭头线：</p>
<pre><code class="language-bash">git add .
git commit -m &quot;comment&quot;
git push
</code></pre>
<ol>
<li><code>git add .</code> 把所有文件放入暂存区；</li>
<li><code>git commit</code> 把所有文件从暂存区提交进本地仓库；</li>
<li><code>git push</code> 把所有文件从本地仓库推送进远程仓库。</li>
</ol>
<h2 id="4-个区">4 个区</h2>
<p><code>git</code> 之所以令人费解，主要是它相比于 <code>svn</code> 等等传统的版本管理工具，多引入了一个暂存区（Stage）的概念，就因为多了这一个概念，而使很多人疑惑。其实，在初学者来说，每个区具体怎么工作的，我们完全不需要关心，而只要知道有这么 4 个区就够了：</p>
<ul>
<li>工作区（Working Area）</li>
<li>暂存区（Stage）</li>
<li>本地仓库（Local Repository）</li>
<li>远程仓库（Remote Repository）</li>
</ul>
<h2 id="5-种状态">5 种状态</h2>
<p>以上 4 个区，进入每一个区成功之后会产生一个状态，再加上最初始的一个状态，一共是 5 种状态。以下我们把这 5 种状态分别命名为：</p>
<ul>
<li>未修改（Origin）</li>
<li>已修改（Modified）</li>
<li>已暂存（Staged）</li>
<li>已提交（Committed）</li>
<li>已推送（Pushed）</li>
</ul>
<h1 id="检查修改">检查修改</h1>
<p>了解了基本概念之后，我们来谈一谈犯错误之后如何撤销的问题。首先，我们要了解如何检查这 3 个步骤当中每一个步骤修改了什么，然后才好判断有没有修改成功。检查修改的二级命令都相同，都是 <code>diff</code>，只是参数有所不同。</p>
<h2 id="已修改未暂存">已修改，未暂存</h2>
<pre><code class="language-bash">git diff
</code></pre>
<p>首先，我们来看一下，如果我们只是简单地在浏览器里保存了一下文件，但是还没有做 <code>git add .</code> 之前，我们如何检查有哪些修改。我们先随便拿一个文件来做一下实验：<br>
<img src="https://faded.auspicious.space/post-images/1587090638955.png" alt="" loading="lazy"><br>
我们在文件开头的第 2 行胡乱加了 4 个数字 <code>1234</code>，存盘，这时文件进入了<strong>已修改</strong>状态，但是还没有进入<strong>暂存区</strong>，我们运行 <code>git diff</code>，结果如下：</p>
<pre><code class="language-bash">diff --git a/index.md b/index.md
index 73ff1ba..1066758 100644
--- a/index.md
+++ b/index.md
@@ -1,5 +1,5 @@
 ---
-layout: main
+1234layout: main
 color: black
 ---
</code></pre>
<p><code>git diff</code> 的结果告诉我们哪些文件已经做了哪些修改。</p>
<h2 id="已暂存未提交">已暂存，未提交</h2>
<pre><code class="language-bash">git diff --cached
</code></pre>
<p>现在我们把修改放入<strong>暂存区</strong>看一下。先执行 <code>git add .</code>，然后执行 <code>git diff</code>，你会发现没有任何结果：<br>
<img src="https://faded.auspicious.space/post-images/1587090841347.png" alt="" loading="lazy"><br>
这说明 <code>git diff</code> 这个命令只检查我们的<strong>工作区</strong>和<strong>暂存区</strong>之间的差异，如果我们想看到<strong>暂存区</strong>和<strong>本地仓库</strong>之间的差异，就需要加一个参数 <code>git diff --cached</code>：</p>
<pre><code class="language-bash">diff --git a/index.md b/index.md
index 73ff1ba..1066758 100644
--- a/index.md
+++ b/index.md
@@ -1,5 +1,5 @@
 ---
-layout: main
+1234layout: main
 color: black
 ---
</code></pre>
<p>这时候我们看到的差异是<strong>暂存区</strong>和<strong>本地仓库</strong>之间的差异。</p>
<h2 id="已提交未推送">已提交，未推送</h2>
<pre><code class="language-bash">git diff master origin/master
</code></pre>
<p>现在，我们把修改从<strong>暂存区</strong>提交到<strong>本地仓库</strong>，再看一下差异。先执行 <code>git commit</code>，然后再执行 <code>git diff --cached</code>，没有差异，执行 <code>git diff master origin/master</code>，可以看到差异：<br>
<img src="https://faded.auspicious.space/post-images/1587091065745.png" alt="" loading="lazy"><br>
在这里，<code>master</code> 就是你的本地仓库，而 <code>origin/master</code> 就是你的远程仓库，<code>master</code> 是主分支的意思，因为我们都在主分支上工作，所以这里两边都是 <code>master</code>，而 <code>origin</code> 就代表远程。</p>
<h1 id="撤销修改">撤销修改</h1>
<p>了解清楚如何检查各种修改之后，我们开始尝试各种撤销操作。</p>
<h2 id="恢复已修改未暂存">恢复已修改，未暂存</h2>
<p>如果我们只是在编辑器里修改了文件，但还没有执行 <code>git add .</code>，这时候我们的文件还在<strong>工作区</strong>，并没有进入<strong>暂存区</strong>，我们可以用：</p>
<pre><code class="language-bash">git checkout .
</code></pre>
<p>或者</p>
<pre><code class="language-bash">git reset --hard
</code></pre>
<p>来进行撤销操作。<br>
<img src="https://faded.auspicious.space/post-images/1587091296924.png" alt="" loading="lazy"><br>
可以看到，在执行完 <code>git checkout .</code> 之后，修改已被撤销，<code>git diff</code> 没有任何内容了。</p>
<table>
<thead>
<tr>
<th>一对反义词 &gt; <code>git add .</code> 的反义词是 <code>git checkout .</code>。做完修改之后，如果你想向前走一步，让修改进入暂存区，就执行 <code>git add .</code>，如果你想向后退一步，撤销刚才的修改，就执行 <code>git checkout .</code>。</th>
</tr>
</thead>
<tbody></tbody>
</table>
<h2 id="恢复已暂存未提交">恢复已暂存，未提交</h2>
<p>你已经执行了 <code>git add .</code>，但还没有执行 <code>git commit -m &quot;comment&quot;</code>。这时候你意识到了错误，想要撤销，你可以执行：</p>
<pre><code class="language-bash">git reset
git checkout .
</code></pre>
<p>或者</p>
<pre><code class="language-bash">git reset --hard
</code></pre>
<p><code>git reset</code> 只是把修改退回到了 <code>git add .</code> 之前的状态，也就是说文件本身还处于<strong>已修改未暂存</strong>状态，你如果想退回<strong>未修改</strong>状态，还需要执行 <code>git checkout .</code>。</p>
<p>或许你已经注意到了，以上两个步骤都可以用同一个命令 <code>git reset --hard</code> 来完成。是的，就是这个强大的命令，可以一步到位地把你的修改完全恢复到<strong>未修改</strong>的状态。</p>
<h2 id="恢复已提交未推送">恢复已提交，未推送</h2>
<p>你的手太快，你既执行了 <code>git add .</code>，又执行了 <code>git commit</code>，这时候你的代码已经进入了你的<strong>本地仓库</strong>，然而你后悔了，怎么办？不要着急，还有办法。</p>
<pre><code class="language-bash">git reset --hard origin/master
</code></pre>
<p>还是这个 <code>git reset --hard</code> 命令，只不过这次多了一个参数 <code>origin/master</code>，正如我们上面讲过的，<code>origin/master</code> 代表<strong>远程仓库</strong>，既然你已经污染了你的<strong>本地仓库</strong>，那么就从<strong>远程仓库</strong>把代码取回来吧。</p>
<h2 id="已推送">已推送</h2>
<p>很不幸，你的手实在是太快了，你既 <code>git add</code> 了，又 <code>git commit</code> 了，并且还 <code>git push</code> 了，这时你的代码已经进入<strong>远程仓库</strong>。如果你想恢复的话，还好，由于你的<strong>本地仓库</strong>和<strong>远程仓库</strong>是等价的，你只需要先恢复<strong>本地仓库</strong>，再强制 <code>push</code> 到<strong>远程仓库</strong>就好了：</p>
<pre><code class="language-bash">git reset --hard HEAD^
git push -f
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://faded.auspicious.space/post-images/1587091677820.png" alt="" loading="lazy"></figure>
<h1 id="总结">总结</h1>
<p>以上 4 种状态的撤销我们都用到了同一个命令 <code>git reset --hard</code>，前 2 种状态的用法甚至完全一样，所以只要掌握了 <code>git reset --hard</code> 这个命令的用法，从此你再也不用担心提交错误了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JavaScript——发现闭包的强大威力]]></title>
        <id>https://faded.auspicious.space/post/javascript-discover-the-power-of-closures/</id>
        <link href="https://faded.auspicious.space/post/javascript-discover-the-power-of-closures/">
        </link>
        <updated>2020-04-15T04:57:02.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p><a href="https://juejin.im/post/5c4e6a90e51d4552266576d2">[译]发现 JavaScript 中闭包的强大威力</a></p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p><a href="https://juejin.im/post/5c4e6a90e51d4552266576d2">[译]发现 JavaScript 中闭包的强大威力</a></p>
</blockquote>
<!-- more -->
<p>闭包是一个可以访问外部作用域的内部函数，即使这个外部作用域已经执行结束。</p>
<h1 id="1-作用域">1 作用域</h1>
<p>作用域决定这个变量的生命周期及其可见性。 当我们创建了一个函数或者 <code>{}</code> 块，就会生成一个新的作用域。需要注意的是，通过 <code>var</code> 创建的变量只有函数作用域，而通过 <code>let</code> 和 <code>const</code> 创建的变量既有函数作用域，也有块作用域。</p>
<h1 id="2-嵌套作用域">2 嵌套作用域</h1>
<p>在 JavasScript 中函数里面可以嵌套函数，如下：</p>
<pre><code class="language-javascript">(function autorun(){
    let x = 1;
    function log(){ 
       console.log(x); 
    }
    log();
})();
</code></pre>
<p><code>log()</code> 即是一个嵌套在 <code>autorun()</code> 函数里面的函数。在 <code>log()</code> 函数里面可以通过外部函数访问到变量 <code>x</code>。此时，<code>log()</code> 函数就是一个闭包。</p>
<p>闭包就是内部函数，我们可以通过在一个函数内部或者 <code>{}</code> 块里面定义一个函数来创建闭包。</p>
<h2 id="21-外部函数作用域">2.1 外部函数作用域</h2>
<p>内部函数可以访问外部函数中定义的变量，即使外部函数已经执行完毕。如下：</p>
<pre><code class="language-javascript">(function autorun(){
    let x = 1;
    setTimeout(function log(){
      console.log(x);
    }, 10000);
})();
</code></pre>
<p>并且，内部函数还可以访问外部函数中定义的形参，如下：</p>
<pre><code class="language-javascript">(function autorun(p){
    let x = 1;
    setTimeout(function log(){
      console.log(x);//1
      console.log(p);//10
    }, 10000);
})(10);
</code></pre>
<h2 id="22-外部块作用域">2.2 外部块作用域</h2>
<p>内部函数可以访问外部块中定义的变量，即使外部块已执行完毕，如下：</p>
<pre><code class="language-javascript">{
    let x = 1;
    setTimeout(function log(){
      console.log(x);
    }, 10000);
}
</code></pre>
<h1 id="3-词法作用域">3 词法作用域</h1>
<p>词法作用域是指内部函数在定义的时候就决定了其外部作用域。</p>
<p>看如下代码：</p>
<pre><code class="language-javascript">(function autorun(){
    let x = 1;
    function log(){
      console.log(x);
    };
    
    function run(fn){
      let x = 100;
      fn();
    }
    
    run(log);//1
})();
</code></pre>
<p><code>log()</code> 函数是一个闭包，它在这里访问的是 <code>autorun()</code> 函数中的 <code>x</code> 变量，而不是 <code>run</code> 函数中的变量。</p>
<p>❗️<strong>闭包的外部作用域是在其定义的时候已决定，而不是执行的时候。</strong></p>
<p><code>autorun()</code> 的函数作用域即是 <code>log()</code> 函数的词法作用域。</p>
<h1 id="4-作用域链">4 作用域链</h1>
<p>每一个作用域都有对其父作用域的引用。当我们使用一个变量的时候，JavaScript 引擎 会通过变量名在当前作用域查找，若没有查找到，会一直沿着作用域链一直向上查找，直到 <code>global</code> 全局作用域。</p>
<p>示例如下：</p>
<pre><code class="language-javascript">let x0 = 0;
(function autorun1(){
 let x1 = 1;
  
 (function autorun2(){
   let x2 = 2;
  
   (function autorun3(){
     let x3 = 3;
      
     console.log(x0 + &quot; &quot; + x1 + &quot; &quot; + x2 + &quot; &quot; + x3);//0 1 2 3
    })();
  })();
})();
</code></pre>
<p>我们可以看到，<code>autorun3()</code> 这个内部函数可以访问其自身局部变量 <code>x3</code> ，也可以访问外部作用域中的 <code>x1</code> 和 <code>x2</code> 变量，以及全局作用域中的 <code>x0</code> 变量。即：闭包可以访问其外部（父）作用域中的定义的所有变量。</p>
<h2 id="41-外部作用域执行完毕后">4.1 外部作用域执行完毕后</h2>
<p>当外部作用域执行完毕后，内部函数还存活（仍在其他地方被引用）时，闭包才真正发挥其作用。譬如以下几种情况：</p>
<ul>
<li>在异步任务例如 <code>timer</code> 定时器，事件处理，<code>Ajax</code> 请求中被作为回调。</li>
<li>被外部函数作为返回结果返回，或者返回结果对象中引用该内部函数。</li>
</ul>
<p>考虑如下的几个示例：</p>
<h3 id="411-timer">4.1.1 Timer</h3>
<pre><code class="language-javascript">(function autorun(){
    let x = 1;
    setTimeout(function log(){
      console.log(x);
    }, 10000);
})();
</code></pre>
<p>变量 <code>x</code> 将一直存活着直到定时器的回调执行或者 <code>clearTimeout()</code> 被调用。<br>
如果这里使用的是 <code>setInterval()</code>，那么变量 <code>x</code> 将一直存活到 <code>clearInterval()</code> 被调用。</p>
<p><em>译者注：原文中说变量 <code>x</code> 一直存活到 <code>setTimeout()</code> 或者 <code>setInterval()</code> 被调用是错误的。</em></p>
<h3 id="412-event">4.1.2 Event</h3>
<pre><code class="language-javascript">(function autorun(){
    let x = 1;
    $(&quot;#btn&quot;).on(&quot;click&quot;, function log(){
      console.log(x);
    });
})();
</code></pre>
<p>当变量 <code>x</code> 在事件处理函数中被使用时，它将一直存活直到该事件处理函数被移除。</p>
<h3 id="413-ajax">4.1.3 Ajax</h3>
<pre><code class="language-javascript">(function autorun(){
    let x = 1;
    fetch(&quot;http://&quot;).then(function log(){
      console.log(x);
    });
})();
</code></pre>
<p>变量 <code>x</code> 将一直存活到接收到后端返回结果，回调函数被执行。</p>
<p>在已上几个示例中，我们可以看到，<code>log()</code> 函数在父函数执行完毕后还一直存活着，<code>log()</code> 函数就是一个闭包。</p>
<p>除了 <code>timer</code> 定时器，事件处理，<code>Ajax</code> 请求等比较常见的异步任务，还有其他的一些异步 API 比如 <code>HTML5 Geolocation</code>，<code>WebSockets</code>，<code>requestAnimationFrame()</code> 也将使用到闭包的这一特性。</p>
<p>变量的生命周期取决于闭包的生命周期。被闭包引用的外部作用域中的变量将一直存活直到闭包函数被销毁。如果一个变量被多个闭包所引用，那么直到所有的闭包被垃圾回收后，该变量才会被销毁。</p>
<h1 id="5-闭包与循环">5 闭包与循环</h1>
<p>闭包只存储外部变量的引用，而不会拷贝这些外部变量的值。 查看如下示例：</p>
<pre><code class="language-javascript">function initEvents(){
  for(var i=1; i&lt;=3; i++){
    $(&quot;#btn&quot; + i).click(function showNumber(){
      alert(i);//4
    });
  }
}
initEvents();
</code></pre>
<p>在这个示例中，我们创建了 3 个闭包，皆引用了同一个变量 <code>i</code>，且这三个闭包都是事件处理函数。由于变量 <code>i</code> 随着循环自增，因此最终输出的都是同样的值。</p>
<p>修复这个问题最简单的方法是在 <code>for</code> 语句块中使用 <code>let</code> 变量声明，这将在每次循环中为 <code>for</code> 语句块创建一个新的局部变量。如下：</p>
<pre><code class="language-javascript">function initEvents(){
  for(let i=1; i&lt;=3; i++){
    $(&quot;#btn&quot; + i).click(function showNumber(){
      alert(i); // 1 2 3
    });
  }
}
initEvents();
</code></pre>
<p>但是，如果变量声明在 <code>for</code> 语句块之外的话，即使用了 <code>let</code> 变量声明，所有的闭包还是会引用同一个变量，最终输出的还是同一个值。</p>
<h1 id="6-闭包与封装性">6 闭包与封装性</h1>
<p>封装性意味着信息隐藏。</p>
<h2 id="61-函数与私有状态">6.1 函数与私有状态</h2>
<p>通过闭包，我们可以创建拥有私有状态的函数，闭包使得状态被封装起来。</p>
<h2 id="62-工厂模式与私有原型对象">6.2 工厂模式与私有原型对象</h2>
<p>我们先来看一个通过原型创建对象的常规方式，如下：</p>
<pre><code class="language-javascript">let todoPrototype = {
  toString : function() {
    return this.id + &quot; &quot; + this.userName + &quot;: &quot; + this.title;
  }
}
function Todo(todo){
  let newTodo = Object.create(todoPrototype);
  Object.assign(newTodo, todo);
  return newTodo;
}
</code></pre>
<p>在这个例子中，<code>todoPrototype</code> 原型对象是一个全局对象。</p>
<p>我们可以通过闭包，只用创建原型对象一次，也能够被所有 <code>Todo</code> 函数调用所公用，并且保证其私有性。示例如下：</p>
<pre><code class="language-javascript">let Todo = (function createTodoFactory(){
  let todoPrototype = {
    toString : function() {
      return this.id + &quot; &quot; + this.userName + &quot;: &quot; + this.title;
    }
  }
  return function(todo){
    let newTodo = Object.create(todoPrototype);
    Object.assign(newTodo, todo);
    return newTodo;
  }
})();
let todo = Todo({id : 1, title: &quot;This is a title&quot;, userName: &quot;Cristi&quot;, completed: false });
</code></pre>
<p>这里，<code>Todo()</code> 就是一个拥有私有状态的函数。</p>
<h2 id="63-工厂模式与私有构造函数">6.3 工厂模式与私有构造函数</h2>
<p>查看如下代码：</p>
<pre><code class="language-javascript">let Todo = (function createTodoFactory(){
 function Todo(spec){
   Object.assign(this, spec);
 }
 
 return function(spec){
   let todo = new Todo(spec);
   return Object.freeze(todo);
 }
})();
</code></pre>
<p>这里，<code>Todo()</code> 工厂函数就是一个闭包。通过它，不管是否使用 <code>new</code>，我们都可以创建不可变对象，原型对象也只用创建一次，并且它是私有的。</p>
<pre><code class="language-javascript">let todo = Todo({title : &quot;A description&quot;});
todo.title = &quot;Another description&quot;; 
// Cannot assign to read only property 'title' of object
todo.toString = function() {};
//Cannot assign to read only property 'toString' of object
</code></pre>
<p>而且，在内存快照中，我们可以通过构造函数名来识别这些示例对象。<br>
<img src="https://faded.auspicious.space/post-images/1586954287441.png" alt="" loading="lazy"></p>
<h2 id="64-翻译功能与私有-map">6.4 翻译功能与私有 map</h2>
<p>通过闭包，我们可以创建一个 <code>map</code>，在所有翻译调用中被使用，且是私有的。</p>
<p>示例如下：</p>
<pre><code class="language-javascript">let translate = (function(){
  let translations = {};
  translations[&quot;yes&quot;] = &quot;oui&quot;;
  translations[&quot;no&quot;]  = &quot;non&quot;;
  
  return function(key){
    return translations[key];
  }
})();
translate(&quot;yes&quot;); //oui
</code></pre>
<h2 id="65-自增生成器函数">6.5 自增生成器函数</h2>
<p>通过闭包，我们可以创建自增生成器函数。同样，内部状态是私有的。示例如下：</p>
<pre><code class="language-javascript">function createAGenerate(count, increment) {
  return function(){
    count += increment;
    return count;
  }
}
let generateNextNumber = createAGenerate(0, 1);
console.log(generateNextNumber()); //1
console.log(generateNextNumber()); //2
console.log(generateNextNumber()); //3
let generateMultipleOfTen = createAGenerate(0, 10);
console.log(generateMultipleOfTen()); //10
console.log(generateMultipleOfTen()); //20
console.log(generateMultipleOfTen()); //30
</code></pre>
<p><em>译者注：原文中依次输出0,1,2,0,10,20是有误的，感谢@Round的指正</em></p>
<h2 id="66-对象与私有状态">6.6 对象与私有状态</h2>
<p>以上示例中，我们可以创建一个拥有私有状态的函数。同时，我们也可以创建多个拥有同一私有状态的函数。基于此，我们还可以创建一个拥有私有状态的对象。</p>
<p>示例如下：</p>
<pre><code class="language-javascript">function TodoStore(){
  let todos = [];
  
  function add(todo){
    todos.push(todo);
  }
  function get(){
    return todos.filter(isPriorityTodo).map(toTodoViewModel);
  }
  
  function isPriorityTodo(todo){
     return task.type === &quot;RE&quot; &amp;&amp; !task.completed;
  }
  
  function toTodoViewModel(todo) {
     return { id : todo.id, title : todo.title };
  }
  
  return Object.freeze({
    add,
    get
  });
}
</code></pre>
<p><code>TodoStore()</code> 函数返回了一个拥有私有状态的对象。在外部，我们无法访问私有的 <code>todos</code> 变量，并且 <code>add</code> 和 <code>get</code> 这两个闭包拥有相同的私有状态。在这里，<code>TodoStore()</code> 是一个工厂函数。</p>
<h2 id="67-闭包-vs-纯函数">6.7 闭包 vs 纯函数</h2>
<p>闭包就是那些引用了外部作用域中变量的函数。</p>
<p>为了更好的理解，我们将内部函数拆成闭包和纯函数两个方面：</p>
<ul>
<li>闭包是那些引用了外部作用域中变量的函数。</li>
<li>纯函数是那些没有引用外部作用域中变量的函数，它们通常返回一个值并且没有副作用。</li>
</ul>
<p>在上述例子中，<code>add()</code> 和 <code>get()</code> 函数是闭包，而 <code>isPriorityTodo()</code> 和 <code>toTodoViewModel()</code> 则是纯函数。</p>
<h1 id="7-闭包在函数式编程中的应用">7 闭包在函数式编程中的应用</h1>
<p>闭包在函数式编程中也应用广泛。譬如，<code>underscore</code> 源码中 <a href="https://underscorejs.org/#functions">函数相关小节</a> 中的所有函数都利用了闭包这一特性。</p>
<blockquote>
<p>A function decorator is a higher-order function that takes one function as an argument and returns another function, and the returned function is a variation of the argument function — <a href="https://leanpub.com/javascript-allonge/read#decorators">Javascript Allongé</a></p>
</blockquote>
<p>装饰器函数也使用了闭包的特性。</p>
<p>我们来看如下 <code>not</code> 这个简单的装饰器函数：</p>
<pre><code class="language-javascript">function not(fn){
  return function decorator(...args){
    return !fn.apply(this, args);
  }
}
</code></pre>
<p><code>decorator()</code> 函数引用了外部作用域的 <code>fn</code> 变量，因此它是一个闭包。</p>
<p>如果你想知道更多关于装饰器相关的知识，可以查看<a href="https://www.freecodecamp.org/news/here-are-a-few-function-decorators-you-can-write-from-scratch-488549fe8f86/">这篇文章</a>。</p>
<h1 id="8-垃圾回收">8 垃圾回收</h1>
<p>在 JavaScript 中，局部变量会随着函数的执行完毕而被销毁，除非还有指向他们的引用。当闭包本身也被垃圾回收之后，这些闭包中的私有状态随后也会被垃圾回收。通常我们可以通过切断闭包的引用来达到这一目的。</p>
<p>在这个例子中，我们首先创建了一个 <code>add()</code> 闭包。</p>
<pre><code class="language-javascript">let add = (function createAddClosure(){
    let arr = [];
    return function(obj){
       arr.push(obj);
    }
})();
</code></pre>
<p>随后，我们又定义了两个函数：</p>
<ul>
<li><code>addALotOfObjects()</code> 往闭包变量 <code>arr</code> 中加入对象。</li>
<li><code>clearAllObjects()</code> 将闭包函数置为 <code>null</code> 。</li>
</ul>
<p>并且两个函数皆作为事件处理函数：</p>
<pre><code class="language-javascript">function addALotOfObjects(){
    for(let i=1; i&lt;=10000;i++) {
       add(new Todo(i));
    }
}
function clearAllObjects(){
    if(add){
       add = null;
    }
}
$(&quot;#add&quot;).click(addALotOfObjects);
$(&quot;#clear&quot;).click(clearAllObjects);
</code></pre>
<p>当我点击 <code>Add</code> 按钮时，将往闭包变量 <code>arr</code> 中加入 10000 个 <code>todo</code> 对象，内存快照如下：<br>
<img src="https://faded.auspicious.space/post-images/1586954839826.png" alt="" loading="lazy"><br>
当我点击 <code>Clear</code> 按钮时，我们将闭包引用置为 <code>null</code>。随后，闭包变量 <code>arr</code> 将被垃圾回收，内存快照如下：<br>
<img src="https://faded.auspicious.space/post-images/1586954881968.png" alt="" loading="lazy"></p>
<h1 id="9-避免全局变量">9 避免全局变量</h1>
<p>在 JavaScript 中，我们很容易创建出全局变量。任何定义在函数和 <code>{}</code> 块之外的变量都是全局的，定义在全局作用域中的函数也是全局的。</p>
<p>这里以定义创建不同对象的工厂函数为例。为了避免将所有的工厂函数都放在全局作用域下，最简单的方法就是将他们挂在 <code>app</code> 全局变量下。</p>
<p>示例如下：</p>
<pre><code class="language-javascript">let app = Loader();
app.factory(function DataService(args){ return {}});
app.factory(function Helper(args){ return {}});
app.factory(function Mapper(args){ return {}});
app.factory(function Model(args){});
</code></pre>
<p><code>app.factory()</code> 方法还可以将不同的工厂函数归类到不同的模块中。下面这个示例就是将 <code>Timer</code> 工厂函数归类到 <code>tools</code> 模块下。</p>
<pre><code class="language-javascript">app.factory(&quot;tools&quot;)(function Timer(args){ return {}});
</code></pre>
<p>我们可以在 <code>app</code> 对象上暴露一个 <code>start</code> 方法来作为应用的入口点，通过回调函数中 <code>factories</code> 参数来访问这些工厂函数。这里 <code>start()</code> 函数只能被调用一次，如下：</p>
<pre><code class="language-javascript">app.start(function startApplication(factories){
  let helper = factories.Helper();
  
  let dataService = factories.DataService();
  let model = factories.Model({
      dataService : dataService,
      helper : helper,
      timer : factories.tools.Timer()
  });
});
</code></pre>
<blockquote>
<p>A Composition Root is a (preferably) unique location in an application where modules are composed together—Mark Seemann</p>
</blockquote>
<h2 id="91-loader-对象">9.1 loader 对象</h2>
<p>让我们来将 <code>app</code> 完善为一个 <code>loader</code> 对象，示例如下：</p>
<pre><code class="language-javascript">function Loader(){
  let modules = Object.create(null);
  let started = false;
  
  function getNamespaceModule(modulesText){
    let parent = modules;
    if(modulesText){
      let parts = modulesText.split('.');
      for(let i=0; i&lt;parts.length; i++){
        let part = parts[i];
        if (typeof parent[part] === &quot;undefined&quot;) {
          parent[part] = Object.create(null);
        }
        
        parent = parent[part];
      }
    }
    
    return parent;
  }
  
  function addFunction(namespace, fn){
    if(typeof(fn) !== &quot;function&quot;) {
      throw &quot;Only functions can be added&quot;;
    }
       
    let module = getNamespaceModule(namespace);
    let fnName = fn.name;    
    module[fnName] = fn;
  }
  
  function addNamespace(namespace){
    return function(fn){
      addFunction(namespace, fn)
    }
  }
  
  function factory(){
    if(typeof(arguments[0]) === &quot;string&quot;){
      return addNamespace(arguments[0]);
    } else {
      return addFunction(null, arguments[0]);
    }
  }
  
  function start(startApplication){
    if(started){
      throw &quot;App can be started only once&quot;;
    }
     
    startApplication(Object.freeze(modules));
    started = true;
  }
  
  return Object.freeze({
    factory,
    start
  });
};
let app = Loader();
</code></pre>
<p><code>factory()</code> 方法用于添加新的工厂函数到内部变量 <code>modules</code> 中。</p>
<p><code>start()</code> 方法则会调用回调函数，在回调函数中访问内部变量。</p>
<p>通过 <code>factory()</code> 定义工厂函数，将 <code>start()</code> 作为整个应用中调用各种工厂函数生成不同对象的唯一入口点，这是如此简洁优雅的方式。</p>
<p>在这里，<code>factory</code> 和 <code>start</code> 都是闭包。</p>
<h1 id="10-总结">10 总结</h1>
<p>闭包是一个可以访问外部作用域中变量的内部函数。</p>
<p>这些被引用的变量直到闭包被销毁时才会被销毁。</p>
<p>闭包使得 <code>timer</code> 定时器，事件处理，<code>Ajax</code> 请求等异步任务更加容易。</p>
<p>可以通过闭包来达到封装性。</p>
<p>最后，想获得更多关于 JavaScript 函数相关知识，可以查看以下文章：</p>
<ul>
<li><a href="https://medium.freecodecamp.org/discover-functional-programming-in-javascript-with-this-thorough-introduction-a2ad9af2d645">Discover Functional Programming in JavaScript with this thorough introduction</a></li>
<li><a href="https://medium.freecodecamp.org/discover-the-power-of-first-class-functions-fd0d7b599b69">Discover the power of first class functions</a></li>
<li><a href="https://medium.freecodecamp.org/how-point-free-composition-will-make-you-a-better-functional-programmer-33dcb910303a">How point-free composition will make you a better functional programmer</a></li>
<li><a href="https://medium.freecodecamp.org/here-are-a-few-function-decorators-you-can-write-from-scratch-488549fe8f86">Here are a few function decorators you can write from scratch</a></li>
<li><a href="https://medium.freecodecamp.org/make-your-code-easier-to-read-with-functional-programming-94fb8cc69f9d">Make your code easier to read with Functional Programming</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[忘记 jQuery 使用原生接口]]></title>
        <id>https://faded.auspicious.space/post/how-to-forget-about-jquery-and-start-using-native/</id>
        <link href="https://faded.auspicious.space/post/how-to-forget-about-jquery-and-start-using-native/">
        </link>
        <updated>2020-04-15T04:43:35.000Z</updated>
        <summary type="html"><![CDATA[<p><a href="https://www.jeffjade.com/2015/11/25/2015-11-31-jQuery-vs-javaScript/">jQuery VS JavaScript原生API</a></p>
]]></summary>
        <content type="html"><![CDATA[<p><a href="https://www.jeffjade.com/2015/11/25/2015-11-31-jQuery-vs-javaScript/">jQuery VS JavaScript原生API</a></p>
<!-- more -->
<h1 id="1-选择元素">1 选择元素</h1>
<pre><code class="language-javascript">// jQuery  
var els = $('.el');  
//==========================================================//
// 原生方法  
var els = document.querySelectorAll('.el');  
// 函数法  
var $ = function (el) {  
 return document.querySelectorAll(el);  
}  
var els = $('.el');
</code></pre>
<h1 id="2-创建元素">2 创建元素</h1>
<pre><code class="language-javascript">// jQuery  
var newEl = $('&lt;div/&gt;');  
//==========================================================//
// 原生方法  
var newEl = document.createElement('div');
</code></pre>
<h1 id="3-添加-移除-切换类">3 添加 / 移除 / 切换类</h1>
<pre><code class="language-javascript">// jQuery  
$('.el').addClass('class');  
$('.el').removeClass('class');  
$('.el').toggleClass('class');  
//==========================================================//
// 原生方法  
document.querySelector('.el').classList.add('class');  
document.querySelector('.el').classList.remove('class');
document.querySelector('.el').classList.toggle('class');
</code></pre>
<p>4 判断是否包含类</p>
<pre><code class="language-javascript">// jQuery
$('.el').hasClass('className');
$('.el').has('.className'); //也可以用来 判断是否包含某个元素
//==========================================================//
// 原生方法(1)
_hasClass(document.querySelector('.el'), className);
function _hasClass( elements,cName ){
    return !!elements.className.match( new RegExp( &quot;(\\s|^)&quot; + cName + &quot;(\\s|$)&quot;) );
};
// 原生方法(2)
if(el.classList.contains(&quot;someClass&quot;)){}
</code></pre>
<h1 id="5-添加事件监听器">5 添加事件监听器</h1>
<pre><code class="language-javascript">// jQuery  
$('.el').on('event', function() {
});  
//==========================================================//  
// 原生方法  
[].forEach.call(document.querySelectorAll('.el'), function (el) {  
  el.addEventListener('event', function() {
  }, false);
});
</code></pre>
<h2 id="原生-dom绑定事件-优化1-参考here">原生－DOM绑定事件－优化1 参考<a href="https://www.cnblogs.com/coffeedeveloper/p/4811850.html">HERE</a></h2>
<pre><code class="language-javascript">//DOM绑定事件-之自执行
var BindEvent = (function () {
  if ('addEventListener' in document) {
    return function (dom, event, handle, ex) {
      dom.addEventListener(event, handle, ex || false);
    }
  } else if ('attachEvent' in document) {
    return function (dom, event, handle) {
      dom.attachEvent('on' + event, handle);
    }
  } else {
    return function (dom, event, handle) {
      dom['on' + event] = handle;
    }
  }
})();```

## 原生－DOM绑定事件－优化2
```javascript
//DOM绑定事件-之惰性加载(调用方去触发BindEvent之时才去做初始化)//
var BindEvent = function (dom, event, handle, ex) {
  if ('addEventListener' in document) {
    BindEvent = function (dom, event, handle, ex) {
      dom.addEventListener(event, handle, ex || false);
    }
  } else if ('attachEvent' in document) {
trueBindEvent = function (dom, event, handle) {
      dom.attachEvent('on' + event, handle);
    }
  } else {
    BindEvent = function (dom, event, handle) {
      dom['on' + event] = handle;
    }
  }
  BindEvent(dom, event, handle, ex);
};
</code></pre>
<h1 id="6-设置-获取属性">6 设置 / 获取属性</h1>
<pre><code class="language-javascript">// jQuery  
$('.el').filter(':first').attr('key', 'value');  
$('.el').filter(':first').attr('key');  
//==========================================================//
// 原生方法  
document.querySelector('.el').setAttribute('key', 'value');  
document.querySelector('.el').getAttribute('key');
</code></pre>
<h1 id="7-附加内容append">7 附加内容（Append）</h1>
<pre><code class="language-javascript">// jQuery  
$('.el').append($('&lt;div/&gt;'));  
//==========================================================//
// 原生方法  
document.querySelector('.el').appendChild(document.createElement('div'));
</code></pre>
<h1 id="8-克隆元素">8 克隆元素</h1>
<pre><code class="language-javascript">// jQuery  
var clonedEl = $('.el').clone();  
//==========================================================//
// 原生方法  
var clonedEl = document.querySelector('.el').cloneNode(true);
</code></pre>
<h1 id="9-移除元素">9 移除元素</h1>
<pre><code class="language-javascript">// jQuery  
$('.el').remove();  
//==========================================================//
// 原生方法  
remove('.el');  
function remove(el) {  
  var toRemove = document.querySelector(el);  
  toRemove.parentNode.removeChild(toRemove);  
}
</code></pre>
<h1 id="10-获取父元素">10 获取父元素</h1>
<pre><code class="language-javascript">// jQuery  
$('.el').parent();  
//==========================================================//
// 原生方法  
document.querySelector('.el').parentNode;
</code></pre>
<h1 id="11-上一个-下一个元素">11 上一个 / 下一个元素</h1>
<pre><code class="language-javascript">// jQuery  
$('.el').prev();  
$('.el').next();  
//==========================================================//
// 原生方法  
document.querySelector('.el').previousElementSibling;  
document.querySelector('.el').nextElementSibling;
</code></pre>
<h1 id="12-修改css属性">12 修改CSS属性</h1>
<p>总是通过 <code>Javascript</code> 修改和检索 <code>CSS</code> 属性，这样会比使用 <code>jQuery CSS</code> 函数更加简单快速，并且没有任何不必要的代码。</p>
<pre><code class="language-javascript">//----设置CSS属性----
/* jQuery */
  $(el).css({
    background: &quot;#FF0000&quot;,
&quot;box-shadow&quot;: &quot;1px 1px 5px 5px red&quot;,
    width: &quot;100px&quot;,
    height: &quot;100px&quot;,
    display: &quot;block&quot;
  });
//==========================================================//
/* 原生 */
var el = document.querySelector(&quot;.main-content&quot;);
el.style.background = &quot;#FF0000&quot;;
el.style.width = &quot;100px&quot;;
el.style.height = &quot;100px&quot;;
el.style.display = &quot;block&quot;;
el.style.boxShadow = &quot;1px 1px 5px 5px red&quot;;
</code></pre>
<h1 id="13-xhr-或-ajax">13 XHR 或 Ajax</h1>
<pre><code class="language-javascript">// jQuery  
$.get('url', function (data) {  
});  
$.post('url', {data: data}, function (data) {  
});  
//==========================================================//
// 原生方法  
// get  
var xhr = new XMLHttpRequest();  
xhr.open('GET', url);  
xhr.onreadystatechange = function (data) {  
}  
xhr.send();  
// post  
var xhr = new XMLHttpRequest()  
xhr.open('POST', url);  
xhr.onreadystatechange = function (data) {  
}  
xhr.send({data: data});
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JavaScript——闭包实际场景应用]]></title>
        <id>https://faded.auspicious.space/post/javascript-closure-application-scenarios/</id>
        <link href="https://faded.auspicious.space/post/javascript-closure-application-scenarios/">
        </link>
        <updated>2020-04-15T04:18:49.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-函数防抖">1. 函数防抖</h1>
<p>比如要缩放窗口 触发 <code>onresize</code> 事件 需要在这时候做一件事情,但是我们希望拖动的时候只触发一次,比如：</p>
<pre><code class="language-javascript">window.onresize = function () {
    console.log('onresize')//只想触发一次
}
</code></pre>
<h2 id="一般方法">一般方法</h2>
<pre><code class="language-javascript">window.onresize = function () {
    debounce(fn, 1000)
}
var fn = function () {
    console.log('fn')
}
var time = ''
function debounce(fn, timeLong) {
    if (time) {
        clearTimeout(time)
        time = ''
    }

    time = setTimeout(function () {
        fn()
    }, timeLong)
}
</code></pre>
<h2 id="闭包">闭包</h2>
<pre><code class="language-javascript">window.onresize = debounce(fn, 500)
function debounce(fn) {
    var timer = null
    return function () {
        if (timer) {     //timer第一次执行后会保存在内存里 永远都是执行器 直到最后被触发
            clearTimeout(timer)
            timer = null
        }
        timer = setTimeout(function () {
            fn()
        }, 1000)
    }

}
var fn = function () {

    console.log('fn')
}
</code></pre>
<h1 id="2-使用闭包设计单例模式">2 使用闭包设计单例模式</h1>
<pre><code class="language-javascript">class CreateUser {
    constructor(name) {
        this.name = name;
        this.getName();
    }
    getName() {
        return this.name;
    }
}
// 代理实现单例模式
var ProxyMode = (function () {
    var instance = null;
    return function (name) {
        if (!instance) {
            instance = new CreateUser(name);
        }
        return instance;
    }
})();
// 测试单体模式的实例
var a = ProxyMode(&quot;aaa&quot;);
var b = ProxyMode(&quot;bbb&quot;);
// 因为单体模式是只实例化一次，所以下面的实例是相等的
console.log(a === b);    //true
</code></pre>
<h1 id="3-为多个组件独立属性">3 为多个组件独立属性</h1>
<p>假如我现在要在页面中使用 <code>Echarts</code>画 6 个线状图，需要 6 个容器。需要为每个容器元素声明一个独立 <code>id</code>，不然会混乱。</p>
<pre><code class="language-typescript">constructor(){
    this.state = { id: &quot;EchartsLine&quot; + Util.clourse() };
}
componentDidMount() {
    this.myEChart = echarts.init(document.getElementById(this.state.id));//不同 id  
}
</code></pre>
<pre><code class="language-html">&lt;div id={this.state.id} className='echarts-line'&gt;&lt;/div&gt;
</code></pre>
<pre><code class="language-javascript">clourse(){
    let clourse = (function () {
        var a = 1;
        return function () {
            return a++;
        }
    })(this);
    this.clourse = clourse;
}
//使用数字命名 不用害怕被篡改
</code></pre>
<h1 id="4-设置私有变量">4 设置私有变量</h1>
<p>内部属性在 <code>Java</code> 里使用 <code>private</code> 就可以，但是 <code>JS</code> 还没有这个东东。</p>
<pre><code class="language-javascript">let _width = Symbol();
class Private {
    constructor(s) {
        this[_width] = s
    }
    foo() {
        console.log(this[_width])
    }
}
var p = new Private(&quot;50&quot;);
p.foo();
console.log(p[_width]); //可以拿到
</code></pre>
<pre><code class="language-javascript">// 赋值到闭包里
let sque = (function () {
    let _width = Symbol();
    class Squery {
        constructor(s) {
            this[_width] = s
        }

        foo() {
            console.log(this[_width])
        }
    }
    return Squery
})();

let ss = new sque(20);
ss.foo();
console.log(ss[_width])
</code></pre>
<h1 id="5-拿到正确的值">5 拿到正确的值</h1>
<pre><code class="language-javascript">for (var i = 0; i &lt; 10; i++) {
    setTimeout(function () {
        console.log(i) // 10 个 10
    }, 1000)
}
</code></pre>
<p>遇到这种问题 如何用解决呢？</p>
<pre><code class="language-javascript">for (var i = 0; i &lt; 10; i++) {
    ((j) =&gt; {
        setTimeout(function () {
            console.log(j)//1-10
        }, 1000)
    })(i)
}
</code></pre>
<p>原理是 声明了10个自执行函数，保存当时的值到内部。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JavaScript——闭包简介]]></title>
        <id>https://faded.auspicious.space/post/javascript-closure-introduction/</id>
        <link href="https://faded.auspicious.space/post/javascript-closure-introduction/">
        </link>
        <updated>2020-04-15T03:39:06.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p><a href="https://juejin.im/post/5b081f8d6fb9a07a9b3664b6">闭包详解一</a></p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p><a href="https://juejin.im/post/5b081f8d6fb9a07a9b3664b6">闭包详解一</a></p>
</blockquote>
<!-- more -->
<h1 id="一-什么是闭包">一、什么是闭包</h1>
<p>《JavaScript高级程序设计》这样描述：</p>
<blockquote>
<p>闭包是指有权访问另一个函数作用域中的变量的函数；</p>
</blockquote>
<p>《JavaScript权威指南》这样描述：</p>
<blockquote>
<p>从技术的角度讲，所有的JavaScript函数都是闭包：它们都是对象，它们都关联到作用域链。</p>
</blockquote>
<p>《你不知道的JavaScript》这样描述：</p>
<blockquote>
<p><strong>当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。</strong></p>
</blockquote>
<p>我最认同的是《你不知道的JavaScript》中的描述，虽然前面的两种说法都没有错，但闭包应该是基于词法作用域书写代码时产生的自然结果，是一种现象！你也不用为了利用闭包而特意的创建，因为闭包的在你的代码中随处可见，只是你还不知道当时你写的那一段代码其实就产生了闭包。</p>
<h1 id="二-讲解闭包">二、讲解闭包</h1>
<p>上面已经说到，<strong>当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行</strong>。</p>
<p>看一段代码</p>
<pre><code class="language-javascript">function fn1() {
	var name = 'iceman';
	function fn2() {
		console.log(name);
	}
	fn2();
}
fn1();
</code></pre>
<p>如果是根据《JavaScript高级程序设计》和《JavaScript权威指南》来说，上面的代码已经产生闭包了。<code>fn2</code> 访问到了 <code>fn1</code> 的变量，满足了条件“有权访问另一个函数作用域中的变量的函数”，<code>fn2</code> 本身是个函数，所以满足了条件“所有的JavaScript函数都是闭包”。</p>
<p>这的确是闭包，但是这种方式定义的闭包不太好观察。</p>
<p>再看一段代码：</p>
<pre><code class="language-javascript">function fn1() {
	var name = 'iceman';
	function fn2() {
		console.log(name);
	}
	return fn2;
}
var fn3 = fn1();
fn3();
</code></pre>
<p>这样就清晰地展示了闭包：</p>
<ul>
<li><code>fn2</code> 的词法作用域能访问 <code>fn1</code>的作用域；</li>
<li>将 <code>fn2</code> 当做一个值返回；</li>
<li><code>fn1</code> 执行后，将 <code>fn2</code> 的引用赋值给 <code>fn3</code>；</li>
<li>执行 <code>fn3</code>，输出了变量 <code>name</code>。</li>
</ul>
<p>我们知道通过引用的关系，<code>fn3</code> 就是 <code>fn2</code> 函数本身。执行 <code>fn3</code> 能正常输出 <code>name</code>，这不就是 <code>fn2</code> 能记住并访问它所在的词法作用域，而且 <code>fn2</code> 函数的运行还是在当前词法作用域之外了。</p>
<p>正常来说，当 <code>fn1</code> 函数执行完毕之后，其作用域是会被销毁的，然后垃圾回收器会释放那段内存空间。而闭包却很神奇的将 <code>fn1</code> 的作用域存活了下来，<code>fn2</code> 依然持有该作用域的引用，这个引用就是闭包。</p>
<p>总结：<strong>某个函数在定义时的词法作用域之外的地方被调用，闭包可以使该函数极限访问定义时的词法作用域。</strong></p>
<p>注意：对函数值的传递可以通过其他的方式，并不一定值有返回该函数这一条路，比如可以用回调函数：</p>
<pre><code class="language-javascript">function fn1() {
	var name = 'iceman';
	function fn2() {
		console.log(name);
	}
	fn3(fn2);
}
function fn3(fn) {
	fn();
}
fn1();
</code></pre>
<p>本例中，将内部函数 <code>fn2</code> 传递给 <code>fn3</code>，当它在 <code>fn3</code> 中被运行时，它是可以访问到 <code>name</code>变量的。</p>
<p>所以无论通过哪种方式将内部的函数传递到所在的词法作用域以外，它都回持有对原始作用域的引用，无论在何处执行这个函数都会使用闭包。</p>
<h3 id="三-再次解释闭包">三、再次解释闭包</h3>
<p>以上的例子会让人觉得有点学院派了，但是闭包绝不仅仅是一个无用的概念，你写过的代码当中肯定有闭包的身影，比如类似如下的代码：</p>
<pre><code class="language-javascript">function waitSomeTime(msg, time) {
	setTimeout(function () {
		console.log(msg)
	}, time);
}
waitSomeTime('hello', 1000);
</code></pre>
<p>定时器中有一个匿名函数，该匿名函数就有涵盖 <code>waitSomeTime</code> 函数作用域的闭包，因此当 1 秒之后，该匿名函数能输出 <code>msg</code>。</p>
<p>另一个很经典的例子就是 <code>for</code> 循环中使用定时器延迟打印的问题：</p>
<pre><code class="language-javascript">for (var i = 1; i &lt;= 10; i++) {
	setTimeout(function () {
		console.log(i);
	}, 1000);
}
</code></pre>
<p>在这段代码中，我们对其的预期是输出 1~10，但却输出 10 次 11。这是因为 <code>setTimeout</code> 中的匿名函数执行的时候，<code>for</code> 循环都已经结束了，<code>for</code> 循环结束的条件是 <code>i</code> 大于 10，所以当然是输出 10 次 11 咯。</p>
<p>究其原因：<code>i</code> 是声明在全局作用中的，定时器中的匿名函数也是执行在全局作用域中，那当然是每次都输出 11 了。</p>
<p>原因知道了，解决起来就简单了，我们可以让i在每次迭代的时候，都产生一个私有的作用域，在这个私有的作用域中保存当前i的值。</p>
<pre><code class="language-javascript">for (var i = 1; i &lt;= 10; i++) {
	(function () {
		var j = i;
		setTimeout(function () {
			console.log(j);
		}, 1000);
	})();
}
</code></pre>
<p>这样就达到我们的预期了呀，让我们用一种比较优雅的写法改造一些，将每次迭代的i作为实参传递给自执行函数，自执行函数中用变量去接收：</p>
<pre><code class="language-javascript">for (var i = 1; i &lt;= 10; i++) {
	(function (j) {
		setTimeout(function () {
			console.log(j);
		}, 1000);
	})(i);
}
</code></pre>
<h1 id="四-闭包的应用">四、闭包的应用</h1>
<p>闭包的应用比较典型是定义模块，我们将操作函数暴露给外部，而细节隐藏在模块内部：</p>
<pre><code class="language-javascript">function module() {
	var arr = [];
	function add(val) {
		if (typeof val == 'number') {
			arr.push(val);
		}
	}
	function get(index) {
		if (index &lt; arr.length) {
			return arr[index]
		} else {
			return null;
		}
	}
	return {
		add: add,
		get: get
	}
}
var mod1 = module();
mod1.add(1);
mod1.add(2);
mod1.add('xxx');
console.log(mod1.get(2));
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JavaScript——7 个角度吃透 Lodash 防抖节流原理]]></title>
        <id>https://faded.auspicious.space/post/javascript-a-simple-explanation-to-debounce-and-throttle-in-lodash/</id>
        <link href="https://faded.auspicious.space/post/javascript-a-simple-explanation-to-debounce-and-throttle-in-lodash/">
        </link>
        <updated>2020-04-14T04:01:24.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p><a href="https://www.muyiy.cn/blog/7/7.5.html">浅出篇 7 个角度吃透 Lodash 防抖节流原理</a></p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p><a href="https://www.muyiy.cn/blog/7/7.5.html">浅出篇 7 个角度吃透 Lodash 防抖节流原理</a></p>
</blockquote>
<!-- more -->
<h1 id="节流函数-throttle">节流函数 Throttle</h1>
<p>我们先来看一张图，这张图充分说明了 Throttle（节流）和 Debounce（防抖）的区别，以及在不同配置下产生的不同效果，其中 <code>mousemove</code> 事件每 50 ms 触发一次，即下图中的每一小隔是 50 ms。今天这篇文章就从下面这张图开始介绍。<br>
<img src="https://faded.auspicious.space/post-images/1586843513764.jpg" alt="" loading="lazy"></p>
<h2 id="角度-1">角度 1</h2>
<p><code>lodash.throttle(fn, 200, {leading: true, trailing: true})</code></p>
<h3 id="mousemove-第一次触发">mousemove 第一次触发</h3>
<p>先来看下 throttle 源码</p>
<pre><code class="language-javascript">function throttle(func, wait, options) {
  // 首尾调用默认为 true
  let leading = true
  let trailing = true

  if (typeof func !== 'function') {
    throw new TypeError('Expected a function')
  }
  // options 是否是对象
  if (isObject(options)) {
    leading = 'leading' in options ? !!options.leading : leading
    trailing = 'trailing' in options ? !!options.trailing : trailing
  }
  // maxWait 为 wait 的防抖函数
  return debounce(func, wait, {
    leading,
    trailing,
    'maxWait': wait,
  })
}
</code></pre>
<p>所以 <code>throttle(fn, 200, {leading: true, trailing: true})</code> 返回内容是 <code>debounce(fn, 200, {leading: true, trailing: true, maxWait: 200})</code>，多了 <code>maxWait: 200</code> 这部分。</p>
<p>先打个预防针，后面即将开始比较难的部分，看下 <code>debounce</code> 入口函数。</p>
<pre><code class="language-javascript">// 入口函数，返回此函数
function debounced(...args) {
  // 获取当前时间
  const time = Date.now()
  // 判断此时是否应该执行 func 函数
  const isInvoking = shouldInvoke(time)

  // 赋值给闭包，用于其他函数调用
  lastArgs = args
  lastThis = this
  lastCallTime = time

  // 执行
  if (isInvoking) {
    // 无 timerId 的情况有两种：
    // 1、首次调用 
    // 2、trailingEdge 执行过函数
    if (timerId === undefined) {
      return leadingEdge(lastCallTime)
    }
    
    // 如果设置了最大等待时间，则立即执行 func
    // 1、开启定时器，到时间后触发 trailingEdge 这个函数。
    // 2、执行 func，并返回结果
    if (maxing) {
      // 循环定时器中处理调用
      timerId = startTimer(timerExpired, wait)
      return invokeFunc(lastCallTime)
    }
  }
  // 一种特殊情况，trailing 设置为 true 时，前一个 wait 的 trailingEdge 已经执行了函数
  // 此时函数被调用时 shouldInvoke 返回 false，所以要开启定时器
  if (timerId === undefined) {
    timerId = startTimer(timerExpired, wait)
  }
  // 不需要执行时，返回结果
  return result
}
</code></pre>
<p>对于 <code>debounce(fn, 200, {leading: true, trailing: true, maxWait: 200})</code> 来说，会经历如下过程。</p>
<ol>
<li><code>shouldInvoke(time)</code> 中，因为满足条件 <code>lastCallTime === undefined</code>，所以返回 <code>true</code>。</li>
<li><code>lastCallTime = time</code>，所以 <code>lastCallTime</code> 等于当前时间，假设为 <code>0</code>。</li>
<li><code>timerId === undefined</code> 满足，执行 <code>leadingEdge(lastCallTime)</code> 方法。</li>
</ol>
<pre><code class="language-javascript">// 执行连续事件刚开始的那次回调
function leadingEdge(time) {
  // 1、设置上一次执行 func 的时间
  lastInvokeTime = time
  // 2、开启定时器，为了事件结束后的那次回调
  timerId = startTimer(timerExpired, wait)
  // 3、如果配置了 leading 执行传入函数 func
  // leading 来源自 !!options.leading
  return leading ? invokeFunc(time) : result
}
</code></pre>
<ol start="4">
<li>在 <code>leadingEdge(time)</code> 中，设置 <code>lastInvokeTime</code> 为当前时间即 <code>0</code>，开启 <code>200</code> 毫秒定时器，执行 <code>invokeFunc(time)</code> 并返回。</li>
</ol>
<pre><code class="language-javascript">// 执行 Func 函数
function invokeFunc(time) {
  // 获取上一次执行 debounced 的参数
  const args = lastArgs
  // 获取上一次的 this
  const thisArg = lastThis

  // 重置
  lastArgs = lastThis = undefined
  lastInvokeTime = time
  result = func.apply(thisArg, args)
  return result
}
</code></pre>
<ol start="5">
<li>在 <code>invokeFunc(time)</code> 中，执行 <code>func.apply(thisArg, args)</code>，即 <code>fn</code> 函数第一次执行，并把结果赋值给 <code>result</code>，便于后续触发时直接返回。同时重置 <code>lastInvokeTime</code> 为当前时间即 <code>0</code>，清空 <code>lastArgs</code> 和 <code>lastThis</code>。</li>
<li>第一次触发已经完成，注意此时 <code>lastCallTime</code> 和 <code>lastInvokeTime</code> 都为 <code>0</code>，<code>200</code> 毫秒的定时器还在运行中。</li>
</ol>
<h3 id="mousemove-第二次触发">mousemove 第二次触发</h3>
<p><code>50</code> 毫秒后第二次触发到来，此时当前时间 <code>time</code> 为 <code>50</code>，<code>wait</code> 为 <code>200</code>， <code>maxWait</code> 为 <code>200</code>，<code>maxing</code> 为 <code>true</code>，<code>lastCallTime</code> 和 <code>lastInvokeTime</code> 都为 <code>0</code>，<code>timerId</code> 定时器存在，我们来看下执行步骤。</p>
<pre><code class="language-javascript">function shouldInvoke(time) {
  // 当前时间距离上一次调用 debounce 的时间差
  const timeSinceLastCall = time - lastCallTime
  // 当前时间距离上一次执行 func 的时间差
  const timeSinceLastInvoke = time - lastInvokeTime

  // 下述 4 种情况返回 true
  return ( lastCallTime === undefined || 
          (timeSinceLastCall &gt;= wait) ||
          (timeSinceLastCall &lt; 0) || 
          (maxing &amp;&amp; timeSinceLastInvoke &gt;= maxWait) )
}
</code></pre>
<ol>
<li><code>shouldInvoke(time)</code> 中，<code>timeSinceLastCall</code> 为 <code>50</code>，<code>timeSinceLastInvoke</code> 为 <code>50</code>，<code>4</code> 种条件都不满足，返回 <code>false</code>。</li>
<li>此时 <code>isInvoking</code> 为 <code>false</code>，同时 <code>timerId === undefined</code> 不满足，直接返回第一次触发时的 <code>result</code>。</li>
<li>第二次触发完成，并不会执行 <code>fn</code>，只会返回上次执行的结果 <code>result</code>。</li>
<li>第三次和第四次触发时，效果一样，就不再重复了。</li>
</ol>
<h3 id="mousemove-第五次触发">mousemove 第五次触发</h3>
<p>距第一次触发 <code>200</code> 毫秒后第五次触发到来，此时当前时间 <code>time</code> 为 <code>200</code>，<code>wait</code> 为 <code>200</code>， <code>maxWait</code> 为 <code>200</code>，<code>maxing</code> 为 <code>true</code>，<code>lastCallTime</code> 为 <code>150</code>，<code>lastInvokeTime</code> 为 <code>0</code>，<code>timerId</code> 定时器存在，我们来看下执行步骤。</p>
<ol>
<li><code>shouldInvoke(time)</code> 中，<code>timeSinceLastInvoke</code> 为 <code>200</code>，满足 <code>(maxing &amp;&amp; timeSinceLastInvoke &gt;= maxWait)</code>，所以返回 <code>true</code>。</li>
</ol>
<pre><code class="language-javascript">// debounced 方法中执行到这部分
if (maxing) {
  // 循环定时器中处理调用
  timerId = startTimer(timerExpired, wait)
  return invokeFunc(lastCallTime)
}
</code></pre>
<ol start="2">
<li>满足 <code>maxing</code> 条件，重新开启 <code>200</code> 毫秒的定时器，并执行 <code>invokeFunc(lastCallTime)</code> 函数。</li>
<li><code>invokeFunc(time)</code> 中，重置 <code>lastInvokeTime</code> 为当前时间即 <code>200</code>，清空 <code>lastArgs</code> 和 <code>lastThis</code>。</li>
<li>第六、七、八次触发时，同第二次触发效果一致，就不再重复了。</li>
</ol>
<h3 id="mousemove-停止触发">mousemove 停止触发</h3>
<p>假设第八次触发之后就停止了滚动，在第八次触发时 <code>time</code> 为 <code>350</code>，所以如果有第九次触发，那么此时是应该执行 <code>fn</code> 的，但是此时 <code>mousemove</code> 已经停止了触发，那么还会执行 <code>fn</code> 吗？答案是依旧执行，因为最开始设置了 <code>{trailing: true}</code>。</p>
<pre><code class="language-javascript">// 开启定时器
function startTimer(pendingFunc, wait) {
  // 没传 wait 时调用 window.requestAnimationFrame()
  if (useRAF) {
    // 若想在浏览器下次重绘之前继续更新下一帧动画
    // 那么回调函数自身必须再次调用 window.requestAnimationFrame()
    root.cancelAnimationFrame(timerId);
    return root.requestAnimationFrame(pendingFunc)
  }
  // 不使用 RAF 时开启定时器
  return setTimeout(pendingFunc, wait)
}
</code></pre>
<p>在第五次触发时开启了 <code>200</code> 毫秒的定时器，所以在时间 <code>time</code> 到 <code>400</code> 时会执行 <code>pendingFunc</code>，此时的 <code>pendingFunc</code> 就是 <code>timerExpired</code> 函数，来看下具体的代码。</p>
<pre><code class="language-javascript">// 定时器回调函数，表示定时结束后的操作
function timerExpired() {
  const time = Date.now()
  // 1、是否需要执行
  // 执行事件结束后的那次回调，否则重启定时器
  if (shouldInvoke(time)) {
    return trailingEdge(time)
  }
  // 2、否则 计算剩余等待时间，重启定时器，保证下一次时延的末尾触发
  timerId = startTimer(timerExpired, remainingWait(time))
}
</code></pre>
<p>此时在 <code>shouldInvoke(time)</code> 中，<code>time</code> 为 <code>400</code>，<code>lastInvokeTime</code> 为 <code>200</code>，<code>timeSinceLastInvoke</code> 为 <code>200</code>，满足 <code>(maxing &amp;&amp; timeSinceLastInvoke &gt;= maxWait)</code>，所以返回 <code>true</code>。</p>
<pre><code class="language-javascript">// 执行连续事件结束后的那次回调
function trailingEdge(time) {
  // 清空定时器
  timerId = undefined

  // trailing 和 lastArgs 两者同时存在时执行
  // trailing 来源自 'trailing' in options ? !!options.trailing : trailing
  // lastArgs 标记位的作用，意味着 debounce 至少执行过一次
  if (trailing &amp;&amp; lastArgs) {
    return invokeFunc(time)
  }
  // 清空参数
  lastArgs = lastThis = undefined
  return result
}
</code></pre>
<p>之后执行 <code>trailingEdge(time)</code>，在这个函数中判断 <code>trailing</code> 和 <code>lastArgs</code>，此时这两个条件都是 <code>true</code>，所以会执行 <code>invokeFunc(time)</code>，最终执行函数 <code>fn</code>。</p>
<p>这里需要说明以下两点：</p>
<ul>
<li>如果设置了 <code>{trailing: false}</code>，那么最后一次是不会执行的。对于 <code>throttle</code> 和 <code>debounce</code> 来说，默认值是 <code>true</code>，所以如果没有特意指定 <code>trailing</code>，那么最后一次是一定会执行的。</li>
<li>对于 <code>lastArgs</code> 来说，执行 <code>debounced</code> 时会赋值，即每次触发都会重新赋值一次，那什么时候清空呢，在 <code>invokeFunc(time)</code> 中执行 <code>fn</code> 函数时重置为 <code>undefined</code>，所以如果 <code>debounced</code> 只触发了一次，即使设置了 <code>{trailing: true}</code> 那也不会再执行 <code>fn</code> 函数，这个就解答了上篇文章留下的第一道思考题。</li>
</ul>
<h2 id="角度-2">角度 2</h2>
<p><code>lodash.throttle(fn, 200, {leading: true, trailing: false})</code><br>
在<a href="#mousemove-%E5%81%9C%E6%AD%A2%E8%A7%A6%E5%8F%91">角度 1 之 mousemove 停止触发</a>这部分中说到，如果不设置 <code>trailing</code> 和设置 <code>{trailing: true}</code> 效果是一样的，事件回调结束后都会再执行一次传入函数 fn，但是如果设置了 <code>{trailing: false}</code>，那么事件回调结束后是不会再执行 <code>fn</code> 的。</p>
<p>此时的配置对比角度 1 来说，区别在于设置了 <code>{trailing: false}</code>，所以实际效果对比 1 来说，就是最后不会额外再执行一次，效果见第一张图。</p>
<h2 id="角度-3">角度 3</h2>
<p><code>lodash.throttle(fn, 200, {leading: false, trailing: true})</code><br>
此时的配置和角度 1 相比，区别在于设置了 <code>{leading: false}</code>，所以直接看 <code>leadingEdge(time)</code> 方法就可以了。</p>
<pre><code class="language-javascript">// 执行连续事件刚开始的那次回调
function leadingEdge(time) {
  // 1、设置上一次执行 func 的时间
  lastInvokeTime = time
  // 2、开启定时器，为了事件结束后的那次回调
  timerId = startTimer(timerExpired, wait)
  // 3、如果配置了 leading 执行传入函数 func
  // leading 来源自 !!options.leading
  return leading ? invokeFunc(time) : result
}
</code></pre>
<p>在这里，会开启 <code>200</code> 毫秒的定时器，同时因为 <code>leading</code> 为 <code>false</code>，所以并不会执行 <code>invokeFunc(time)</code>，只会返回 <code>result</code>，此时的 <code>result</code> 值是 <code>undefined</code>。</p>
<p>这里开启一个定时器的目的是为了事件结束后的那次回调，即如果设置了 <code>{trailing: true}</code> 那么最后一次回调将执行传入函数 <code>fn</code>，哪怕 <code>debounced</code> 函数只触发一次。</p>
<p>这里指定了 <code>{leading: false}</code>，那么 <code>leading</code> 的初始值是什么呢？在 <code>debounce</code> 中是 <code>false</code>，在 <code>throttle</code> 中是 <code>true</code>。所以在 <code>throttle</code> 中不需要刚开始就触发时，必须指定 <code>{leading: false}</code>，在 <code>debounce</code> 中就不需要了，默认不触发。</p>
<h1 id="防抖函数-debounce">防抖函数 Debounce</h1>
<h2 id="角度-4">角度 4</h2>
<p><code>lodash.debounce(fn, 200, {leading: false, trailing: true})</code></p>
<p>此时相比较 <code>throttle</code> 来说，缺少了 <code>maxWait</code> 值，所以具体触发过程中的判断就不一样了，来详细看一遍。</p>
<ol>
<li>在入口函数 <code>debounced</code> 中，执行 <code>shouldInvoke(time)</code>，前面讨论过因为第一次触发所以会返回 <code>true</code>，之后执行 <code>leadingEdge(lastCallTime)</code>。</li>
</ol>
<pre><code class="language-javascript">// 执行连续事件刚开始的那次回调
function leadingEdge(time) {
  // 1、设置上一次执行 func 的时间
  lastInvokeTime = time
  // 2、开启定时器，为了事件结束后的那次回调
  timerId = startTimer(timerExpired, wait)
  // 3、如果配置了 leading 执行传入函数 func
  // leading 来源自 !!options.leading
  return leading ? invokeFunc(time) : result
}
</code></pre>
<ol start="2">
<li>在 <code>leadingEdge</code> 中，因为 <code>leading</code> 为 <code>false</code>，所以并不执行 <code>fn</code>，只开启 <code>200</code> 毫秒的定时器，并返回 <code>undefined</code>。此时 <code>lastInvokeTime</code> 为当前时间，假设为 <code>0</code>。</li>
</ol>
<pre><code class="language-javascript">// 判断此时是否应该执行 func 函数
function shouldInvoke(time) {
  // 当前时间距离上一次调用 debounce 的时间差
  const timeSinceLastCall = time - lastCallTime
  // 当前时间距离上一次执行 func 的时间差
  const timeSinceLastInvoke = time - lastInvokeTime

  // 下述 4 种情况返回 true
  return ( lastCallTime === undefined || 
          (timeSinceLastCall &gt;= wait) ||
          (timeSinceLastCall &lt; 0) || 
          (maxing &amp;&amp; timeSinceLastInvoke &gt;= maxWait) )
}
</code></pre>
<ol start="3">
<li>之后每次触发时，<code>timeSinceLastCall</code> 总是为 <code>50</code> 毫秒，<code>maxing</code> 为 <code>false</code>，所以 <code>shouldInvoke(time)</code> 总是返回 <code>false</code>，并不会执行传入函数 <code>fn</code>，只返回 <code>result</code>，即为 <code>undefined</code>。</li>
<li>到现在为止，<code>fn</code> 一次还没有执行，<code>200</code> 毫秒后，定时器回调函数触发，执行 <code>timerExpired</code> 函数。</li>
</ol>
<pre><code class="language-javascript">// 定时器回调函数，表示定时结束后的操作
function timerExpired() {
  const time = Date.now()
  // 1、是否需要执行
  // 执行事件结束后的那次回调，否则重启定时器
  if (shouldInvoke(time)) {
    return trailingEdge(time)
  }
  // 2、否则 计算剩余等待时间，重启定时器，保证下一次时延的末尾触发
  timerId = startTimer(timerExpired, remainingWait(time))
}
</code></pre>
<ol start="5">
<li>此时存在两种情况，第一种是 <code>mousemove</code> 事件一直在触发，根据前面介绍 <code>shouldInvoke(time)</code> 会返回 <code>false</code>，之后就将计算剩余等待时间，重启定时器。时间计算公式为 <code>wait - (time - lastCallTime)</code>，即 <code>200 - 50</code>，所以只要 <code>shouldInvoke(time)</code> 返回 <code>false</code>，就每隔 <code>150</code> 毫秒后执行一次 <code>timerExpired()</code>。</li>
<li>第二种情况是 <code>mousemove</code> 事件不再触发，因为 <code>timerExpired()</code> 在循环执行，所以肯定会存在一种情况满足 <code>timeSinceLastCall &gt;= wait</code>，即 <code>shouldInvoke(time)</code> 返回 <code>true</code>，终结 <code>timerExpired()</code> 的循环，并执行 <code>trailingEdge(time)</code>。</li>
</ol>
<pre><code class="language-javascript">// 执行连续事件结束后的那次回调
function trailingEdge(time) {
  // 清空定时器
  timerId = undefined

  // trailing 和 lastArgs 两者同时存在时执行
  // trailing 来源自 'trailing' in options ? !!options.trailing : trailing
  // lastArgs 标记位的作用，意味着 debounce 至少执行过一次
  if (trailing &amp;&amp; lastArgs) {
    return invokeFunc(time)
  }
  // 清空参数
  lastArgs = lastThis = undefined
  return result
}
</code></pre>
<ol start="7">
<li>在 <code>trailingEdge</code> 中 <code>trailing</code> 和 <code>lastArgs</code> 都是 <code>true</code>，所以会执行 <code>invokeFunc(time)</code>，即执行传入函数 <code>fn</code>。</li>
<li>所以整个过程中只在最后执行一次传入函数 <code>fn</code>，效果同上面第一张图所示。</li>
</ol>
<h2 id="角度-5">角度 5</h2>
<p><code>lodash.debounce(fn, 200, {leading: true, trailing: false})</code><br>
此时相比角度 4 来说，差异在于 <code>{leading: true, trailing: false}</code>，但是 <code>wait</code> 和 <code>maxWait</code> 都和角度 4 一致，所以只存在下面 2 种区别，效果同上面第一张图所示。</p>
<ul>
<li>区别 1：<code>leadingEdge</code>  中会执行传入函数 <code>fn</code></li>
<li>区别 2：<code>trailingEdge</code> 中不再执行传入函数 <code>fn</code></li>
</ul>
<h2 id="角度-6">角度 6</h2>
<p><code>lodash.debounce(fn, 200, {leading: true, trailing: true})</code><br>
此时相比角度 4 来说，差异仅仅在于设置了 <code>{leading: true}</code>，所以只存在一个区别，那就是在 <code>leadingEdge</code> 中会执行传入函数 <code>fn</code>，当然在 <code>trailingEdge</code> 中依旧执行传入函数 <code>fn</code>，所以会出现在 <code>mousemove</code> 事件触发过程中首尾都会执行的情况，效果同上面第一张图所示。</p>
<p>当然一种情况除外，那就是 <code>mousemove</code> 事件永远只触发一次的情况，关键在于 <code>lastArgs</code> 变量。</p>
<p>对于 <code>lastArgs</code> 变量来说，在入口函数 <code>debounced</code> 中赋值，即每次触发都会重新赋值一次，那什么时候清空呢，在 <code>invokeFunc(time)</code> 中重置为 <code>undefined</code>，所以如果 <code>debounced</code> 只触发了一次，而且在 <code>{leading: true}</code> 时执行过一次 <code>fn</code>，那么即使设置了 <code>{trailing: true}</code> 也不会再执行传入函数 <code>fn</code>。</p>
<h2 id="角度-7">角度 7</h2>
<p><code>lodash.debounce(fn, 200, {leading: false, trailing: true, maxWait: 400})</code><br>
此时 <code>wait</code> 为 <code>200</code>，<code>maxWait</code> 为 <code>400</code>，<code>maxing</code> 为 <code>true</code>，我们来看下执行过程。</p>
<ol>
<li>第一次触发时，因为 <code>{leading: false}</code>，所以肯定不会执行 <code>fn</code>，此时开启了一个 <code>200</code> 毫秒的定时器。</li>
</ol>
<pre><code class="language-javascript">// 判断此时是否应该执行 func 函数
function shouldInvoke(time) {
  // 当前时间距离上一次调用 debounce 的时间差
  const timeSinceLastCall = time - lastCallTime
  // 当前时间距离上一次执行 func 的时间差
  const timeSinceLastInvoke = time - lastInvokeTime

  // 下述 4 种情况返回 true
  return ( lastCallTime === undefined || 
          (timeSinceLastCall &gt;= wait) ||
          (timeSinceLastCall &lt; 0) || 
          (maxing &amp;&amp; timeSinceLastInvoke &gt;= maxWait) )
}
</code></pre>
<ol start="2">
<li>之后每隔 <code>50</code> 毫秒触发一次，每次都会执行 <code>shouldInvoke(time)</code> 函数，只有在第 <code>400</code> 毫秒时，才会满足 <code>maxing &amp;&amp; timeSinceLastInvoke &gt;= maxWait</code>，返回 <code>true</code>。</li>
</ol>
<pre><code class="language-javascript">// 计算仍需等待的时间
function remainingWait(time) {
  // 当前时间距离上一次调用 debounce 的时间差
  const timeSinceLastCall = time - lastCallTime
  // 当前时间距离上一次执行 func 的时间差
  const timeSinceLastInvoke = time - lastInvokeTime
  // 剩余等待时间
  const timeWaiting = wait - timeSinceLastCall

  // 是否设置了最大等待时间
	// 是（节流）：返回「剩余等待时间」和「距上次执行 func 的剩余等待时间」中的最小值
	// 否：返回剩余等待时间
  return maxing
    ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke)
  	: timeWaiting
}
</code></pre>
<ol start="3">
<li>但是在这之前的第 <code>200</code> 毫秒，定时器触发回调函数，执行 <code>timerExpired</code>，因为此时 <code>shouldInvoke(time)</code> 返回 <code>false</code>，所以会重新计算剩余等待时间并重启计时器，其中 <code>timeWaiting</code> 是 <code>150</code> 毫秒，<code>maxWait - timeSinceLastInvoke</code> 是 <code>200</code> 毫秒，所以计算结果是 <code>150</code> 毫秒。</li>
<li><code>150</code> 毫秒之后，即自开始之后的第 <code>350</code> 毫秒时，会重新计算时间，其中 <code>timeWaiting</code> 依旧是 <code>150</code> 毫秒，<code>maxWait - timeSinceLastInvoke</code> 是 <code>50</code> 毫秒，所以重新开启 <code>50</code> 毫秒的定时器，即在第 <code>400</code> 毫秒时触发。</li>
<li>此时会发现定时器触发的时间是第 <code>400</code> 毫秒，<code>shouldInvoke(time)</code> 中返回 <code>true</code> 的时间也是在第 <code>400</code> 毫秒，为什么要这样呢？这样会冲突吗？首先定时器剩余时间判断和 <code>shouldInvoke(time)</code> 判断中，只要有一处满足执行 <code>fn</code> 条件，就会立马执行，同时 <code>lastInvokeTime</code> 值也会发生改变，所以另一处判断就不会生效了。另外本身定时器是不精准的，所以通过 <code>Math.min(timeWaiting, maxWait - timeSinceLastInvoke)</code> 取最小值的方式来减少误差。</li>
<li>于此同时，需要在 <code>debounced</code> 入口函数添加这么一句 <code>if (timerId === undefined) {timerId = startTimer(timerExpired, wait)}</code>，避免 <code>trailingEdge</code> 执行后定时器被清空。</li>
<li>最终效果和节流是一样的，只是时间间隔变大了而已，具体效果同第一张图所示。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JavaScript——防抖和节流]]></title>
        <id>https://faded.auspicious.space/post/javascript-debounce-throttle/</id>
        <link href="https://faded.auspicious.space/post/javascript-debounce-throttle/">
        </link>
        <updated>2020-04-14T03:18:16.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p><a href="https://juejin.im/post/5b5e724af265da0f4d0d88b2">JS简单实现防抖和节流</a></p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p><a href="https://juejin.im/post/5b5e724af265da0f4d0d88b2">JS简单实现防抖和节流</a></p>
</blockquote>
<!-- more -->
<h1 id="1-防抖-debounce">1 防抖 - debounce</h1>
<p>其中一种解决方案就是每次用户停止输入后，延迟超过 500ms 时，才去搜索此时的 string，这就是防抖。</p>
<h2 id="11-原理">1.1 原理</h2>
<p>将若干个函数调用合成为一次，并在给定时间过去之后仅被调用一次。</p>
<h2 id="12-代码实现">1.2 代码实现</h2>
<pre><code class="language-javascript">function debounce(fn, delay) {
  // 维护一个 timer，用来记录当前执行函数状态
  let timer = null;

  return function() {
    // 通过 'this' 和 'arguments' 获取函数的作用域和变量
    let context = this;
    let args = arguments;
    // 清理掉正在执行的函数，并重新执行
    clearTimeout(timer);
    timer = setTimeout(function() {
      fn.apply(context, args);
    }, delay);
  }
}
let flag = 0; // 记录当前函数调用次数
// 当用户滚动时被调用的函数
function foo() {
  flag++;
  console.log('Number of calls: %d', flag);
}

// 在 debounce 中包装我们的函数，过 2 秒触发一次
document.body.addEventListener('scroll', debounce(foo, 2000));
</code></pre>
<h2 id="13-解释">1.3 解释</h2>
<ul>
<li><code>debounce</code> 函数封装后，返回内部函数。</li>
<li>每一次事件被触发，都会清除当前的 <code>timer</code> 然后重新设置超时并调用。这会导致每一次高频事件都会取消前一次的超时调用，导致事件处理程序不能被触发。</li>
<li>只有当高频事件停止，最后一次事件触发的超时调用才能在 <code>delay</code> 时间后执行。</li>
</ul>
<h1 id="2-节流-throttle">2 节流 - throttle</h1>
<p>另一种解决方案比防抖要宽松些，这时我们不想用户一味的输入，而是给用户一些搜索提示，所以在当中限制每过 500ms 就查询一次此时的 string，这就是节流。</p>
<h2 id="21-原理">2.1 原理</h2>
<p>节流函数不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数。</p>
<h2 id="22-代码实现">2.2 代码实现</h2>
<p>代码实现有两种，一种是时间戳，另一种是定时器。</p>
<h3 id="221-时间戳实现">2.2.1 时间戳实现</h3>
<pre><code class="language-javascript">function throttle(func, delay){
  let prev = Date.now();
  return function(){
    const context = this;
    const args    = arguments;
    const now     = Date.now();
    if(now - prev &gt;= delay){
      func.apply(context, args);
      prev = Date.now();
    }
  }
}
</code></pre>
<p>当高频事件触发时，第一次应该会立即执行（给事件绑定函数与真正触发事件的间隔如果大于 <code>delay</code> 的话），而后再怎么频繁触发事件，也都是会每 <code>delay</code> 秒才执行一次。而当最后一次事件触发完毕后，事件也不会再被执行了。</p>
<h3 id="222-定时器实现">2.2.2 定时器实现</h3>
<p>当触发事件的时候，我们设置一个定时器，再触发事件的时候，如果定时器存在，就不执行；直到 <code>delay</code> 秒后，定时器执行执行函数，清空定时器，这样就可以设置下个定时器。</p>
<pre><code class="language-javascript">fucntion throttle(func, delay){
  let timer = null;

  return funtion(){
    let context = this;
    let args    = arguments;
    if(!timer){
      timer = setTimeout(function(){
        func.apply(context, args);
        timer = null;
      }, delay);
    }
  }
}
</code></pre>
<p>当第一次触发事件时，肯定不会立即执行函数，而是在 delay 秒后才执行。 之后连续不断触发事件，也会每 delay 秒执行一次。 当最后一次停止触发后，由于定时器的 delay 延迟，可能还会执行一次函数。</p>
<h3 id="223-综合使用时间戳与定时器">2.2.3 综合使用时间戳与定时器</h3>
<p>完成一个事件触发时立即执行，触发完毕还能执行一次的节流函数。</p>
<pre><code class="language-javascript">function throttle(func, delay){
  let timer = null;
  let startTime = Date.now();

  return function(){
    let curTime = Date.now();
    let remaining = delay - (curTime - startTime);
    const context = this;
    const args = arguments;

    clearTimeout(timer);
    if(remaining &lt;= 0){
      func.apply(context,args);
      startTime = Date.now();
    }else{
      timer = setTimeout(func, remaining);
    }
  }
}
</code></pre>
<p>需要在每个 <code>delay</code> 时间中一定会执行一次函数，因此在节流函数内部使用开始时间、当前时间与 <code>delay</code> 来计算 <code>remaining</code>，当 <code>remaining &lt;= 0</code> 时表示该执行函数了，如果还没到时间的话就设定在 <code>remaining</code> 时间后再触发。当然在 <code>remaining</code> 这段时间中如果又一次发生事件，那么会取消当前的计时器，并重新计算一个 <code>remaining</code> 来判断当前状态。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[什么是 P 问题、NP 问题和 NPC 问题]]></title>
        <id>https://faded.auspicious.space/post/what-is-p-problem-np-problem-and-npc-problem/</id>
        <link href="https://faded.auspicious.space/post/what-is-p-problem-np-problem-and-npc-problem/">
        </link>
        <updated>2020-04-13T06:30:42.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p><a href="http://www.matrix67.com/blog/archives/105">什么是P问题、NP问题和NPC问题</a><br>
<a href="https://www.cnblogs.com/marsggbo/p/9360324.html">[转载] 什么是P问题、NP问题和NPC问题</a></p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p><a href="http://www.matrix67.com/blog/archives/105">什么是P问题、NP问题和NPC问题</a><br>
<a href="https://www.cnblogs.com/marsggbo/p/9360324.html">[转载] 什么是P问题、NP问题和NPC问题</a></p>
</blockquote>
<!-- more -->
<h1 id="1-总结">1 总结</h1>
<table>
<thead>
<tr>
<th>Problem</th>
<th>Introduction</th>
</tr>
</thead>
<tbody>
<tr>
<td>P</td>
<td>能在<strong>多项式时间</strong>里<strong>找到</strong>一个解决算法</td>
</tr>
<tr>
<td>NP</td>
<td>能在<strong>多项式时间</strong>里<strong>验证</strong>一个解是否正确</td>
</tr>
<tr>
<td>NPC</td>
<td>1. 首先必须是一个<strong>NP问题</strong> 2. 所有的NP问题都能 <strong>reduce</strong> 成该问题</td>
</tr>
<tr>
<td>NP-Hard</td>
<td>只需要<strong>满足 NPC 问题的第二个条件</strong>即可</td>
</tr>
</tbody>
</table>
<p>下面的一些说法或许是众多 OIer 最大的误区之一。</p>
<p>你会经常看到网上出现“这怎么做，这不是 NP 问题吗”、“这个只有搜了，这已经被证明是 NP 问题了”之类的话。你要知道，大多数人此时所说的 NP 问题其实都是指的 NPC 问题。他们没有搞清楚 NP 问题和 NPC 问题的概念。NP 问题并不是那种“只有搜才行”的问题，NPC 问题才是。好，行了，基本上这个误解已经被澄清了。下面的内容都是在讲什么是 P 问题，什么是 NP 问题，什么是 NPC 问题，你如果不是很感兴趣就可以不看了。接下来你可以看到，把 NP 问题当成是 NPC 问题是一个多大的错误。</p>
<h1 id="2-时间复杂度">2 时间复杂度</h1>
<p>还是先用几句话简单说明一下时间复杂度。时间复杂度并不是表示一个程序解决问题需要花多少时间，而是当问题规模扩大后，程序需要的时间长度增长得有多快。也就是说，对于高速处理数据的计算机来说，处理某一个特定数据的效率不能衡量一个程序的好坏，而应该看当这个数据的规模变大到数百倍后，程序运行时间是否还是一样，或者也跟着慢了数百倍，或者变慢了数万倍。不管数据有多大，程序处理花的时间始终是那么多的，我们就说这个程序很好，具有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 的时间复杂度，也称常数级复杂度；数据规模变得有多大，花的时间也跟着变得有多长，这个程序的时间复杂度就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，比如找 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 个数中的最大值；而像冒泡排序、插入排序等，数据扩大 2 倍，时间变慢 4 倍的，属于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 的复杂度。还有一些穷举类的算法，所需时间长度成几何阶数上涨，这就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>a</mi><mi>n</mi></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(a^n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 的指数级复杂度，甚至 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>!</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n!)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">!</span><span class="mclose">)</span></span></span></span> 的阶乘级复杂度。不会存在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>2</mn><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(2n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">2</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 的复杂度，因为前面的那个“2”是系数，根本不会影响到整个程序的时间增长。同样地，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>3</mn></msup><mo>+</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^3+n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 的复杂度也就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>3</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 的复杂度。因此，我们会说，一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>0.01</mn><mo>∗</mo><msup><mi>n</mi><mn>3</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(0.01*n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">0</span><span class="mord">.</span><span class="mord">0</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 的程序的效率比 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>100</mn><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(100n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 的效率低，尽管在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 很小的时候，前者优于后者，但后者时间随数据规模增长得慢，最终 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>3</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 的复杂度将远远超过 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。我们也说，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>100</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^{100})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 的复杂度小于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1.0</mn><msup><mn>1</mn><mi>n</mi></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1.01^n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mord">.</span><span class="mord">0</span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 的复杂度。</p>
<p>容易看出，前面的几类复杂度被分为两种级别，其中后者的复杂度无论如何都远远大于前者：一种是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>log</mi><mo>⁡</mo><mo>(</mo><mi>n</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">O(\log(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mi>a</mi></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^a)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>等，我们把它叫做多项式级的复杂度，因为它的规模 n 出现在底数的位置；另一种是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>a</mi><mi>n</mi></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(a^n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>!</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n!)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">!</span><span class="mclose">)</span></span></span></span> 型复杂度，它是非多项式级的，其复杂度计算机往往不能承受。当我们在解决一个问题时，我们选择的算法通常都需要是多项式级的复杂度，非多项式级的复杂度需要的时间太多，往往会超时，除非是数据规模非常小。</p>
<p>自然地，人们会想到一个问题：会不会所有的问题都可以找到复杂度为多项式级的算法呢？很遗憾，答案是否定的。有些问题甚至根本不可能找到一个正确的算法来，这称之为“不可解问题”(Undecidable Decision Problem)。The Halting Problem 就是一个著名的不可解问题，在我的 Blog 上有过专门的介绍和证明。再比如，输出从 1 到 n 这 n 个数的全排列。不管你用什么方法，你的复杂度都是阶乘级，因为你总得用阶乘级的时间打印出结果来。有人说，这样的“问题”不是一个“正规”的问题，正规的问题是让程序解决一个问题，输出一个“YES”或“NO”（这被称为判定性问题），或者一个什么什么的最优值（这被称为最优化问题）。那么，根据这个定义，我也能举出一个不大可能会有多项式级算法的问题来：Hamilton 回路。问题是这样的：给你一个图，问你能否找到一条经过每个顶点一次且恰好一次（不遗漏也不重复）最后又走回来的路（满足这个条件的路径叫做 Hamilton 回路）。这个问题现在还没有找到多项式级的算法。事实上，这个问题就是我们后面要说的 NPC 问题。</p>
<h1 id="3-p-问题">3 P 问题</h1>
<p>下面引入 P 类问题的概念：<strong>如果一个问题可以找到一个能在多项式的时间里解决它的算法，那么这个问题就属于 P 问题</strong>。P 是英文单词多项式的第一个字母。哪些问题是 P 类问题呢？通常 NOI 和 NOIP 不会出不属于 P 类问题的题目。我们常见到的一些信息奥赛的题目都是 P 问题。道理很简单，一个用穷举换来的非多项式级时间的超时程序不会涵盖任何有价值的算法。</p>
<h1 id="4-np-问题">4 NP 问题</h1>
<p>接下来引入 NP 问题的概念。这个就有点难理解了，或者说容易理解错误。在这里强调（回到我竭力想澄清的误区上），<strong>NP 问题不是非 P 类问题。NP 问题是指可以在多项式的时间里验证一个解的问题</strong>。NP 问题的另一个定义是，<strong>可以在多项式的时间里猜出一个解的问题</strong>。比方说，我 RP 很好，在程序中需要枚举时，我可以一猜一个准。现在某人拿到了一个求最短路径的问题，问从起点到终点是否有一条小于 100 个单位长度的路线。它根据数据画好了图，但怎么也算不出来，于是来问我：你看怎么选条路走得最少？我说，我 RP 很好，肯定能随便给你指条很短的路出来。然后我就胡乱画了几条线，说就这条吧。那人按我指的这条把权值加起来一看，嘿，神了，路径长度 98，比 100 小。于是答案出来了，存在比 100 小的路径。别人会问他这题怎么做出来的，他就可以说，因为我找到了一个比 100 小的解。在这个题中，找一个解很困难，但验证一个解很容易。验证一个解只需要 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 的时间复杂度，也就是说我可以花 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 的时间把我猜的路径的长度加出来。那么，只要我 RP 好，猜得准，我一定能在多项式的时间里解决这个问题。我猜到的方案总是最优的，不满足题意的方案也不会来骗我去选它。这就是 NP 问题。当然有不是 NP 问题的问题，即你猜到了解但是没用，因为你不能在多项式的时间里去验证它。下面我要举的例子是一个经典的例子，它指出了一个目前还没有办法在多项式的时间里验证一个解的问题。很显然，前面所说的 Hamilton 回路是 NP 问题，因为验证一条路是否恰好经过了每一个顶点非常容易。但我要把问题换成这样：试问一个图中是否不存在 Hamilton 回路。这样问题就没法在多项式的时间里进行验证了，因为除非你试过所有的路，否则你不敢断定它“没有 Hamilton 回路”。</p>
<p>之所以要定义 NP 问题，是因为通常只有 NP 问题才可能找到多项式的算法。我们不会指望一个连多项式地验证一个解都不行的问题存在一个解决它的多项式级的算法。相信读者很快明白，信息学中的号称最困难的问题——“NP 问题”，实际上是在探讨 NP 问题与 P 类问题的关系。</p>
<p>很显然，所有的 P 类问题都是 NP 问题。也就是说，能多项式地解决一个问题，必然能多项式地验证一个问题的解——既然正解都出来了，验证任意给定的解也只需要比较一下就可以了。关键是，人们想知道，是否所有的 NP 问题都是 P 类问题。我们可以再用集合的观点来说明。如果把所有 P 类问题归为一个集合 P 中，把所有 NP 问题划进另一个集合 NP 中，那么，显然有 P 属于 NP。现在，所有对 NP 问题的研究都集中在一个问题上，即究竟是否有 P=NP ？通常所谓的“NP 问题”，其实就一句话：证明或推翻 P=NP。</p>
<p>NP 问题一直都是信息学的巅峰。巅峰，意即很引人注目但难以解决。在信息学研究中，这是一个耗费了很多时间和精力也没有解决的终极问题，好比物理学中的大统一和数学中的歌德巴赫猜想等。</p>
<p>目前为止这个问题还“啃不动”。但是，一个总的趋势、一个大方向是有的。人们普遍认为，P=NP 不成立，也就是说，多数人相信，存在至少一个不可能有多项式级复杂度的算法的 NP 问题。人们如此坚信 P≠NP 是有原因的，就是在研究 NP 问题的过程中找出了一类非常特殊的 NP 问题叫做 NP-完全问题，也即所谓的 NPC 问题。C 是英文单词“完全”的第一个字母。正是 NPC 问题的存在，使人们相信 P≠NP。下文将花大量篇幅介绍 NPC 问题，你从中可以体会到 NPC 问题使 P=NP 变得多么不可思议。</p>
<h1 id="5-规约">5 规约</h1>
<p>为了说明 NPC 问题，我们先引入一个概念——约化(Reducibility，有的资料上叫“归约”)。</p>
<p>简单地说，一个问题 A 可以约化为问题 B 的含义即是，可以用问题 B 的解法解决问题 A，或者说，问题 A 可以“变成”问题 B。《算法导论》上举了这么一个例子。比如说，现在有两个问题：求解一个一元一次方程和求解一个一元二次方程。那么我们说，前者可以约化为后者，意即知道如何解一个一元二次方程那么一定能解出一元一次方程。我们可以写出两个程序分别对应两个问题，那么我们能找到一个“规则”，按照这个规则把解一元一次方程程序的输入数据变一下，用在解一元二次方程的程序上，两个程序总能得到一样的结果。这个规则即是：两个方程的对应项系数不变，一元二次方程的二次项系数为 0。按照这个规则把前一个问题转换成后一个问题，两个问题就等价了。同样地，我们可以说，Hamilton 回路可以约化为 TSP(Travelling Salesman Problem，旅行商问题)：在Hamilton 回路问题中，两点相连即这两点距离为 0，两点不直接相连则令其距离为 1，于是问题转化为在 TSP 中，是否存在一条长为 0 的路径。Hamilton 回路存在当且仅当 TSP 中存在长为 0 的回路。</p>
<p>“问题 A 可约化为问题 B”有一个重要的直观意义：B 的时间复杂度高于或者等于 A 的时间复杂度。也就是说，问题 A 不比问题 B 难。这很容易理解。既然问题 A 能用问题 B 来解决，倘若 B 的时间复杂度比 A 的时间复杂度还低了，那 A 的算法就可以改进为 B 的算法，两者的时间复杂度还是相同。正如解一元二次方程比解一元一次方程难，因为解决前者的方法可以用来解决后者。</p>
<p>很显然，约化具有一项重要的性质：约化具有传递性。如果问题 A 可约化为问题 B，问题 B 可约化为问题 C，则问题 A 一定可约化为问题 C。这个道理非常简单，就不必阐述了。</p>
<p>现在再来说一下约化的标准概念就不难理解了：如果能找到这样一个变化法则，对任意一个程序 A 的输入，都能按这个法则变换成程序 B 的输入，使两程序的输出相同，那么我们说，问题 A 可约化为问题 B。</p>
<p>当然，我们所说的“可约化”是指的可“多项式地”约化(Polynomial-time Reducible)，即变换输入的方法是能在多项式的时间里完成的。约化的过程只有用多项式的时间完成才有意义。</p>
<p>好了，从约化的定义中我们看到，一个问题约化为另一个问题，时间复杂度增加了，问题的应用范围也增大了。通过对某些问题的不断约化，我们能够不断寻找复杂度更高，但应用范围更广的算法来代替复杂度虽然低，但只能用于很小的一类问题的算法。再回想前面讲的 P 和 NP 问题，联想起约化的传递性，自然地，我们会想问，如果不断地约化上去，不断找到能“通吃”若干小 NP 问题的一个稍复杂的大 NP 问题，那么最后是否有可能找到一个时间复杂度最高，并且能“通吃”所有的 NP 问题的这样一个超级 NP 问题？答案居然是肯定的。也就是说，存在这样一个 NP 问题，所有的 NP 问题都可以约化成它。换句话说，只要解决了这个问题，那么所有的 NP 问题都解决了。这种问题的存在难以置信，并且更加不可思议的是，这种问题不只一个，它有很多个，它是一类问题。这一类问题就是传说中的 NPC 问题，也就是 NP-完全问题。NPC 问题的出现使整个 NP 问题的研究得到了飞跃式的发展。我们有理由相信，NPC 问题是最复杂的问题。再次回到全文开头，我们可以看到，人们想表达一个问题不存在多项式的高效算法时应该说它“属于 NPC 问题”。此时，我的目的终于达到了，我已经把 NP 问题和 NPC 问题区别开了。到此为止，本文已经写了近 5000 字了，我佩服你还能看到这里来，同时也佩服一下自己能写到这里来。</p>
<h1 id="6-npc-问题">6 NPC 问题</h1>
<p>NPC 问题的定义非常简单。同时满足下面两个条件的问题就是 NPC 问题。</p>
<ul>
<li>首先，<strong>它得是一个 NP 问题</strong>；</li>
<li>然后，<strong>所有的 NP 问题都可以约化到它</strong>。</li>
</ul>
<p>证明一个问题是 NPC 问题也很简单。先证明它至少是一个 NP 问题，再证明其中一个已知的 NPC 问题能约化到它（由约化的传递性，则 NPC 问题定义的第二条也得以满足；至于第一个 NPC 问题是怎么来的，下文将介绍），这样就可以说它是 NPC 问题了。</p>
<p>既然所有的 NP 问题都能约化成 NPC 问题，那么只要任意一个 NPC 问题找到了一个多项式的算法，那么所有的 NP 问题都能用这个算法解决了，NP 也就等于 P 了。因此，给 NPC 找一个多项式算法太不可思议了。因此，前文才说，“正是 NPC 问题的存在，使人们相信 P≠NP”。我们可以就此直观地理解，NPC 问题目前没有多项式的有效算法，只能用指数级甚至阶乘级复杂度的搜索。</p>
<h1 id="7-np-hard-问题">7 NP-Hard 问题</h1>
<p>顺便讲一下 NP-Hard 问题。NP-Hard 问题是这样一种问题，<strong>它满足 NPC 问题定义的第二条但不一定要满足第一条（就是说，NP-Hard 问题要比 NPC 问题的范围广）</strong>。NP-Hard 问题同样难以找到多项式的算法，但它不列入我们的研究范围，因为它不一定是 NP 问题。即使 NPC 问题发现了多项式级的算法，NP-Hard 问题有可能仍然无法得到多项式级的算法。事实上，由于 NP-Hard 放宽了限定条件，它将有可能比所有的 NPC 问题的时间复杂度更高从而更难以解决。</p>
<h1 id="8-npc-问题示例">8 NPC 问题示例</h1>
<p>不要以为 NPC 问题是一纸空谈。NPC 问题是存在的。确实有这么一个非常具体的问题属于 NPC 问题。下文即将介绍它。</p>
<p>下文即将介绍逻辑电路问题。这是第一个 NPC 问题。其它的 NPC 问题都是由这个问题约化而来的。因此，逻辑电路问题是 NPC 类问题的“鼻祖”。</p>
<p>逻辑电路问题是指的这样一个问题：给定一个逻辑电路，问是否存在一种输入使输出为 True。</p>
<p>什么叫做逻辑电路呢？一个逻辑电路由若干个输入，一个输出，若干“逻辑门”和密密麻麻的线组成。看下面一例，不需要解释你马上就明白了。</p>
<pre><code>+----------+
| Input 1  +---+
+----------+   |
               |   +----------+
               +--&gt;+          |
                   |    OR    +---+
               +--&gt;+          |   |
               |   +----------+   |    +----------+
+----------+   |                  +---&gt;+          |
| Input 2  +---+                       |    AND   +---&gt; Output
+----------+                      +---&gt;+          |
                   +----------+   |    +----------+
                   |          |   |
               +--&gt;+    NOT   +---+
               |   |          |
+----------+   |   +----------+
| Input 3  +---+
+----------+
</code></pre>
<p>这是个较简单的逻辑电路，当输入 1、输入 2、输入 3分别为 True、True、False 或 False、True、False 时，输出为True。</p>
<p>有输出无论如何都不可能为 True 的逻辑电路吗？有。下面就是一个简单的例子。</p>
<pre><code>+----------+
|  Input 1 +---+
+----------+   |
               |   +----------+
               +---+          |
                   |   AND    +---+
               +---+          |   |
               |   +----------+   |    +----------+
               |                  +---&gt;+          |
               |                       |   AND    +---&gt; Output
               |                  +---&gt;+          |
               |   +----------+   |    +----------+
               |   |          |   |
               +---+   NOT    +---+
               |   |          |
+----------+   |   +----------+
|  Input 2 +---+
+----------+

</code></pre>
<p>上面这个逻辑电路中，无论输入是什么，输出都是 False。我们就说，这个逻辑电路不存在使输出为 True 的一组输入。</p>
<p>回到上文，给定一个逻辑电路，问是否存在一种输入使输出为 True，这即逻辑电路问题。</p>
<p>逻辑电路问题属于 NPC 问题。这是有严格证明的。它显然属于 NP 问题，并且可以直接证明所有的 NP 问题都可以约化到它（不要以为 NP 问题有无穷多个将给证明造成不可逾越的困难）。证明过程相当复杂，其大概意思是说任意一个 NP 问题的输入和输出都可以转换成逻辑电路的输入和输出（想想计算机内部也不过是一些 0 和 1 的运算），因此对于一个 NP 问题来说，问题转化为了求出满足结果为 True 的一个输入（即一个可行解）。</p>
<p>有了第一个 NPC 问题后，一大堆 NPC 问题就出现了，因为再证明一个新的 NPC 问题只需要将一个已知的 NPC 问题约化到它就行了。后来，Hamilton 回路成了 NPC 问题，TSP 问题也成了 NPC 问题。现在被证明是 NPC 问题的有很多，任何一个找到了多项式算法的话所有的 NP 问题都可以完美解决了。因此说，正是因为 NPC 问题的存在，P=NP 变得难以置信。P=NP 问题还有许多有趣的东西，有待大家自己进一步的挖掘。攀登这个信息学的巅峰是我们这一代的终极目标。现在我们需要做的，至少是不要把概念弄混淆了。</p>
]]></content>
    </entry>
</feed>