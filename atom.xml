<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://faded.auspicious.space</id>
    <title>Typhoeus</title>
    <updated>2020-04-26T03:11:19.568Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://faded.auspicious.space"/>
    <link rel="self" href="https://faded.auspicious.space/atom.xml"/>
    <logo>https://faded.auspicious.space/images/avatar.png</logo>
    <icon>https://faded.auspicious.space/favicon.ico</icon>
    <rights>All rights reserved 2020, Typhoeus</rights>
    <entry>
        <title type="html"><![CDATA[漫谈《大型网站技术架构》]]></title>
        <id>https://faded.auspicious.space/post/a-random-talk-on-large-website-technical-architecture/</id>
        <link href="https://faded.auspicious.space/post/a-random-talk-on-large-website-technical-architecture/">
        </link>
        <updated>2020-04-25T04:13:45.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p><a href="https://www.jianshu.com/p/9cf3ff1ecb88">漫谈《大型网站技术架构》</a></p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p><a href="https://www.jianshu.com/p/9cf3ff1ecb88">漫谈《大型网站技术架构》</a></p>
</blockquote>
<!-- more -->
<h1 id="一-大型网站的架构演化">一、大型网站的架构演化</h1>
<h2 id="11-大型网站软件的特点">1.1 大型网站软件的特点</h2>
<ul>
<li>高并发、大流量</li>
<li>高可用：系统7*24小时不间断提供服务</li>
<li>海量数据</li>
<li>用户分布广泛</li>
<li>安全环境恶劣</li>
<li>需求变更快，发布频繁</li>
<li>渐进式发展</li>
</ul>
<h2 id="12-大型网站架构演化发展历程">1.2 大型网站架构演化发展历程</h2>
<ul>
<li><strong>初始阶段的网站架构</strong>：一台服务器，上面同时拥有应用程序，数据库，文件，等所有资源。例如 LAMP 架构。</li>
<li><strong>应用和数据服务分离</strong>：三台服务器（硬件资源各不相同），分别是应用服务器，文件服务器和数据库服务器。</li>
<li><strong>使用缓存改善网站性能</strong>：分为两种，缓存在应用服务器上的本地缓存和缓存在专门的分布式缓存服务器的远程缓存。</li>
<li><strong>使用应用服务器集群改善网站并发处理能力</strong>：通过负载均衡调度服务器来将访问请求分发到应用服务器集群中的任何一台机器。</li>
<li><strong>数据库读写分离</strong>：数据库采用主从热备，应用服务器在写数据时访问主数据库，主数据库通过主从复制机制将数据更新同步到从数据库。应用服务器使用专门的数据访问模块从而对应用透明。</li>
<li><strong>使用反向代理和 CDN 加速网站响应</strong>：这两者基本原理都是缓存。反向代理部署在网站的中心机房，CDN 部署在网络提供商的机房。</li>
<li><strong>使用分布式文件系统和分布式数据库系统</strong>：数据库拆分的最后手段，更常用的是业务分库。</li>
<li><strong>使用 NoSQL 和搜索引擎</strong>：对可伸缩的分布式有更好的支持。</li>
<li><strong>业务拆分</strong>：将整个网站业务拆分成不同的应用，每个应用独立部署维护，应用之间通过超链接建立联系/消息队列进行数据分发/访问同一数据存储系统。</li>
<li><strong>分布式服务</strong>：公共业务提取出来独立部署。</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://faded.auspicious.space/post-images/1587788408370.png" alt="架构设计_分布式服务" loading="lazy"></figure>
<h2 id="13-大型网站架构演化的价值观">1.3 大型网站架构演化的价值观</h2>
<ul>
<li>大型网站架构的核心价值是随网站所需灵活应对。</li>
<li>驱动大型网站技术发展的主要力量是网站的业务发展。</li>
</ul>
<h2 id="14-网站架构设计误区">1.4 网站架构设计误区</h2>
<ul>
<li>一味追随大公司的解决方案。</li>
<li>为了技术而技术。</li>
<li>企图用技术解决所有问题。</li>
</ul>
<h1 id="二-大型网站架构模式">二、大型网站架构模式</h1>
<h2 id="21-网站架构模式">2.1 网站架构模式</h2>
<ul>
<li>分层<br>
-分割<br>
-分布式
<ul>
<li>分布式应用和服务</li>
<li>分布式静态资源</li>
<li>分布式数据和存储</li>
<li>分布式计算</li>
</ul>
</li>
<li>集群</li>
<li>缓存
<ul>
<li>CDN</li>
<li>反向代理</li>
<li>本地缓存</li>
<li>分布式缓存</li>
</ul>
</li>
<li>异步
<ul>
<li>提供系统可用性</li>
<li>加快网站响应速度</li>
<li>消除高并发访问高峰</li>
</ul>
</li>
<li>冗余
<ul>
<li>服务器冗余运行</li>
<li>数据库冗余备份</li>
</ul>
</li>
<li>自动化</li>
<li>安全
<ul>
<li>防止 XSS 攻击</li>
<li>SQL 注入</li>
</ul>
</li>
</ul>
<h1 id="三-大型网站核心架构要素">三、大型网站核心架构要素</h1>
<ul>
<li>性能</li>
<li>可用性</li>
<li>伸缩性：不断地向服务器集群加服务器</li>
<li>扩张性</li>
</ul>
<h1 id="四-瞬时响应网站的高性能架构">四、瞬时响应：网站的高性能架构</h1>
<h2 id="41-网站性能测试">4.1 网站性能测试</h2>
<ul>
<li>不同视角下网站的性能
<ul>
<li>用户视角网站性能 响应时间</li>
<li>开发人员视角的网站性能 响应时间、并发量</li>
<li>运维人员视角的网站性能 资源</li>
</ul>
</li>
<li>性能测试指标
<ul>
<li>响应时间</li>
<li>并发数</li>
<li>吞吐量 qps tps hps</li>
<li>性能计数器</li>
</ul>
</li>
<li>性能测试方法
<ul>
<li>性能测试</li>
<li>负载测试</li>
<li>压力测试</li>
<li>稳定性测试</li>
</ul>
</li>
<li>性能测试报告</li>
<li>性能优化策略
<ul>
<li>性能分析</li>
<li>性能优化</li>
</ul>
</li>
</ul>
<h2 id="42-web-前端性能优化">4.2 Web 前端性能优化</h2>
<ul>
<li>浏览器访问优化
<ul>
<li>减少 HTTP 请求</li>
<li>使用浏览器缓存</li>
<li>启用压缩</li>
<li>CSS 放在网页最上面 JS 最下面</li>
<li>减少 Cookie 传输</li>
</ul>
</li>
<li>CDN 加速。（Content Delivery Network)</li>
<li>反向代理</li>
</ul>
<h2 id="43-应用服务器性能优化">4.3 应用服务器性能优化</h2>
<ul>
<li>分布式缓存
<ul>
<li>缓存的基本原理</li>
<li>合理的使用缓存
<ul>
<li>频繁修改数据</li>
<li>没有热点的访问</li>
<li>数据不一致与脏读</li>
<li>缓存可用性</li>
<li>缓存预热</li>
<li>缓存穿透 缓存不存在，直接访问数据库</li>
</ul>
</li>
<li>分布式缓存架构</li>
<li>Memcached</li>
</ul>
</li>
<li>异步操作</li>
<li>使用集群</li>
<li>代码优化
<ul>
<li>多线程</li>
<li>资源复用</li>
<li>数据结构</li>
<li>垃圾回收</li>
</ul>
</li>
</ul>
<h2 id="44-存储性能优化">4.4 存储性能优化</h2>
<ul>
<li>机械硬盘 vs. 固态硬盘</li>
<li>B+ 树 vs. LSM 树</li>
<li>RAID vs. HDFS</li>
</ul>
<h1 id="五-万无一失网站的高可用架构">五、万无一失：网站的高可用架构</h1>
<h2 id="51-网站可用性的度量和考核">5.1 网站可用性的度量和考核</h2>
<ul>
<li>网站可行性度量</li>
<li>网站可用性考核</li>
</ul>
<h2 id="52-高可用的网站架构">5.2 高可用的网站架构</h2>
<h2 id="53-高可用的应用">5.3 高可用的应用</h2>
<ul>
<li>通过负载均衡进行无状态服务的失效转移</li>
<li>应用服务器集群的 Session 管理
<ul>
<li>Session复制</li>
<li>Session绑定</li>
<li>利用 Cookie 记录 Session</li>
<li>Session服务器</li>
</ul>
</li>
</ul>
<h2 id="54-高可用的应用">5.4 高可用的应用</h2>
<ul>
<li>分级管理</li>
<li>超时设置</li>
<li>异步调用</li>
<li>服务降级 随机拒绝访问（twitter)</li>
<li>幂等性设计</li>
</ul>
<h2 id="55-高可用的数据">5.5 高可用的数据</h2>
<ul>
<li>CAP 原理
<ul>
<li>数据持久性</li>
<li>数据可访问性</li>
<li>数据一致性
<ul>
<li>数据强一致性</li>
<li>数据用户一致性</li>
<li>数据最终一致性</li>
</ul>
</li>
<li>数据备份</li>
<li>失效转移
<ul>
<li>失效确认</li>
<li>访问转移</li>
<li>数据恢复</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="56-高可用软件质量保障">5.6 高可用软件质量保障</h2>
<ul>
<li>网站发布</li>
<li>自动化测试</li>
<li>预发布验证</li>
<li>代码控制
<ul>
<li>主干开发，分支发布</li>
<li>分支开发，主干发布</li>
</ul>
</li>
<li>自动化发布</li>
<li>灰度发布</li>
</ul>
<h2 id="57-网站运行监控">5.7 网站运行监控</h2>
<ul>
<li>监控数据采集
<ul>
<li>用户行为日志收集</li>
<li>服务器性能检测</li>
<li>运行数据报告</li>
</ul>
</li>
<li>监控管理
<ul>
<li>系统报警</li>
<li>失效转移</li>
<li>自动优雅降级</li>
</ul>
</li>
</ul>
<h1 id="六-永无止尽网站的伸缩性架构">六、永无止尽：网站的伸缩性架构</h1>
<h2 id="61-网站伸缩性设计">6.1 网站伸缩性设计</h2>
<ul>
<li>不同功能进行物理分离实现伸缩</li>
<li>单一功能通过集群实现伸缩</li>
</ul>
<h2 id="62-应用服务器集群伸缩设计">6.2 应用服务器集群伸缩设计</h2>
<ul>
<li>HTTP 重定向负载均衡</li>
<li>DNS 域名解析负载均衡</li>
<li>反向代理负载均衡</li>
<li>IP 负载均衡</li>
<li>数据链路层负载均衡</li>
<li>负载均衡算法
<ul>
<li>轮询</li>
<li>加权轮询</li>
<li>随机</li>
<li>最少链接</li>
<li>原地址散列</li>
</ul>
</li>
</ul>
<h2 id="63-分布式缓存集群的伸缩性设计">6.3 分布式缓存集群的伸缩性设计</h2>
<ul>
<li>Memcached 分布式缓存集群的访问模型</li>
<li>Memcached 分布式缓存集群的伸缩性挑战</li>
<li>分布式缓存的一致性 hash 算法</li>
</ul>
<h2 id="64-数据存储服务器集群的伸缩性设计">6.4 数据存储服务器集群的伸缩性设计</h2>
<ul>
<li>关系数据库集群的伸缩性设计</li>
<li>NoSQL 数据库的伸缩性设计</li>
</ul>
<h1 id="七-随机应变网站的可扩展性架构">七、随机应变：网站的可扩展性架构</h1>
<h2 id="71-构建可扩展性的网站架构">7.1 构建可扩展性的网站架构</h2>
<h2 id="72-利用分布式消息队列降低系统耦合性">7.2 利用分布式消息队列降低系统耦合性</h2>
<ul>
<li>事件驱动架构</li>
<li>分布式消息队列</li>
</ul>
<h2 id="73-利用分布式服务打造可复用的业务平台">7.3 利用分布式服务打造可复用的业务平台</h2>
<ul>
<li>Web Service 与企业级分布式服务</li>
<li>大型网站分布式服务的需求与特点
<ul>
<li>负载均衡</li>
<li>失效转移</li>
<li>高效的远程通信</li>
<li>整合异构系统</li>
<li>对应用最少侵入</li>
<li>版本控制</li>
<li>实时监控</li>
</ul>
</li>
<li>分布式服务框架设计</li>
</ul>
<h2 id="74-可扩展的数据结构">7.4 可扩展的数据结构</h2>
<h2 id="75-利用开放平台建设网站生态圈">7.5 利用开放平台建设网站生态圈</h2>
<ul>
<li>API 接口</li>
<li>协议转移</li>
<li>安全</li>
<li>审计</li>
<li>路由</li>
<li>流程</li>
</ul>
<h1 id="八-固若金汤网站的安全架构">八、固若金汤：网站的安全架构</h1>
<h2 id="81-道高一尺魔高一丈的网站应用攻击与防御">8.1 道高一尺魔高一丈的网站应用攻击与防御</h2>
<ul>
<li>xss攻击
<ul>
<li>消毒</li>
<li>HTTP Only</li>
</ul>
</li>
<li>注入攻击
<ul>
<li>开源</li>
<li>错误回显</li>
<li>盲注</li>
<li>消毒</li>
<li>参数绑定</li>
</ul>
</li>
<li>CSRF 攻击
<ul>
<li>表单token</li>
<li>验证码</li>
<li>Referer Check</li>
</ul>
</li>
<li>其他攻击和漏洞
<ul>
<li>Error Code</li>
<li>HTML 注释</li>
<li>文件上传</li>
<li>路径遍历</li>
</ul>
</li>
<li>Web 应用防火墙</li>
<li>网站安全漏洞扫描</li>
</ul>
<h2 id="82-信息加密技术及密钥安全管理">8.2 信息加密技术及密钥安全管理</h2>
<ul>
<li>单向散列加密</li>
<li>对称加密</li>
<li>非对称加密</li>
<li>密钥安全管理</li>
</ul>
<h2 id="83-信息过滤与反垃圾">8.3 信息过滤与反垃圾</h2>
<ul>
<li>文本匹配</li>
<li>分类算法</li>
<li>黑名单</li>
</ul>
<h2 id="84-电子商务风险控制">8.4 电子商务风险控制</h2>
<ul>
<li>风险
<ul>
<li>账号风险</li>
<li>买家风险</li>
<li>卖家风险</li>
<li>交易风险</li>
</ul>
</li>
<li>风控
<ul>
<li>规则引擎</li>
<li>统计模型</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[UML—简介]]></title>
        <id>https://faded.auspicious.space/post/uml-introduction/</id>
        <link href="https://faded.auspicious.space/post/uml-introduction/">
        </link>
        <updated>2020-04-25T02:48:03.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p><a href="https://www.jianshu.com/p/7e7a03de6d21">uml学习</a></p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p><a href="https://www.jianshu.com/p/7e7a03de6d21">uml学习</a></p>
</blockquote>
<!-- more -->
<h1 id="概念">概念</h1>
<ol>
<li><strong>类（Class）</strong>：使用三层矩形框表示。
<ul>
<li>第一层显示类的名称，如果是抽象类，则就用斜体显示。</li>
<li>第二层是字段和属性。</li>
<li>第三层是类的方法。<br>
注意前面的符号，<code>+</code> 表示 <code>public</code>，<code>-</code> 表示 <code>private</code>，<code>#</code> 表示 <code>protected</code>。</li>
</ul>
</li>
<li><strong>接口</strong>：使用两层矩形框表示，与类图的区别主要是顶端有 <code>&lt;&gt;</code> 显示 。
<ul>
<li>第一行是接口名称。</li>
<li>第二行是接口方法。</li>
</ul>
</li>
<li><strong>继承类（extends）</strong>：用空心三角形 + 实线来表示。</li>
<li><strong>实现接口（implements）</strong>：用空心三角形 + 虚线来表示。</li>
<li><strong>关联（Association）</strong>：用实线箭头来表示，例如：燕子与气候。</li>
<li><strong>聚合（Aggregation）</strong>：用空心的菱形 + 实线箭头来表示。<br>
聚合：表示一种弱的‘拥有’关系，体现的是 A 对象可以包含 B 对象，但 B 对象不是 A 对象的一部分，例如：公司和员工。</li>
<li><strong>组合（Composition）</strong>：用实心的菱形 + 实线箭头来表示。<br>
组合：部分和整体的关系，并且生命周期是相同的。例如：人与手。</li>
<li><strong>依赖（Dependency）</strong>：用虚线箭头来表示，例如：动物与氧气。</li>
<li><strong>基数</strong> ：连线两端的数字表明这一端的类可以有几个实例，比如：一个鸟应该有两只翅膀。如果一个类可能有无数个实例，则就用‘n’来表示。关联、聚合、组合是有基数的。</li>
</ol>
<h1 id="类之间的关系">类之间的关系</h1>
<p>UML 把类之间的关系分为以下 5 种：</p>
<ul>
<li><strong>关联</strong>：类 A 与类 B 的实例之间存在特定的对应关系；</li>
<li><strong>依赖</strong>：类 A 访问类 B 提供的服务；</li>
<li><strong>聚集</strong>：类 A 为整体类，类 B 为局部类，类 A 的对象由类 B 的对象组合而成；</li>
<li><strong>泛化</strong>：类 A 继承类 B；</li>
<li><strong>实现</strong>：类 A 实现了 B 接口</li>
</ul>
<h2 id="关联association">关联（Association）</h2>
<p>关联指的是类之间的特定对应关系，在 UML 中用带实线的箭头表示。按照类之间的数量对比，关联可以分为以下三种：</p>
<ul>
<li>一对一关联；</li>
<li>一对多关联；</li>
<li>多对多关联。</li>
</ul>
<p>注意：关联还要以分为<strong>单向关联</strong>和<strong>双向关联</strong>。</p>
<h2 id="依赖dependency">依赖（Dependency）</h2>
<p>依赖指的是类之间的调用关系，在 UML 中用带虚线的箭头表示。如果类 A 访问类 B 的属性或者方法，  或者类 A 负责实例化类 B，那么可以说类 A 依赖类 B。和关联关系不同，无须在类 A 中定义类 B 类型的属性。</p>
<h2 id="聚集aggregation">聚集（Aggregation）</h2>
<p>聚集指的是整体与部分之间的关系，在 UML 中用带实线的菱形箭头表示。</p>
<p>聚集关系还可以分为两种类型：</p>
<ul>
<li>被聚集的子系统允许被拆卸和替换，这是普通聚集关系。</li>
<li>被聚集的子系统不允许被拆卸和替换，这种聚集称为强聚集关系，或者组成关系。</li>
</ul>
<p>注：强聚集（组成）可用带实线的实心菱形箭头表示。</p>
<h2 id="泛化generalization">泛化（Generalization）</h2>
<p>泛化指的是类之间的继承关系，在 UML 中用带实线的三角形箭头表示。</p>
<h2 id="实现realization">实现（Realization）</h2>
<p>实现指的是类与接口之间的关系，在 UML 中用带虚线的三角形箭头表示。</p>
<ol>
<li><img src="https://faded.auspicious.space/post-images/1587783886562.png" alt="" loading="lazy"></li>
<li><img src="https://faded.auspicious.space/post-images/1587783928940.png" alt="" loading="lazy"></li>
<li><img src="https://faded.auspicious.space/post-images/1587783950528.png" alt="" loading="lazy"></li>
<li><img src="https://faded.auspicious.space/post-images/1587783975197.png" alt="" loading="lazy"></li>
<li><img src="https://faded.auspicious.space/post-images/1587783994785.png" alt="" loading="lazy"></li>
<li><img src="https://faded.auspicious.space/post-images/1587784018076.png" alt="" loading="lazy"></li>
<li><img src="https://faded.auspicious.space/post-images/1587784045445.png" alt="" loading="lazy"></li>
<li><img src="https://faded.auspicious.space/post-images/1587784066892.png" alt="" loading="lazy"></li>
<li><img src="https://faded.auspicious.space/post-images/1587784111857.png" alt="" loading="lazy"></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[现代 IM 系统中消息推送和存储架构的实现]]></title>
        <id>https://faded.auspicious.space/post/implementation-of-message-push-and-storage-architecture-in-modern-im-system/</id>
        <link href="https://faded.auspicious.space/post/implementation-of-message-push-and-storage-architecture-in-modern-im-system/">
        </link>
        <updated>2020-04-25T01:44:47.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p><a href="https://www.jianshu.com/p/6a5e7611435d">现代IM系统中消息推送和存储架构的实现</a></p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p><a href="https://www.jianshu.com/p/6a5e7611435d">现代IM系统中消息推送和存储架构的实现</a></p>
</blockquote>
<!-- more -->
<h1 id="前言">前言</h1>
<p>IM 全称是“Instant Messaging”，中文名是即时通讯。在这个高度信息化的移动互联网时代，生活中 IM 类产品已经成为必备品，比较有名的如钉钉、微信、QQ 等以 IM 为核心功能的产品。当然目前微信已经成长为一个生态型产品，但其核心功能还是 IM。还有一些非以 IM 系统为核心的应用，最典型的如一些在线游戏、社交应用，IM 也是其重要的功能模块。可以说，带有社交属性的应用，IM 功能一定是必不可少的。</p>
<p>IM 系统在互联网初期即存在，其基础技术架构在这十几年的发展中更新迭代多次，从早期的 CS、P2P 架构，到现在后台已经演变为一个复杂的分布式系统，涉及移动端、网络、安全和存储等技术的方方面面。其支撑的规模也从早期的少量日活，到现在微信这个巨头最新公布的达到 9 亿的日活的体量。</p>
<p>IM 系统中最核心的部分是消息系统，消息系统中最核心的功能是消息的同步和存储：</p>
<ul>
<li><strong>消息的同步</strong>：将消息完整的、快速的从发送方传递到接收方，就是消息的同步。消息同步系统最重要的衡量指标就是消息传递的实时性、完整性以及能支撑的消息规模。从功能上来说，一般至少要支持在线和离线推送，高级的 IM 系统还支持“<strong>多端同步</strong>”。</li>
<li><strong>消息的存储</strong>：消息存储即消息的持久化保存，这里不是指消息在客户端本地的保存，而是指云端的保存，功能上对应的就是“<strong>消息漫游</strong>”。“<strong>消息漫游</strong>”的好处是可以实现账号在任意端登陆查看所有历史消息，这也是高级 IM 系统特有的功能之一。</li>
</ul>
<p>本篇文章内容主要涉及 IM 系统中的消息系统架构，会介绍一种基于 TableStore 构建的消息同步以及存储系统的架构实现，能够支持消息系统中的高级特性“<strong>多端同步</strong>”以及“<strong>消息漫游</strong>”。在性能和规模上，能够做到全量消息云端存储，百万 TPS 以及毫秒级延迟的消息同步能力。</p>
<h1 id="架构设计">架构设计</h1>
<p>本章主要会介绍基于 TableStore 的现代 IM 消息系统的架构设计，在详细介绍架构设计之前，会先介绍一种 Timeline 逻辑模型，来抽象和简化对 IM 消息同步和存储模型的理解。理解了 Timeline 模型后，会介绍如何基于此模型对消息的同步以及存储进行建模。基于 Timeline 模型，在实现消息同步和存储时还会有各方面的技术权衡，例如如何对消息同步常见的读扩散和写扩散两种模型进行对比和选择，以及针对 Timeline 模型的特征如何来选择底层数据库。</p>
<h2 id="传统架构-vs-现代架构">传统架构 vs 现代架构</h2>
<figure data-type="image" tabindex="1"><img src="https://faded.auspicious.space/post-images/1587779925317.png" alt="消息系统传统架构与现代架构的简单对比" loading="lazy"></figure>
<p>传统架构下，消息是先同步后存储。对于在线的用户，消息会直接实时同步到在线的接收方，消息同步成功后，并不会进行持久化。而对于离线的用户或者消息无法实时同步成功时，消息会持久化到离线库，当接收方重新连接后，会从离线库拉取所有未读消息。当离线库中的消息成功同步到接收方后，消息会从离线库中删除。传统的消息系统，服务端的主要工作是维护发送方和接收方的连接状态，并提供在线消息同步和离线消息缓存的能力，保证消息一定能够从发送方传递到接收方。服务端不会对消息进行持久化，所以也无法支持消息漫游。</p>
<p>现代架构下，消息是先存储后同步。先存储后同步的好处是，如果接收方确认接收到了消息，那这条消息一定是已经在云端保存了。并且消息会有两个库来保存，一个是消息存储库，用于全量保存所有会话的消息，主要用于支持消息漫游。另一个是消息同步库，主要用于接收方的多端同步。消息从发送方发出后，经过服务端转发，服务端会先将消息保存到消息存储库，后保存到消息同步库。完成消息的持久化保存后，对于在线的接收方，会直接选择在线推送。但在线推送并不是一个必须路径，只是一个更优的消息传递路径。对于在线推送失败或者离线的接收方，会有另外一个统一的消息同步方式。接收方会主动的向服务端拉取所有未同步消息，但接收方何时来同步以及会在哪些端来同步消息对服务端来说是未知的，所以要求服务端必须保存所有需要同步到接收方的消息，这是消息同步库的主要作用。对于新的同步设备，会有消息漫游的需求，这是消息存储库的主要作用，在消息存储库中，可以拉取任意会话的全量历史消息。</p>
<p>以上是传统架构和现代架构的一个简单的对比，现代架构上整个消息的同步和存储流程，并没有变复杂太多，但是其能实现多端同步以及消息漫游。现代架构中最核心的就是两个消息库“<strong>消息同步库</strong>”和“<strong>消息存储库</strong>”，是消息同步和存储最核心的基础。而本篇文章接下来的部分，都是围绕这两个库的设计和实现来展开。</p>
<h2 id="timeline-模型">Timeline 模型</h2>
<p>在分析“<strong>消息同步库</strong>”和“<strong>消息存储库</strong>”的设计和实现之前，在本章会先介绍一个逻辑模型——Timeline。Timeline 模型会帮助我们简化对消息同步和存储模型的理解，而消息库的设计和实现也是围绕 Timeline 的特性和需求来展开。</p>
<figure data-type="image" tabindex="2"><img src="https://faded.auspicious.space/post-images/1587781148322.png" alt="" loading="lazy"></figure>
<p>如图是 Timeline 模型的一个抽象表述，Timeline 可以简单理解为是一个消息队列，但这个消息队列有如下特性：</p>
<ul>
<li>每个消息拥有一个顺序 ID（SeqId），在队列后面的消息的 SeqId 一定比前面的消息的 SeqId 大，也就是保证 SeqId 一定是增长的，但是不要求严格递增。</li>
<li>新的消息永远在尾部添加，保证新的消息的 SeqId 永远比已经存在队列中的消息都大。</li>
<li>可根据 SeqId 随机定位到具体的某条消息进行读取，也可以任意读取某个给定范围内的所有消息。</li>
</ul>
<p>有了这些特性后，消息的同步可以拿 Timeline 来很简单的实现。图中的例子中，消息发送方是 A，消息接收方是 B，同时 B 存在多个接收端，分别是 B1、B2 和 B3。A 向 B 发送消息，消息需要同步到 B 的多个端，待同步的消息通过一个 Timeline 来进行交换。A 向 B 发送的所有消息，都会保存在这个 Timeline 中，B 的每个接收端都是独立的从这个 Timeline 中拉取消息。每个接收端同步完毕后，都会在本地记录下最新同步到的消息的 SeqId，即最新的一个位点，作为下次消息同步的起始位点。服务端不会保存各个端的同步状态，各个端均可以在任意时间从任意点开始拉取消息。</p>
<p>消息漫游也是基于 Timeline，和消息同步唯一的区别是，消息漫游要求服务端能够对 Timeline 内的所有数据进行持久化。</p>
<p>基于 Timeline，从逻辑模型上能够很简单的理解在服务端如何去实现消息同步和存储，并支持多端同步和消息漫游这些高级功能。落地到实现的难点主要在如何将逻辑模型映射到物理模型，Timeline 的实现对数据库会有哪些要求？我们应该选择何种数据库去实现？这些是接下来会讨论到的问题。</p>
<h2 id="消息存储模型">消息存储模型</h2>
<p><img src="https://faded.auspicious.space/post-images/1587781324683.png" alt="" loading="lazy"><br>
如图是基于 Timeline 的消息存储模型，消息存储要求每个会话都对应一个独立的 Timeline。如图例子所示，A 与 B/C/D/E/F 均发生了会话，每个会话对应一个独立的 Timeline，每个 Timeline 内存有这个会话中的所有消息，服务端会对每个 Timeline 进行持久化。服务端能够对所有会话 Timeline 中的全量消息进行持久化，也就拥有了消息漫游的能力。</p>
<h2 id="消息同步模型">消息同步模型</h2>
<p>消息同步模型会比消息存储模型稍复杂一些，消息的同步一般有读扩散和写扩散两种不同的方式，分别对应不同的 Timeline 物理模型。<br>
<img src="https://faded.auspicious.space/post-images/1587781412550.png" alt="" loading="lazy"></p>
<p>如图是读扩散和写扩散两种不同同步模式下对应的不同的 Timeline 模型，按图中的示例，A 作为消息接收者，其与 B/C/D/E/F 发生了会话，每个会话中的新的消息都需要同步到 A 的某个端，看下读扩散和写扩散两种模式下消息如何做同步。</p>
<h3 id="读扩散">读扩散</h3>
<p>消息存储模型中，每个会话的 Timeline 中保存了这个会话的全量消息。读扩散的消息同步模式下，每个会话中产生的新的消息，只需要写一次到其用于存储的 Timeline 中，接收端从这个 Timeline 中拉取新的消息。优点是消息只需要写一次，相比写扩散的模式，能够大大降低消息写入次数，特别是在群消息这种场景下。但其缺点也比较明显，接收端去同步消息的逻辑会相对复杂和低效。接收端需要对每个会话都拉取一次才能获取全部消息，读被大大的放大，并且会产生很多无效的读，因为并不是每个会话都会有新消息产生。</p>
<h3 id="写扩散">写扩散</h3>
<p>写扩散的消息同步模式，需要有一个额外的 Timeline 来专门用于消息同步，通常是每个接收端都会拥有一个独立的同步 Timeline，用于存放需要向这个接收端同步的所有消息。每个会话中的消息，会产生多次写，除了写入用于消息存储的会话 Timeline，还需要写入需要同步到的接收端的同步 Timeline。在个人与个人的会话中，消息会被额外写两次，除了写入这个会话的存储 Timeline，还需要写入参与这个会话的两个接收者的同步 Timeline。而在群这个场景下，写入会被更加的放大，如果这个群拥有 N 个参与者，那每条消息都需要额外的写 N 次。写扩散同步模式的优点是，在接收端消息同步逻辑会非常简单，只需要从其同步 Timeline 中读取一次即可，大大降低了消息同步所需的读的压力。其缺点就是消息写入会被放大，特别是针对群这种场景。</p>
<p>在 IM 这种应用场景下，通常会选择写扩散这种消息同步模式。IM 场景下，一条消息只会产生一次，但是会被读取多次，是典型的读多写少的场景，消息的读写比例大概是 10:1。若使用读扩散同步模式，整个系统的读写比例会被放大到 100:1。一个优化的好的系统，必须从设计上去平衡这种读写压力，避免读或写任意一维触碰到天花板。所以 IM 系统这类场景下，通常会应用写扩散这种同步模式，来平衡读和写，将 100:1 的读写比例平衡到 30:30。当然写扩散这种同步模式，还需要处理一些极端场景，例如万人大群。针对这种极端写扩散的场景，会退化到使用读扩散。一个简单的 IM 系统，通常会在产品层面限制这种大群的存在，而对于一个高级的 IM 系统，会采用读写扩散混合的同步模式，来满足这类产品的需求。</p>
<h2 id="消息库设计">消息库设计</h2>
<p>基于 Timeline 模型，以及 Timeline 模型在消息存储和消息同步的应用，我们看下消息同步库和消息存储库的设计。<br>
<img src="https://faded.auspicious.space/post-images/1587781931258.png" alt="" loading="lazy"><br>
如图是基于Timeline的消息库设计。</p>
<h3 id="消息同步库">消息同步库</h3>
<p>消息同步库用于存储所有用于消息同步的 Timeline，每个 Timeline 对应一个接收端，主要用作写扩散模式的消息同步。这个库不需要永久保留所有需要同步的消息，因为消息在同步到所有端后其生命周期就可以结束，就可以被回收。但是如前面所介绍的，一个实现简单的多端同步消息系统，在服务端不会保存有所有端的同步状态，而是依赖端自己主动来做同步。所以服务端不知道消息何时可以回收，通常的做法是为这个库里的消息设定一个固定的生命周期，例如一周或者一个月，生命周期结束可被淘汰。</p>
<h3 id="消息存储库">消息存储库</h3>
<p>消息存储库用于存储所有会话的 Timeline，每个 Timeline 包含了一个会话中的所有消息。这个库主要用于消息漫游时拉取某个会话的所有历史消息，也用于读扩散模式的消息同步。</p>
<p>消息同步库和消息存储库，对数据库有不同的要求，如何对数据库做选型，在下面会讨论。</p>
<h2 id="数据库选型">数据库选型</h2>
<p>消息系统最核心的两个库是消息同步库和消息存储库，两个库对数据库有不同的要求：</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">消息同步库</th>
<th style="text-align:center">消息存储库</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>数据模型</strong></td>
<td style="text-align:center">Timeline 模型</td>
<td style="text-align:center">Timeline 模型</td>
</tr>
<tr>
<td style="text-align:center"><strong>写能力</strong></td>
<td style="text-align:center">高并发写，十万级 TPS</td>
<td style="text-align:center">高并发写，少量读，万级 TPS</td>
</tr>
<tr>
<td style="text-align:center"><strong>读能力</strong></td>
<td style="text-align:center">高并发范围读，十万级 TPS</td>
<td style="text-align:center">少量范围读，千级 TPS</td>
</tr>
<tr>
<td style="text-align:center"><strong>存储规模</strong></td>
<td style="text-align:center">保存一段时间内的同步消息，TB 级，保留千万级的 Timeline 规模</td>
<td style="text-align:center">保存全量消息，百 TB 级，保留亿级的 Timeline 规模</td>
</tr>
</tbody>
</table>
<p>总结下来，对数据库的要求有如下几点：</p>
<ul>
<li>表结构设计能够满足 Timeline 模型的功能要求：不要求关系模型，能够实现队列模型，并能够支持生成自增的 SeqId。</li>
<li>能够支持高并发写和范围读，规模在十万级TPS。</li>
<li>能够保存海量数据，百TB级。</li>
<li>能够为数据定义生命周期。</li>
</ul>
<p>阿里云表格存储（TableStore）是基于 LSM 存储引擎的分布式 NoSQL 数据库，支持百万 TPS 高并发读写，PB 级数据存储，数据支持 TTL，能够很好的满足以上需求，并且支持自增列，能够非常完美的设计和实现 Timeline 的物理模型。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Meta 标签设置]]></title>
        <id>https://faded.auspicious.space/post/meta-tag-configuration/</id>
        <link href="https://faded.auspicious.space/post/meta-tag-configuration/">
        </link>
        <updated>2020-04-25T01:37:05.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p><a href="https://www.jianshu.com/p/602e0a469255">meta标签设置</a></p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p><a href="https://www.jianshu.com/p/602e0a469255">meta标签设置</a></p>
</blockquote>
<!-- more -->
<p>meta 标签常用设置：</p>
<pre><code class="language-html">&lt;!-- 根据浏览器的屏幕大小自适应的展现合适的效果 --&gt;
&lt;meta name=&quot;applicable-device&quot; content=&quot;pc,mobile&quot; /&gt;

&lt;!-- 移动端 浏览器中页面将以原始大小显示，不允许缩放 --&gt;
&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no&quot; /&gt;

&lt;!--自动选择更好的浏览器--&gt;
&lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt;
//告诉浏览器这个网址应该用哪个内核渲染，那么浏览器就会在读取到这个标签后，立即切换对应的内核

&lt;!-- 优先使用 IE 最新版本和 Chrome --&gt;
&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot; /&gt;
//它必须显示在网页中除 title 元素和其他 meta 元素以外的所有其他元素之前。如果不是的话，它不起作用

&lt;!-- 描述文档类型 content表示文档类型，这里为text/html，如果JS就是text/javascript，charset表示页面字符集 --&gt;
&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;

&lt;!-- iphone会把一串数字识别为电话号码，点击的时候会提示是否呼叫，屏蔽这功能则把telephone设置为no --&gt;
&lt;meta content=&quot;telephone=no&quot; name=&quot;format-detection&quot; /&gt;

&lt;!-- iphone的私有标签，默认值为default（白色），可以定为black（黑色）和black-translucent（灰色半透明） --&gt;
&lt;meta content=&quot;black&quot; name=&quot;apple-mobile-web-app-status-bar-style&quot;&gt;

&lt;!-- iphone设备的是有标签 允许全屏模式浏览，隐藏浏览器导航栏 --&gt;
&lt;meta content=&quot;yes&quot; name=&quot;apple-mobile-web-app-capable&quot; /&gt;

&lt;!-- 全屏显示 --&gt;
&lt;meta content=&quot;yes&quot; name=&quot;apple-touch-fullscreen&quot; /&gt;

&lt;!-- UC强制全屏 --&gt;
&lt;meta name=&quot;full-screen&quot; content=&quot;yes&quot;&gt;

&lt;!-- QQ强制全屏 --&gt;
&lt;meta name=&quot;x5-fullscreen&quot; content=&quot;true&quot;&gt;

&lt;!-- 屏蔽百度转码 --&gt;
&lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-transform&quot; /&gt;
&lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-siteapp&quot; /&gt;

&lt;!-- 定义网页简短描述 --&gt;
&lt;meta name=&quot;description&quot; content=&quot;Cochemist&quot;&gt;

&lt;!-- 定义网页关键词 --&gt;
&lt;meta name=&quot;keywords&quot; content=&quot;生物化学&quot;&gt; 

&lt;!-- 定义网页的作者 --&gt;
&lt;meta name=&quot;author&quot; content=&quot;sun_Annie&quot;&gt;

&lt;!-- 避免HTML页面缓存 --&gt;
&lt;meta http-equiv=&quot;pragma&quot; content=&quot;no-cache&quot; /&gt;
&lt;meta http-equiv=&quot;cache-control&quot; content=&quot;no-cache&quot;&gt;
&lt;meta http-equiv=&quot;expires&quot; content=&quot;0&quot;&gt;

&lt;!-- 定义网页的缓存过期时间 --&gt;
&lt;meta http-equiv=&quot;expires&quot; content=&quot;Sunday 26 October 2016 00:00 GMT&quot;&gt;
//由于这是一个过去的日期，所以这个网页只要一打开，就会直接到网站服务器重新下载页面内容，而不是从cache调用。这是一种防止网页被cache缓存的措施。

</code></pre>
<h1 id="概要">概要</h1>
<blockquote>
<p>标签提供关于 HTML 文档的元数据。元数据不会显示在页面上，但是对于机器是可读的。它可用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他 web 服务。 —— W3School</p>
</blockquote>
<h2 id="必要属性">必要属性</h2>
<table>
<thead>
<tr>
<th>属性</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>content</td>
<td>some text</td>
<td>定义与http-equiv或name属性相关的元信息</td>
</tr>
</tbody>
</table>
<h2 id="可选属性">可选属性</h2>
<table>
<thead>
<tr>
<th>属性</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>http-equiv</td>
<td>content-type / expire / refresh / set-cookie</td>
<td>把 content 属性关联到 HTTP 头部。</td>
</tr>
<tr>
<td>name</td>
<td>author / description / keywords / generator / revised / others</td>
<td>把 content 属性关联到一个名称。</td>
</tr>
<tr>
<td>content</td>
<td>some text</td>
<td>定义用于翻译 content 属性值的格式。</td>
</tr>
</tbody>
</table>
<h1 id="seo">SEO</h1>
<p><a href="http://msdn.microsoft.com/zh-cn/library/ff724016">搜索引擎优化</a></p>
<h2 id="页面关键词">页面关键词</h2>
<p>每个网页应具有描述该网页内容的一组唯一的关键字。<br>
使用人们可能会搜索，并准确描述网页上所提供信息的描述性和代表性关键字及短语。标记内容太短，则搜索引擎可能不会认为这些内容相关。另外标记不应超过 874 个字符。</p>
<pre><code class="language-html">&lt;meta name=&quot;keywords&quot; content=&quot;your tags&quot; /&gt;
</code></pre>
<h2 id="页面描述">页面描述</h2>
<p>每个网页都应有一个不超过 150 个字符且能准确反映网页内容的描述标签。</p>
<pre><code class="language-html">&lt;meta name=&quot;description&quot; content=&quot;150 words&quot; /&gt;
</code></pre>
<h2 id="搜索引擎索引方式">搜索引擎索引方式</h2>
<p><code>robot terms</code> 是一组使用逗号 <code>,</code> 分割的值，通常有如下几种取值：<code>none</code>，<code>noindex</code>，<code>nofollow</code>，<code>all</code>，<code>index</code> 和 <code>follow</code>。确保正确使用 <code>nofollow</code> 和 <code>noindex</code> 属性值。</p>
<pre><code class="language-html">&lt;meta name=&quot;robots&quot; content=&quot;index,follow&quot; /&gt;
&lt;!--
    all：文件将被检索，且页面上的链接可以被查询；
    none：文件将不被检索，且页面上的链接不可以被查询；
    index：文件将被检索；
    follow：页面上的链接可以被查询；
    noindex：文件将不被检索；
    nofollow：页面上的链接不可以被查询。
 --&gt;
</code></pre>
<h2 id="页面重定向和刷新">页面重定向和刷新</h2>
<p><code>content</code> 内的数字代表时间（秒），既多少时间后刷新。如果加 <code>url</code>，则会重定向到指定网页（搜索引擎能够自动检测，也很容易被引擎视作误导而受到惩罚）。</p>
<pre><code class="language-html">&lt;meta http-equiv=&quot;refresh&quot; content=&quot;0;url=&quot; /&gt;
</code></pre>
<h2 id="其他">其他</h2>
<pre><code class="language-html">&lt;meta name=&quot;author&quot; content=&quot;author name&quot; /&gt; &lt;!-- 定义网页作者 --&gt;
&lt;meta name=&quot;google&quot; content=&quot;index,follow&quot; /&gt;
&lt;meta name=&quot;googlebot&quot; content=&quot;index,follow&quot; /&gt;
&lt;meta name=&quot;verify&quot; content=&quot;index,follow&quot; /&gt;
</code></pre>
<h1 id="移动设备">移动设备</h1>
<h2 id="viewport">viewport</h2>
<p>能优化移动浏览器的显示。如果不是响应式网站，不要使用 <code>initial-scale</code> 或者禁用缩放。<br>
大部分 4.7-5 寸设备的 <code>viewport</code> 宽设为 360px；5.5 寸设备设为 400px；iPhone6 设为 375px；iPone6 Plus 设为414px。</p>
<pre><code class="language-html">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0,maximum-scale=1.0, user-scalable=no&quot;/&gt;
&lt;!-- `width=device-width` 会导致 iPhone 5 添加到主屏后以 WebApp 全屏模式打开页面时出现黑边  --&gt;
</code></pre>
<ol>
<li><code>width</code>：宽度（数值 / <code>device-width</code>）（范围从 200 到 10,000，默认为 980 像素）；</li>
<li><code>height</code>：高度（数值 / <code>device-height</code>）（范围从 223 到 10,000）；</li>
<li><code>initial-scale</code>：初始的缩放比例 （范围从 &gt;0 到 10）；</li>
<li><code>minimum-scale</code>：允许用户缩放到的最小比例；</li>
<li><code>maximum-scale</code>：允许用户缩放到的最大比例；</li>
<li><code>user-scalable</code>：用户是否可以手动缩 (<code>no</code>, <code>yes</code>)；</li>
<li><code>minimal-ui</code>：可以在页面加载时最小化上下状态栏。（已弃用）</li>
</ol>
<p>注意，很多人使用 <code>initial-scale=1</code> 到非响应式网站上，这会让网站以 100% 宽度渲染，用户需要手动移动页面或者缩放。如果和 <code>initial-scale=1</code> 同时使用 <code>user-scalable=no</code> 或 <code>maximum-scale=1</code>，则用户将不能放大/缩小网页来看到全部的内容。</p>
<h2 id="webapp-全屏模式">WebApp 全屏模式</h2>
<p>伪装 App，离线应用。</p>
<pre><code class="language-html">&lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot; /&gt; &lt;!-- 启用 WebApp 全屏模式 --&gt;
</code></pre>
<h2 id="隐藏状态栏设置状态栏颜色">隐藏状态栏/设置状态栏颜色</h2>
<p>只有在开启 WebApp 全屏模式时才生效。<code>content</code> 的值为 <code>default | black | black-translucent</code>。</p>
<pre><code class="language-html">&lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black-translucent&quot; /&gt;
</code></pre>
<h2 id="添加到主屏后的标题">添加到主屏后的标题</h2>
<pre><code class="language-html">&lt;meta name=&quot;apple-mobile-web-app-title&quot; content=&quot;标题&quot;&gt;
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://faded.auspicious.space/post-images/1587787337510.png" alt="" loading="lazy"></figure>
<h2 id="忽略数字自动识别为电话号码">忽略数字自动识别为电话号码</h2>
<pre><code class="language-html">&lt;meta content=&quot;telephone=no&quot; name=&quot;format-detection&quot; /&gt; 
</code></pre>
<h2 id="忽略识别邮箱">忽略识别邮箱</h2>
<pre><code class="language-html">&lt;meta content=&quot;email=no&quot; name=&quot;format-detection&quot; /&gt;
</code></pre>
<h2 id="添加智能-app-广告条-smart-app-banner">添加智能 App 广告条 Smart App Banner</h2>
<p>告诉浏览器这个网站对应的 App，并在页面上显示下载 banner（如下图）。<a href="https://developer.apple.com/library/ios/documentation/AppleApplications/Reference/SafariWebContent/PromotingAppswithAppBanners/PromotingAppswithAppBanners.html">Promoting Apps with Smart App Banners</a></p>
<pre><code class="language-html">&lt;meta name=&quot;apple-itunes-app&quot; content=&quot;app-id=myAppStoreID, affiliate-data=myAffiliateData, app-argument=myURL&quot;&gt; 
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://faded.auspicious.space/post-images/1587787470047.jpg" alt="" loading="lazy"></figure>
<h2 id="其他-2">其他</h2>
<p><a href="http://fex.baidu.com/blog/2014/10/html-head-tags/">HTML head 头标签</a></p>
<pre><code class="language-html">&lt;!-- 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 --&gt;
&lt;meta name=&quot;HandheldFriendly&quot; content=&quot;true&quot;&gt;
&lt;!-- 微软的老式浏览器 --&gt;
&lt;meta name=&quot;MobileOptimized&quot; content=&quot;320&quot;&gt;
&lt;!-- uc强制竖屏 --&gt;
&lt;meta name=&quot;screen-orientation&quot; content=&quot;portrait&quot;&gt;
&lt;!-- QQ强制竖屏 --&gt;
&lt;meta name=&quot;x5-orientation&quot; content=&quot;portrait&quot;&gt;
&lt;!-- UC强制全屏 --&gt;
&lt;meta name=&quot;full-screen&quot; content=&quot;yes&quot;&gt;
&lt;!-- QQ强制全屏 --&gt;
&lt;meta name=&quot;x5-fullscreen&quot; content=&quot;true&quot;&gt;
&lt;!-- UC应用模式 --&gt;
&lt;meta name=&quot;browsermode&quot; content=&quot;application&quot;&gt;
&lt;!-- QQ应用模式 --&gt;
&lt;meta name=&quot;x5-page-mode&quot; content=&quot;app&quot;&gt;
&lt;!-- windows phone 点击无高光 --&gt;
&lt;meta name=&quot;msapplication-tap-highlight&quot; content=&quot;no&quot;&gt;
</code></pre>
<h1 id="网页相关">网页相关</h1>
<h2 id="申明编码">申明编码</h2>
<pre><code class="language-html">&lt;meta charset='utf-8' /&gt;
</code></pre>
<h2 id="优先使用-ie-最新版本和-chrome">优先使用 IE 最新版本和 Chrome</h2>
<pre><code class="language-html">&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot; /&gt;
&lt;!-- 关于X-UA-Compatible --&gt;
&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=6&quot; &gt;&lt;!-- 使用IE6 --&gt;
&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=7&quot; &gt;&lt;!-- 使用IE7 --&gt;
&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=8&quot; &gt;&lt;!-- 使用IE8 --&gt;
</code></pre>
<h2 id="浏览器内核控制">浏览器内核控制</h2>
<p>国内浏览器很多都是双内核（Webkit和Trident），Webkit内核高速浏览，IE 内核兼容网页和旧版网站。而添加 <code>meta</code> 标签的网站可以控制浏览器选择何种内核渲染。<a href="http://se.360.cn/v6/help/meta.html">浏览器内核控制标签meta说明</a></p>
<pre><code class="language-html">&lt;meta name=&quot;renderer&quot; content=&quot;webkit|ie-comp|ie-stand&quot;&gt;
</code></pre>
<p>国内双核浏览器默认内核模式如下：</p>
<ol>
<li>搜狗高速浏览器、QQ 浏览器：IE 内核（兼容模式）；</li>
<li>360 极速浏览器、遨游浏览器：Webkit 内核（极速模式）。</li>
</ol>
<h2 id="禁止浏览器从本地计算机的缓存中访问页面内容">禁止浏览器从本地计算机的缓存中访问页面内容</h2>
<p>这样设定，访问者将无法脱机浏览。</p>
<pre><code class="language-html">&lt;meta http-equiv=&quot;Pragma&quot; content=&quot;no-cache&quot;&gt;
</code></pre>
<h2 id="windows-8">Windows 8</h2>
<pre><code class="language-html">&lt;meta name=&quot;msapplication-TileColor&quot; content=&quot;#000&quot;/&gt; &lt;!-- Windows 8 磁贴颜色 --&gt;
&lt;meta name=&quot;msapplication-TileImage&quot; content=&quot;icon.png&quot;/&gt; &lt;!-- Windows 8 磁贴图标 --&gt;
</code></pre>
<h2 id="站点适配">站点适配</h2>
<p>主要用于 PC-手机页的对应关系。</p>
<pre><code class="language-html">&lt;meta name=&quot;mobile-agent&quot;content=&quot;format=[wml|xhtml|html5]; url=url&quot;/&gt;
&lt;!--
[wml|xhtml|html5]根据手机页的协议语言，选择其中一种；
url=&quot;url&quot; 后者代表当前PC页所对应的手机页URL，两者必须是一一对应关系。
 --&gt;
</code></pre>
<h2 id="转码申明">转码申明</h2>
<p>用百度打开网页可能会对其进行转码（比如贴广告），避免转码可添加如下 <code>meta</code></p>
<pre><code class="language-html">&lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-siteapp&quot;/&gt;
</code></pre>
<h1 id="其他参考文档">其他参考文档</h1>
<ul>
<li><a href="http://code.lancepollard.com/complete-list-of-html-meta-tags/">COMPLETE LIST OF HTML META TAGS</a></li>
<li><a href="http://www.w3.org/TR/html5/document-metadata.html#the-meta-element">W3C META TAGS</a></li>
<li><a href="http://www.html-5.com/metatags/">METATAGES in HTML5</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta">MDN META TAGS</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[药品前后缀]]></title>
        <id>https://faded.auspicious.space/post/prefix-and-suffix-of-drug/</id>
        <link href="https://faded.auspicious.space/post/prefix-and-suffix-of-drug/">
        </link>
        <updated>2020-04-25T01:13:01.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p><a href="https://www.toutiao.com/i6381409325444760065/">药品名称中的那些“百家姓”</a></p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p><a href="https://www.toutiao.com/i6381409325444760065/">药品名称中的那些“百家姓”</a></p>
</blockquote>
<!-- more -->
<p><strong>看到一个药品名字中含有这些前缀/后缀，就应该知道它的基本作用是什么</strong>，以防吃药时犯低级错误哦。</p>
<p>一般情况下，前缀或后缀相同的药品，就是同一类药物，具有同一类药效。例如：</p>
<ul>
<li><strong>头孢××</strong>。头孢类药物是很常用的抗菌药物，俗称为<strong>抗生素</strong>，例如<strong>头孢拉定</strong>、<strong>头孢呋辛</strong>、<strong>头孢羟氨苄</strong>、<strong>头孢曲松</strong>、<strong>头孢克洛</strong>、<strong>头孢吡肟</strong>等。他们是用来治疗感染性炎症的，比如<strong>上呼吸道感染</strong>、<strong>下呼吸道感染</strong>、<strong>皮肤软组织感染</strong>、<strong>泌尿道感染</strong>、<strong>耳鼻部感染</strong>、<strong>腹腔感染</strong>等等，需要知道的是，不同头孢的治疗侧重点不同，需要根据感染的类型选用。</li>
<li><strong>××沙星</strong>。沙星类药物也是很常用的<strong>抗生素</strong>之一，例如<strong>环丙沙星</strong>、<strong>氧氟沙星</strong>、<strong>左氧氟沙星</strong>、<strong>莫西沙星</strong>等。他们也是用来治疗感染性炎症的，广泛用于<strong>呼吸系统感染</strong>、<strong>泌尿系统感染</strong>、<strong>皮肤软组织感染</strong>、<strong>肠道感染</strong>等。近年来，国家食药总局多次提醒大家关注这一类药物的不良反应，包括关节病变、致周围神经病变作用、中枢神经系统毒性等。同时，18岁以下患者禁用此类药物。</li>
<li><strong>××拉唑</strong>。拉唑类药物是很常用的<strong>抑制胃酸</strong>药，例如<strong>奥美拉唑</strong>、<strong>埃索美拉唑</strong>、<strong>兰索拉唑</strong>、<strong>半托拉唑</strong>、<strong>雷贝拉唑</strong>等。他们是用来治疗<strong>胃溃疡</strong>、<strong>十二指肠溃疡</strong>、<strong>反流性食管炎</strong>等消化道疾病的。需要注意的是，由于这一类药物影响胃酸分泌，同时与其他很多药物共用代谢酶，所以相互作用会比较多，同时使用这一类药物和其他药物的患者，最好审查一下相互作用哦。</li>
<li><strong>××他汀</strong>。他汀类药物是很常用的<strong>降脂药</strong>，主要用于<strong>高胆固醇血症</strong>和<strong>冠心病</strong>等，例如<strong>阿托伐他汀</strong>、<strong>瑞舒伐他汀</strong>、<strong>辛伐他汀</strong>、<strong>洛伐他汀</strong>、<strong>匹伐他汀</strong>、<strong>氟伐他汀</strong>等。不同他汀类药物的降脂强度不同，不可随意换用。另外，长期用药患者需要注意监测转氨酶和肌酸激酶。</li>
<li><strong>××普利</strong>。普利类药物是很常用的<strong>降压药</strong>之一，学名称作<strong>血管紧张素转化酶抑制剂</strong>，是治疗<strong>高血压</strong>的一线药物之一，例如<strong>卡托普利</strong>、<strong>贝那普利</strong>、<strong>依那普利</strong>、<strong>福辛普利</strong>、<strong>培哚普利</strong>、<strong>雷米普利</strong>、<strong>赖诺普利</strong>等。使用普利类降压药时，需要注意其<strong>干咳的副作用</strong>。</li>
<li><strong>××地平</strong>。地平类药物也是很常用的<strong>降压药</strong>，学名称为<strong>钙离子通道拮抗剂</strong>，也是治疗<strong>高血压</strong>的一线药物，例如<strong>硝苯地平</strong>、<strong>氨氯地平</strong>、<strong>尼群地平</strong>、<strong>拉西地平</strong>、<strong>尼卡地平</strong>等。其中，硝苯地平是最常用的<strong>降血压</strong>和<strong>缓解心绞痛</strong>的的药物之一，为了减少服药次数增加疗效稳定性，目前有多种缓控释制剂供选择。</li>
</ul>
<p>但是，任何事情都有例外，<strong>有些药品名称“看起来是一家”，实际上却“不是一家”</strong>。例如：</p>
<ul>
<li><strong>××霉素</strong>。药品名称中含有“霉素”两个字的药很多，但是他们并不都是一类的。例如，青霉素和苄星青霉素属于青霉素类抗菌药，庆大霉素、妥布霉素属于氨基糖苷类抗菌药，红霉素、阿奇霉素、克拉霉素属于大环内酯类抗菌药，万古霉素属于糖肽类抗菌药，链霉素、利福霉素常用于抗结核病类药，阿霉素、柔红霉素、丝裂霉素属于细胞毒药物（抗癌药）等。这些药物的药效和作用范围都不相同。</li>
<li><strong>×格列×</strong>。名称中含有“格列”两个字的药也很多，例如降糖药里面的磺脲类降糖药格列美脲、格列喹酮，α-糖苷酶抑制剂伏格列波糖，胰岛素增敏药罗格列酮、吡格列酮等。这些药物虽然都是糖尿病患者的口服降糖药，但是具体作用机制和药物类别并不一样，适用人群和用法也不一样。</li>
<li><strong>×莫司×</strong>。名称中含有“莫司”两个字的药也很多，但是药效作用各不相同，有免疫调节剂他克莫司、西罗莫司，有细胞毒药物司莫司汀、卡莫司汀、洛莫司汀、福莫司汀等，还有降血脂药阿昔莫司。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[程序员经典语录]]></title>
        <id>https://faded.auspicious.space/post/classic-quotes-of-programmer/</id>
        <link href="https://faded.auspicious.space/post/classic-quotes-of-programmer/">
        </link>
        <updated>2020-04-25T00:52:40.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p><a href="https://www.jianshu.com/p/7901115f61ec">程序员经典语录</a></p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p><a href="https://www.jianshu.com/p/7901115f61ec">程序员经典语录</a></p>
</blockquote>
<!-- more -->
<ol>
<li>
<p>A good programmer is someone who always looks both ways before crossing a one-way street. (Doug Linder)<br>
好的程序员即使在过单行道时也总是会环顾两边。</p>
</li>
<li>
<p>Don't worry if it doesn't work right. If everything did, you'd be out of a job. (Mosher's Law of Software Engineering)<br>
不要担心它能否正常工作。如果一切正常，那么你就会失去工作。</p>
</li>
<li>
<p>The trouble with programmers is that you can never tell what a programmer is doing until it's too late. (Seymour Cray)<br>
程序员的烦恼是，你永远无法知道一个程序员在做什么，直到为时已晚。</p>
</li>
<li>
<p>Most of you are familiar with the virtues of a programmer. There are three, of course: laziness, impatience, and hubris. (Larry Wall)<br>
程序员的美德：懒惰，没有耐心以及老子天下第一。</p>
</li>
<li>
<p>Always code as if the guy who ends up maintaining your code will be a violent psychopath who knows where you live. (Martin Golding)<br>
写代码的时候总是想象维护你代码的家伙是一个知道你住在哪里的暴力精神病患者。</p>
</li>
<li>
<p>One man's crappy software is another man's full time job. (Jessica Gaston)<br>
一个人写的烂软件将会给另一个人带来一份全职工作。</p>
</li>
<li>
<p>If builders built buildings the way programmers wrote programs, then the first woodpecker that came along wound destroy civilization. (Gerald Weinberg)<br>
如果建筑工人用程序员写程序的方式建造建筑物，那么来的第一只啄木鸟（找bug）就将摧毁文明。</p>
</li>
<li>
<p>The most likely way for the world to be destroyed, most experts agree, is by accident.  That's where we come in; we're computer professionals. We cause accidents. (Nathaniel Borenstein)<br>
大多数专家认为，世界被破坏的最有可能的方式是，是因为偶然。那就是我们所要进入的领域：我们是计算机专家。我们制造偶然。</p>
</li>
<li>
<p>It's a curious thing about our industry: not only do we not learn from our mistakes, we also don't learn from our successes. (Keith  Braithwaite)<br>
这是我们这个行业的一件咄咄怪事：我们不仅不从错误中学习，我们也不从成功中学习。</p>
</li>
<li>
<p>Once a new technology starts rolling, if you're not part of the steamroller, you're part of the road. (Stewart Brand)<br>
一旦一种新技术开始滚动碾压道路，如果你不能成为压路机的一部分，那么你就只能成为道路的一部分。</p>
</li>
<li>
<p>If at first you don't succeed, call it version 1.0 (unknown)<br>
如果第一次你没有成功，那么称之为1.0版，继续加油。</p>
</li>
<li>
<p>All programmers are playwrights and all computers are lousy actors. (Anonymous Hack Actor)<br>
所有的程序员都剧作家，而所有计算机都是糟糕的演员。</p>
</li>
<li>
<p>The sooner you get behind in your work, the more time you have to catch up. (Anonymous Scheduler)<br>
工作拉下得越早，赶上去所需要的时间越多。</p>
</li>
<li>
<p>When a programming language is created that allows programmers to program in simple English, it will be discovered that programmers cannot speak English. (Anonymous Linguist)<br>
当创建一种编程语言允许程序员使用简单英语编程的时候，那么新问题又来了，你会发现程序员不说英语。</p>
</li>
<li>
<p>Why do we never have time to do it right, but always have time to do it over? (Anonymous)<br>
为什么我们总是没有时间把事情做对，却有时间做完它？</p>
</li>
<li>
<p>Any fool can write code that a computer can understand. Good programmers write code that humans can understand.<br>
傻瓜写计算机能理解的代码。优秀的程序员写人类能读懂的代码。</p>
</li>
<li>
<p>Any code of your own that you haven't looked at for six or more months might as well have been written by someone else. (Eagleson's law)<br>
自己的代码六个月或更久不见，还不如别人写的代码。</p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[10 种常见的软件架构模式]]></title>
        <id>https://faded.auspicious.space/post/10-common-software-architectural-patterns-in-a-nutshell/</id>
        <link href="https://faded.auspicious.space/post/10-common-software-architectural-patterns-in-a-nutshell/">
        </link>
        <updated>2020-04-24T11:47:47.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p><a href="https://www.jianshu.com/p/8377ce217b65">10种常见的软件架构模式</a></p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p><a href="https://www.jianshu.com/p/8377ce217b65">10种常见的软件架构模式</a></p>
</blockquote>
<!-- more -->
<p>有没有想过要设计多大的企业规模系统？在主要的软件开发开始之前，我们必须选择一个合适的体系结构，它将为我们提供所需的功能和质量属性。因此，在将它们应用到我们的设计之前，我们应该了解不同的体系结构。</p>
<figure data-type="image" tabindex="1"><img src="https://faded.auspicious.space/post-images/1587729095513.png" alt="" loading="lazy"></figure>
<h1>什么是架构模式？</h1>
根据维基百科中的定义：
<blockquote>
<p>架构模式是一个通用的、可重用的解决方案，用于在给定上下文中的软件体系结构中经常出现的问题。架构模式与软件设计模式类似，但具有更广泛的范围。</p>
</blockquote>
<p>在本文中，将简要地解释以下 10 种常见的体系架构模式，以及它们的用法、优缺点。</p>
<ol>
<li><a href="#%E4%B8%80-%E5%88%86%E5%B1%82%E6%A8%A1%E5%BC%8F">分层模式</a></li>
<li><a href="#%E4%BA%8C-%E5%AE%A2%E6%88%B7%E7%AB%AF-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A8%A1%E5%BC%8F">客户端-服务器模式</a></li>
<li><a href="#%E4%B8%89-%E4%B8%BB%E4%BB%8E%E8%AE%BE%E5%A4%87%E6%A8%A1%E5%BC%8F">主从设备模式</a></li>
<li><a href="#%E5%9B%9B-%E7%AE%A1%E9%81%93-%E8%BF%87%E6%BB%A4%E5%99%A8%E6%A8%A1%E5%BC%8F">管道-过滤器模式</a></li>
<li><a href="#%E4%BA%94-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F">代理模式</a></li>
<li><a href="#%E5%85%AD-%E7%82%B9%E5%AF%B9%E7%82%B9%E6%A8%A1%E5%BC%8F">点对点模式</a></li>
<li><a href="#%E4%B8%83-%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%BC%8F">事件总线模式</a></li>
<li><a href="#%E5%85%AB-%E6%A8%A1%E5%9E%8B-%E8%A7%86%E5%9B%BE-%E6%8E%A7%E5%88%B6%E5%99%A8%E6%A8%A1%E5%BC%8F">模型-视图-控制器模式</a></li>
<li><a href="#%E4%B9%9D-%E9%BB%91%E6%9D%BF%E6%A8%A1%E5%BC%8F">黑板模式</a></li>
<li><a href="#%E5%8D%81-%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F">解释器模式</a></li>
</ol>
<h1 id="一-分层模式">一、分层模式</h1>
<p>这种模式也称为多层体系架构模式。它可以用来构造可以分解为子任务组的程序，每个子任务都处于一个特定的抽象级别。每个层都为下一个提供更高层次服务。</p>
<p>一般信息系统中最常见的是如下所列的 4 层。</p>
<ul>
<li>表示层（也称为 UI 层）；</li>
<li>应用层（也称为服务层）；</li>
<li>业务逻辑层（也称为领域层）；</li>
<li>数据访问层（也称为持久化层）。</li>
</ul>
<p>使用场景：</p>
<ul>
<li>一般的桌面应用程序；</li>
<li>电子商务 Web 应用程序。</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://faded.auspicious.space/post-images/1587729515629.png" alt="Layered pattern" loading="lazy"></figure>
<h1 id="二-客户端-服务器模式">二、客户端-服务器模式</h1>
<p>这种模式由两部分组成：一个服务器和多个客户端。服务器组件将为多个客户端组件提供服务。客户端从服务器请求服务，服务器为这些客户端提供相关服务。此外，服务器持续侦听客户机请求。</p>
<p>使用场景：</p>
<ul>
<li>电子邮件，文件共享和银行等在线应用程序。</li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://faded.auspicious.space/post-images/1587729648043.png" alt="Client-server pattern " loading="lazy"></figure>
<h1 id="三-主从设备模式">三、主从设备模式</h1>
<p>这种模式由两方组成：主设备和从设备。主设备组件在相同的从设备组件中分配工作，并计算最终结果，这些结果是由从设备返回的结果。</p>
<p>使用场景：</p>
<ul>
<li>在数据库复制中，主数据库被认为是权威的来源，并且要与之同步；</li>
<li>在计算机系统中与总线连接的外围设备（主和从驱动器）。</li>
</ul>
<figure data-type="image" tabindex="4"><img src="https://faded.auspicious.space/post-images/1587729762626.png" alt="Master-slave pattern" loading="lazy"></figure>
<h1 id="四-管道-过滤器模式">四、管道-过滤器模式</h1>
<p>此模式可用于构造生成和处理数据流的系统。每个处理步骤都封装在一个过滤器组件内。要处理的数据是通过管道传递的。这些管道可以用于缓冲或用于同步。</p>
<p>使用场景：</p>
<ul>
<li>编译器。连续的过滤器执行词法分析、解析、语义分析和代码生成；</li>
<li>生物信息学的工作流。</li>
</ul>
<figure data-type="image" tabindex="5"><img src="https://faded.auspicious.space/post-images/1587729828986.png" alt="Pipe-filter pattern" loading="lazy"></figure>
<h1 id="五-代理模式">五、代理模式</h1>
<p>此模式用于构造具有解耦组件的分布式系统。这些组件可以通过远程服务调用彼此交互。代理组件负责组件之间的通信协调。</p>
<p>服务器将其功能（服务和特征）发布给代理。客户端从代理请求服务，然后代理将客户端重定向到其注册中心的适当服务。</p>
<p>使用场景：</p>
<ul>
<li>消息代理软件，如 Apache ActiveMQ，Apache Kafka，RabbitMQ 和 JBoss Messaging。</li>
</ul>
<figure data-type="image" tabindex="6"><img src="https://faded.auspicious.space/post-images/1587729911790.png" alt="Broker pattern" loading="lazy"></figure>
<h1 id="六-点对点模式">六、点对点模式</h1>
<p>在这种模式中，单个组件被称为对等点。对等点可以作为客户端，从其他对等点请求服务，作为服务器，为其他对等点提供服务。对等点可以充当客户端或服务器或两者的角色，并且可以随时间动态地更改其角色。</p>
<p>使用场景：</p>
<ul>
<li>像 Gnutella 和 G2 这样的文件共享网络；</li>
<li>多媒体协议，如 P2PTV 和 PDTP；</li>
<li>像 Spotify 这样的专有多媒体应用程序。</li>
</ul>
<figure data-type="image" tabindex="7"><img src="https://faded.auspicious.space/post-images/1587730026205.png" alt="Peer-to-peer pattern" loading="lazy"></figure>
<h1 id="七-事件总线模式">七、事件总线模式</h1>
<p>这种模式主要是处理事件，包括 4 个主要组件：事件源、事件监听器、通道和事件总线。消息源将消息发布到事件总线上的特定通道上。侦听器订阅特定的通道。侦听器会被通知消息，这些消息被发布到它们之前订阅的一个通道上。</p>
<p>使用场景：</p>
<ul>
<li>安卓开发；</li>
<li>通知服务。</li>
</ul>
<figure data-type="image" tabindex="8"><img src="https://faded.auspicious.space/post-images/1587730115823.png" alt="Event-bus pattern" loading="lazy"></figure>
<h1 id="八-模型-视图-控制器模式">八、模型-视图-控制器模式</h1>
<p>这种模式，也称为 MVC 模式，把一个交互式应用程序划分为 3 个部分，</p>
<ul>
<li><strong>模型</strong>：包含核心功能和数据；</li>
<li><strong>视图</strong>：将信息显示给用户（可以定义多个视图）；</li>
<li><strong>控制器</strong>：处理用户输入的信息。</li>
</ul>
<p>这样做是为了将信息的内部表示与信息的呈现方式分离开来，并接受用户的请求。它分离了组件，并允许有效的代码重用。</p>
<p>使用场景：</p>
<ul>
<li>在主要编程语言中互联网应用程序的体系架构；</li>
<li>像 Django 和 Rails 这样的 Web 框架。</li>
</ul>
<figure data-type="image" tabindex="9"><img src="https://faded.auspicious.space/post-images/1587730246020.png" alt="Model-view-controller pattern" loading="lazy"></figure>
<h1 id="九-黑板模式">九、黑板模式</h1>
<p>这种模式对于没有确定解决方案策略的问题是有用的。黑板模式由 3 个主要组成部分组成。</p>
<ul>
<li><strong>黑板</strong>——包含来自解决方案空间的对象的结构化全局内存；</li>
<li><strong>知识源</strong>——专门的模块和它们自己的表示；</li>
<li><strong>控制组件</strong>——选择、配置和执行模块；</li>
</ul>
<p>所有的组件都可以访问黑板。组件可以生成添加到黑板上的新数据对象。组件在黑板上查找特定类型的数据，并通过与现有知识源的模式匹配来查找这些数据。</p>
<p>使用场景：</p>
<ul>
<li>语音识别；</li>
<li>车辆识别和跟踪；</li>
<li>蛋白质结构识别；</li>
<li>声纳信号的解释。</li>
</ul>
<figure data-type="image" tabindex="10"><img src="https://faded.auspicious.space/post-images/1587730341022.png" alt="Blackboard pattern" loading="lazy"></figure>
<h1 id="十-解释器模式">十、解释器模式</h1>
<p>这个模式用于设计一个解释用专用语言编写的程序的组件。它主要指定如何评估程序的行数，即以特定的语言编写的句子或表达式。其基本思想是为每种语言的符号都有一个分类。</p>
<p>使用场景：</p>
<ul>
<li>数据库查询语言，比如 SQL；</li>
<li>用于描述通信协议的语言。</li>
</ul>
<figure data-type="image" tabindex="11"><img src="https://faded.auspicious.space/post-images/1587730400554.png" alt="Interpreter pattern" loading="lazy"></figure>
<h1 id="体系架构模式的比较">体系架构模式的比较</h1>
<p>下面给出的表格总结了每种体系架构模式的优缺点。</p>
<table>
<thead>
<tr>
<th style="width:20%">名称</th>
<th style="width:40%">优点</th>
<th style="width:40%">缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>分层模式</td>
<td>一个较低的层可以被不同的层所使用。层使标准化更容易，因为我们可以清楚地定义级别。可以在层内进行更改，而不会影响其他层。</td>
<td>不是普遍适用的。在某些情况下，某些层可能会被跳过。</td>
</tr>
<tr>
<td>客户端-服务器模式</td>
<td>很好地建立一组服务，用户可以请求他们的服务。</td>
<td>请求通常在服务器上的单独线程中处理。由于不同的客户端具有不同的表示，进程间通信会导致额外开销。</td>
</tr>
<tr>
<td>主从设备模式</td>
<td>准确性——将服务的执行委托给不同的从设备，具有不同的实现。</td>
<td>从设备是孤立的：没有共享的状态。主-从通信中的延迟可能是一个问题，例如在实时系统中。这种模式只能应用于可以分解的问题。</td>
</tr>
<tr>
<td>管道-过滤器模式</td>
<td>展示并发处理。当输入和输出由流组成时，过滤器在接收数据时开始计算。轻松添加过滤器，系统可以轻松扩展。过滤器可重复使用。 可以通过重新组合一组给定的过滤器来构建不同的管道。</td>
<td>效率受到最慢的过滤过程的限制。从一个过滤器移动到另一个过滤器时的数据转换开销。</td>
</tr>
<tr>
<td>代理模式</td>
<td>允许动态更改、添加、删除和重新定位对象，这使开发人员的发布变得透明。</td>
<td>要求对服务描述进行标准化。</td>
</tr>
<tr>
<td>点对点模式</td>
<td>支持分散式计算。对任何给定节点的故障处理具有强大的健壮性。在资源和计算能力方面具有很高的可扩展性。</td>
<td>服务质量没有保证，因为节点是自愿合作的。安全是很难得到保证的。性能取决于节点的数量。</td>
</tr>
<tr>
<td>事件总线模式</td>
<td>新的发布者、订阅者和连接可以很容易地添加。对高度分布式的应用程序有效。</td>
<td>可伸缩性可能是一个问题，因为所有消息都是通过同一事件总线进行的。</td>
</tr>
<tr>
<td>模型-视图-控制器模式</td>
<td>可以轻松地拥有同一个模型的多个视图，这些视图可以在运行时连接和断开。</td>
<td>增加复杂性。可能导致许多不必要的用户操作更新。</td>
</tr>
<tr>
<td>黑板模式</td>
<td>很容易添加新的应用程序。扩展数据空间的结构很简单。</td>
<td>修改数据空间的结构非常困难，因为所有应用程序都受到了影响。可能需要同步和访问控制。</td>
</tr>
<tr>
<td>解释器模式</td>
<td>高度动态的行为是可行的。对终端用户编程性提供好处。提高灵活性，因为替换一个解释程序很容易。</td>
<td>由于解释语言通常比编译后的语言慢，因此性能可能是一个问题。</td>
</tr>
</tbody>
</table>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[window 对象知识总结]]></title>
        <id>https://faded.auspicious.space/post/window-object-summary/</id>
        <link href="https://faded.auspicious.space/post/window-object-summary/">
        </link>
        <updated>2020-04-24T05:17:21.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p><a href="https://yq.aliyun.com/articles/74458">window对象知识总结</a></p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p><a href="https://yq.aliyun.com/articles/74458">window对象知识总结</a></p>
</blockquote>
<!-- more -->
<h1 id="window-对象属性">window 对象属性</h1>
<table>
<thead>
<tr>
<th>属性名</th>
<th>属性功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>closed</td>
<td>返回窗口是否已被关闭</td>
</tr>
<tr>
<td>defaultStatus</td>
<td>设置或返回窗口状态栏中的默认文本</td>
</tr>
<tr>
<td>document</td>
<td>对 document 对象的只读引用</td>
</tr>
<tr>
<td>history</td>
<td>对 history 对象的只读引用</td>
</tr>
<tr>
<td>innerheight</td>
<td>返回窗口的文档显示区的高度</td>
</tr>
<tr>
<td>innerwidth</td>
<td>返回窗口的文档显示区的宽度</td>
</tr>
<tr>
<td>length</td>
<td>设置或返回窗口中的框架数量</td>
</tr>
<tr>
<td>location</td>
<td>用于窗口或框架的 location 对象</td>
</tr>
<tr>
<td>name</td>
<td>设置或返回窗口的名称</td>
</tr>
<tr>
<td>navigator</td>
<td>对 navigator 对象的只读引用</td>
</tr>
<tr>
<td>opener</td>
<td>返回对创建此窗口的窗口的引用</td>
</tr>
<tr>
<td>outerheight</td>
<td>返回窗口的外部高度</td>
</tr>
<tr>
<td>outerwidth</td>
<td>返回窗口的外部宽度</td>
</tr>
<tr>
<td>pageXOffset</td>
<td>设置或返回当前页面相对于窗口显示区左上角的 X 位置</td>
</tr>
<tr>
<td>pageYOffset</td>
<td>设置或返回当前页面相对于窗口显示区左上角的 Y 位置</td>
</tr>
<tr>
<td>parent</td>
<td>返回父窗口</td>
</tr>
<tr>
<td>screen</td>
<td>对 screen 对象的只读引用</td>
</tr>
<tr>
<td>self</td>
<td>返回对当前窗口的引用。等价于 window 属性</td>
</tr>
<tr>
<td>status</td>
<td>设置窗口状态栏的文本</td>
</tr>
<tr>
<td>top</td>
<td>返回最顶层的先辈窗口</td>
</tr>
<tr>
<td>window</td>
<td>window 属性等价于 self 属性，它包含了对窗口自身的引用</td>
</tr>
<tr>
<td>screenLeft/screenTop/screenX/screenY</td>
<td>只读整数。声明了窗口的左上角在屏幕上的的 x 坐标和 y 坐标。IE、Safari 和 Opera 支持 screenLeft 和 screenTop，而 Firefox 和 Safari 支持 screenX 和 screenY</td>
</tr>
</tbody>
</table>
<h1 id="window-对象方法">window 对象方法</h1>
<table>
<thead>
<tr>
<th>对象名</th>
<th>对象功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>alert()</td>
<td>显示带有一段消息和一个确认按钮的警告框</td>
</tr>
<tr>
<td>blur()</td>
<td>把键盘焦点从顶层窗口移开</td>
</tr>
<tr>
<td>clearInterval()</td>
<td>取消由 setInterval() 设置的 timeout</td>
</tr>
<tr>
<td>clearTimeout()</td>
<td>取消由 setTimeout() 方法设置的 timeout</td>
</tr>
<tr>
<td>close()</td>
<td>关闭浏览器窗口</td>
</tr>
<tr>
<td>confirm()</td>
<td>显示带有一段消息以及确认按钮和取消按钮的对话框</td>
</tr>
<tr>
<td>createPopup()</td>
<td>创建一个 pop-up 窗口</td>
</tr>
<tr>
<td>focus()</td>
<td>把键盘焦点给予一个窗口</td>
</tr>
<tr>
<td>moveBy()</td>
<td>可相对窗口的当前坐标把它移动指定的像素</td>
</tr>
<tr>
<td>moveTo()</td>
<td>把窗口的左上角移动到一个指定的坐标</td>
</tr>
<tr>
<td>open()</td>
<td>打开一个新的浏览器窗口或查找一个已命名的窗口</td>
</tr>
<tr>
<td>print()</td>
<td>打印当前窗口的内容</td>
</tr>
<tr>
<td>prompt()</td>
<td>显示可提示用户输入的对话框</td>
</tr>
<tr>
<td>resizeBy()</td>
<td>按照指定的像素调整窗口的大小</td>
</tr>
<tr>
<td>resizeTo()</td>
<td>把窗口的大小调整到指定的宽度和高度</td>
</tr>
<tr>
<td>scrollBy()</td>
<td>按照指定的像素值来滚动内容</td>
</tr>
<tr>
<td>scrollTo()</td>
<td>把内容滚动到指定的坐标</td>
</tr>
<tr>
<td>setInterval()</td>
<td>按照指定的周期（以毫秒计）来调用函数或计算表达式</td>
</tr>
<tr>
<td>setTimeout()</td>
<td>在指定的毫秒数后调用函数或计算表达式</td>
</tr>
</tbody>
</table>
<h1 id="window-对象描述">window 对象描述</h1>
<p>window 对象表示一个浏览器窗口或一个框架。在客户端 JavaScript 中，window 对象是全局对象，所有的表达式都在当前的环境中计算。也就是说，要引用当前窗口根本不需要特殊的语法，可以把那个窗口的属性作为全局变量来使用。例如，可以只写 <code>document</code>，而不必写 <code>window.document</code></p>
<p>同样，可以把当前窗口对象的方法当作函数来使用，如只写 <code>alert()</code>，而不必写 <code>window.alert()</code></p>
<p>除了上面列出的属性和方法，window 对象还实现了核心 JavaScript 所定义的所有全局属性和方法</p>
<p>window 对象的 <code>window</code> 属性和 <code>self</code> 属性引用的都是它自己。当你想明确地引用当前窗口，而不仅仅是隐式地引用它时，可以使用这两个属性。除了这两个属性之外，<code>parent</code> 属性、<code>top</code> 属性以及 <code>frame[]</code> 数组都引用了与当前 window 对象相关的其他 window 对象</p>
<p>要引用窗口中的一个框架，可以使用如下语法：</p>
<ul>
<li><code>frame[i]</code>：当前窗口的框架</li>
<li><code>self.frame[i]</code>：当前窗口的框架</li>
<li><code>w.frame[i]</code>：窗口 <code>w</code> 的框架</li>
</ul>
<p>要引用一个框架的父窗口（或父框架），可以使用下面的语法：</p>
<ul>
<li><code>parent</code>：当前窗口的父窗口。</li>
<li><code>self.parent</code>：当前窗口的父窗口。</li>
<li><code>w.parent</code>：窗口 <code>w</code> 的父窗口。</li>
</ul>
<p>要从顶层窗口含有的任何一个框架中引用它，可以使用如下语法：</p>
<ul>
<li><code>top</code>：当前框架的顶层窗口。</li>
<li><code>self.top</code>：当前框架的顶层窗口。</li>
<li><code>f.top</code>：框架 <code>f</code> 的顶层窗口。</li>
</ul>
<p>新的顶层浏览器窗口由方法 <code>window.open()</code> 创建。当调用该方法时，应把 <code>open()</code> 调用的返回值存储在一个变量中，然后使用那个变量来引用新窗口。新窗口的 <code>opener</code> 属性反过来引用了打开它的那个窗口</p>
<p>一般来说，window 对象的方法都是对浏览器窗口或框架进行某种操作；而 <code>alert()</code> 方法、<code>confirm()</code> 方法和 <code>prompt</code> 方法则不同，它们通过简单的对话框与用户进行交互。</p>
<h1 id="全局的-window-对象">全局的 window 对象</h1>
<p>JavaScript 中的任何一个全局函数或变量都是 <code>window</code> 的属性。</p>
<pre><code class="language-html">&lt;script type=&quot;text/javascript&quot;&gt;
    var name = &quot;aaaa&quot;;
    document.write(window.name);
&lt;/script&gt;
</code></pre>
<h1 id="window-与-self-对象">window 与 self 对象</h1>
<p><code>self</code> 对象与 <code>window</code> 对象完全相同，<code>self</code> 通常用于确认就是在当前的窗体内</p>
<pre><code class="language-html">&lt;script type=&quot;text/javascript&quot;&gt;
    document.write(window == self);　　　　    　//必须相等，永远都相等
    document.write(window.top == window.self);　//判断当前框架是否是主框架
&lt;/script&gt;
</code></pre>
<p><code>window</code>、<code>self</code>、<code>window.self</code> 三者是等价的。</p>
<h1 id="window-的子对象">window 的子对象</h1>
<p><code>window</code> 的主对象主要有：</p>
<ul>
<li>JavaScript <code>document</code> 对象</li>
<li>JavaScript <code>frames</code> 对象</li>
<li>JavaScript <code>history</code> 对象</li>
<li>JavaScript <code>location</code> 对象</li>
<li>JavaScript <code>navigator</code> 对象</li>
<li>JavaScript <code>screen</code> 对象</li>
</ul>
<h1 id="window-函数索引仅对-ie-有效">window 函数索引（仅对 IE 有效）</h1>
<h2 id="窗体控制函数">窗体控制函数</h2>
<ul>
<li><code>moveBy()</code>：从当前位置水平移动窗体 <code>x</code> 个像素，垂直移动窗体 <code>y</code> 个像素，<code>x</code> 为负数，将向左移动窗体，<code>y</code> 为负数，将向上移动窗体。</li>
<li><code>moveTo()</code>：移动窗体左上角到相对于屏幕左上角的 <code>(x, y)</code> 点，当使用负数做为参数时会把窗体移出屏幕的可视区域。</li>
<li><code>resizeBy()</code>：相对窗体当前的大小，宽度调整 <code>w</code> 个像素，高度调整 <code>h</code> 个像素。如果参数为负值，将缩小窗体，反之扩大窗体。</li>
<li><code>resizeTo()</code>：把窗体宽度调整为 <code>w</code> 个像素，高度调整为 <code>h</code>个像素。</li>
</ul>
<pre><code class="language-html">&lt;body&gt;
    &lt;input type=&quot;button&quot; id=&quot;btn1&quot; value=&quot;先设置窗体固定大小！&quot; onclick=&quot;window.resizeTo(500,500);&quot; /&gt;
    &lt;input type=&quot;button&quot; id=&quot;btn2&quot; value=&quot;再缩小10像素！&quot; onclick=&quot;window.resizeBy(-10,-10);&quot; /&gt;
    &lt;input type=&quot;button&quot; id=&quot;btn2&quot; value=&quot;上！&quot; onclick=&quot;window.moveBy(0,-5);&quot; /&gt;
    &lt;input type=&quot;button&quot; id=&quot;btn2&quot; value=&quot;下！&quot; onclick=&quot;window.moveBy(0, 5);&quot; /&gt;
    &lt;input type=&quot;button&quot; id=&quot;btn2&quot; value=&quot;左！&quot; onclick=&quot;window.moveBy(-5, 0);&quot; /&gt;
    &lt;input type=&quot;button&quot; id=&quot;btn2&quot; value=&quot;右！&quot; onclick=&quot;window.moveBy(5, 0);&quot; /&gt;
    &lt;input type=&quot;button&quot; id=&quot;btn2&quot; value=&quot;距离左上角左边100像素，顶部200像素&quot; onclick=&quot;window.moveTo(100, 200);&quot; /&gt;
&lt;/body&gt;
</code></pre>
<h2 id="窗体滚动轴控制函数">窗体滚动轴控制函数</h2>
<ul>
<li><code>scrollTo()</code>：在窗体中如果有滚动条，将横向滚动条移动到相对于窗体宽度为 <code>x</code> 个像素的位置，将纵向滚动条移动到相对于窗体高度为 <code>y</code> 个像素的位置。</li>
<li><code>scrollBy()</code>：如果有滚动条，将横向滚动条移动到相对于当前横向滚动条的 <code>x</code> 个像素的位置（就是向左移动 <code>x</code> 像素），将纵向滚动条移动到相对于当前纵向滚动条高度为 <code>y</code> 个像素的位置（就是向下移动 <code>y</code> 像素）。</li>
</ul>
<p>注意区别，一个是相对当前窗口，一个是相当现在滚动条的位置。</p>
<pre><code class="language-html">&lt;div style=&quot;height:150%; width:150%; background-color:#ddd&quot;&gt;
    &lt;input type=&quot;button&quot; id=&quot;btn1&quot; value=&quot;移动滚动条！&quot; onclick=&quot;window.scrollTo(100,100);&quot; /&gt;　　//相当于设置绝对位置
    &lt;input type=&quot;button&quot; id=&quot;btn1&quot; value=&quot;移动滚动条！&quot; onclick=&quot;window.scrollBy(100,100);&quot; /&gt;　　//相当于累加
&lt;/div&gt;
</code></pre>
<h2 id="窗体焦点控制函数">窗体焦点控制函数</h2>
<ul>
<li><code>focus()</code>：使窗体或空间获得焦点。</li>
<li><code>blur()</code>：使窗体或控件失去焦点。</li>
</ul>
<pre><code class="language-html">&lt;div&gt;
    &lt;input type=&quot;button&quot; value=&quot;获得焦点&quot; onclick=&quot;document.getElementById('testInput').focus()&quot; /&gt;
    &lt;input type=&quot;button&quot; value=&quot;失去焦点&quot; onclick=&quot;document.getElementById('testInput').blur()&quot; /&gt;
    &lt;input type=&quot;text&quot; value=&quot;text&quot; id=&quot;testInput&quot; onblur=&quot;alert('我已失去焦点')&quot; /&gt;
&lt;/div&gt;
</code></pre>
<h2 id="新建窗体函数">新建窗体函数</h2>
<ul>
<li><code>open()</code>：打开（弹出）一个新的窗体。</li>
<li><code>close()</code>：关闭窗体。</li>
<li><code>opener</code>：通过 <code>opener</code> 可以实现跨窗体之间的通讯，但是要保证是在同一域名下，而且一个窗体要包含另一个窗体的 <code>opener</code>。</li>
</ul>
<p>格式：<code>window.open(url, name, features, replace);</code></p>
<h3 id="open-函数参数说明">open 函数参数说明</h3>
<ul>
<li><code>url</code>：要载入窗体的 URL。</li>
<li><code>name</code>：新建窗体的名称（也可以是 HTML <code>target</code> 属性的取值，目标）。</li>
<li><code>features</code>：代表窗体特性的字符串，字符串中每个特性使用逗号分隔。</li>
<li><code>replace</code>：一个布尔值，说明新载入的页面是否替换当前载入的页面，此参数通常不用指定。</li>
</ul>
<h3 id="open-方法示例">open 方法示例</h3>
<pre><code class="language-html">&lt;a href=&quot;2.html&quot; target=&quot;2&quot;&gt;在新窗口打开连接&lt;/a&gt;
&lt;a href=&quot;#&quot; onclick=&quot;window.open('http://www.google.com','2');&quot;&gt;在已建立连接的页面打开新地址&lt;/a&gt;
</code></pre>
<p>首先使用普通 HTML 链接打开一个页面( <code>target</code> 名为 <code>dreamdu</code>)，之后使用 <code>open</code> 函数打开另一个页面，浏览器首先要查找是否有名称为 <code>dreamdu</code> 的窗体，如果有，就在这个窗体中加载 <code>open</code> 的地址。</p>
<h4 id="经过设置的-open">经过设置的 open</h4>
<pre><code class="language-javascript">window.open ('page.html', 'newwindow', 'height=100, width=400, top=0,left=0, toolbar=no, menubar=no, scrollbars=no, resizable=no,location=no, status=no');
</code></pre>
<h4 id="弹窗方法">弹窗方法</h4>
<ul>
<li>方法一：<code>&lt;body onload=&quot;openwin()&quot;&gt;</code> 浏览器读页面时弹出窗口；</li>
<li>方法二：<code>&lt;body onunload=&quot;openwin()&quot;&gt;</code> 浏览器离开页面时弹出窗口。</li>
</ul>
<h3 id="open-函数第三个参数-features-说明">open 函数第三个参数 features 说明</h3>
<table>
<thead>
<tr>
<th>参数名称</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>height</td>
<td>Number</td>
<td>设置窗体的高度，不能小于100</td>
</tr>
<tr>
<td>left</td>
<td>Number</td>
<td>说明创建窗体的左坐标，不能为负值</td>
</tr>
<tr>
<td>location</td>
<td>Boolean</td>
<td>窗体是否显示地址栏，默认值为 no</td>
</tr>
<tr>
<td>resizable</td>
<td>Boolean</td>
<td>窗体是否允许通过拖动边线调整大小，默认值为 no</td>
</tr>
<tr>
<td>scrollable</td>
<td>Boolean</td>
<td>窗体中内部超出窗口可视范围时是否允许拖动，默认值为 no</td>
</tr>
<tr>
<td>toolbar</td>
<td>Boolean</td>
<td>窗体是否显示工具栏，默认值为 no</td>
</tr>
<tr>
<td>top</td>
<td>Number</td>
<td>说明创建窗体的上坐标，不能为负值</td>
</tr>
<tr>
<td>status</td>
<td>Boolean</td>
<td>窗体是否显示状态栏，默认值为 no</td>
</tr>
<tr>
<td>width</td>
<td>Number</td>
<td>创建窗体的宽度，不能小于 100</td>
</tr>
</tbody>
</table>
<p>特性字符串中的每个特性使用逗号分隔，每个特性之间不允许有空格。</p>
<p><code>window.open</code> 函数新建立窗体后会返回新建窗体的 <code>window</code> 对象，通过此对象可以控制窗体（移动，改变大小，关闭）。</p>
<h2 id="close-函数">close 函数</h2>
<pre><code class="language-html">&lt;input type=&quot;button&quot; value=&quot;关闭已经打开的窗体！&quot; onclick=&quot;window.close();&quot; /&gt;
</code></pre>
<p><code>self.close();</code> 配合上 <code>setTimeout()</code> 可以实现，打开的窗口定时关闭的效果。</p>
<h2 id="对话框函数">对话框函数</h2>
<ul>
<li><code>alert()</code>：弹出消息对话框（对话框中有一个 OK 按钮）；</li>
<li><code>confirm()</code>：弹出消息对话框（对话框中包含一个 OK 按钮与 Cancel 按钮）；<code>confirm()</code> 消息对话框是排它的，也就是在用户点击对话框的按钮前，不能进行任何其它操作。<pre><code class="language-javascript">
if (confirm(&quot;确定跳大？&quot;)) {
    alert(&quot;果断跳大&quot;);
} else {
    alert(&quot;猥琐打钱&quot;);
</code></pre>
</li>
</ul>
<p>}<br>
```</p>
<ul>
<li><code>prompt()</code>：弹出消息对话框（对话框中包含一个 OK 按钮、Cancel 按钮与一个文本输入框）；函数有两个参数：
<ul>
<li><code>str1</code>：要显示在消息对话框中的文本，不可修改；</li>
<li><code>str2</code>：文本框中的内容，可以修改。</li>
</ul>
<pre><code class="language-javascript">
var sResult = prompt(&quot;请在下面输入你的姓名&quot;, &quot;aaa&quot;);
if (sResult != null) {
    alert(sResult + &quot;已经超越神的杀戮&quot;);
} else {
    alert(&quot;无名氏已经超越神的杀戮&quot;);
}
</code></pre>
</li>
</ul>
<h2 id="时间等待与间隔函数">时间等待与间隔函数</h2>
<h3 id="settimeout-函数-cleartimeout-函数">setTimeout() 函数 / clearTimeout() 函数</h3>
<p>在指定的时间后调用函数。</p>
<h4 id="语法">语法：</h4>
<ul>
<li><code>setTimeout(fun, time);</code>：<code>fun</code>：函数体或函数名，<code>time</code>：指定时间，单位为毫秒；</li>
<li><code>clearTimeout(id);</code>：取消指定的 <code>setTimeout</code> 函数将要执行的代码。<pre><code class="language-javascript">
setTimeout(function () {
    document.write(&quot;隔3秒后触发&quot;);   
}, 3000)    //在3秒后输出
setTimeout(fun1, 5000);     //在5秒后输出
function fun1() {
    document.write(&quot;函数名的方式5秒后触发&quot;);
}
</code></pre>
</li>
</ul>
<h3 id="setinterval-函数-clearinterval-函数">setInterval() 函数 / clearInterval() 函数</h3>
<p>在间隔指定的事件后重复调用函数。</p>
<h4 id="语法-2">语法：</h4>
<ul>
<li><code>setInterval(fun1, time)</code>：<code>fun</code>：函数体或函数名，<code>time</code>：指定的时间，单位为毫秒。会返回一个值，这个值是统计该函数的个数用的，第一个是 1，第二个就是 2，指明是第几个 <code>setInterval</code> 函数。</li>
<li><code>clearInterval(value)</code>：<code>value</code>：<code>setInterval()</code> 函数返回的值，根据这个值可以停止 <code>setInterval()</code> 的重复。</li>
</ul>
<p>注意，JavaScript 是单线程的，因此，这个定时函数实际上是通过插入执行队列的方式来实现。</p>
<p>如下面的代码：</p>
<pre><code class="language-javascript">function fn() {
    setTimeout(function () { alert('can you see me?'); }, 1000);
    while (true) { }
}
</code></pre>
<p><code>alert();</code> 永远都不会执行，因为线程一直被死循环占用了。</p>
<h2 id="windowlocation-子对象">window.location 子对象</h2>
<p>解析 URL 对象 <code>location:location</code> 对象的属性有：<code>href</code>，<code>protocal</code>，<code>host</code>，<code>hostname</code>，<code>port</code>，<code>pathname</code>，<code>search</code>，<code>hash</code>。</p>
<pre><code class="language-javascript">document.write(location.href + &quot;&lt;br/&gt;&quot;);        // http://localhost:4889/javascriptTest.html
document.write(location.protocol + &quot;&lt;br/&gt;&quot;);    // http:
document.write(location.host + &quot;&lt;br/&gt;&quot;);        // localhost:4889
document.write(location.hostname + &quot;&lt;br/&gt;&quot;);    // localhost
document.write(location.port + &quot;&lt;br/&gt;&quot;);        // 4889
document.write(location.pathname + &quot;&lt;br/&gt;&quot;);    // /javascriptTest.html
document.write(location.search + &quot;换行&lt;br/&gt;&quot;);  //http://localhost:4889/javascriptTest.html?id=1&amp;name=张三 如果路径是这样，则输出  ?id=1&amp;name=%E5%BC%A0%E4%B8%89
document.write(location.hash);                  //http: //localhost:4889/javascriptTest.html#kk=你好?id=1&amp;name=张三 如果路径是这样，则输出  #kk=你好?id=1&amp;name=张三
</code></pre>
<h3 id="载入新文档">载入新文档</h3>
<pre><code class="language-javascript">location.reload()　　               // 重新加载页面
location.replace()　                // 本窗口载入新文档
location.assign()　                 // 本窗口载入新文档
location = &quot;http://www.baidu.com&quot; 　// 跳转到指定网址
location = &quot;search.html&quot;　　　　　　 // 相对路径跳转
location = &quot;#top&quot;　　　　　　        // 跳转到页面顶部
</code></pre>
<h3 id="浏览历史">浏览历史</h3>
<ul>
<li><code>history</code> 对象的 <code>back()</code> 与 <code>forward()</code>：与浏览器的“后退”，“前进”功能一样。</li>
<li><code>history.go(-2);</code> 后退两个历史记录。</li>
</ul>
<h3 id="浏览器和屏幕信息">浏览器和屏幕信息</h3>
<pre><code class="language-javascript">navigator.appName 　　// Web 浏览器全称
navigator.appVersion　// Web 浏览器厂商和版本的详细字符串
navigator.userAgent 　// 客户端绝大部分信息
navigator.platform　　// 浏览器运行所在的操作系统
</code></pre>
<pre><code class="language-javascript">document.write(navigator.userAgent + &quot;&lt;br/&gt;&quot;); // Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.11 (KHTML, like Gecko) Chrome/23.0.1271.97 Safari/537.11
document.write(navigator.appName + &quot;&lt;br/&gt;&quot;);   // Netscape
document.write(navigator.appVersion + &quot;&lt;br/&gt;&quot;); // 5.0 (Windows NT 6.1) AppleWebKit/537.11 (KHTML, like Gecko) document.write(navigator.platform);             //Win32
</code></pre>
<h3 id="窗口的关系">窗口的关系</h3>
<ul>
<li><code>parent == self</code>：只有顶级窗口才返回 <code>true</code>；</li>
<li><code>parent</code> 和 <code>top</code> 属性允许脚本引用它的窗体的祖先，通常窗体是通过元素创建的，可以用来获取顶级窗口。</li>
</ul>
<h1 id="event-事件对象">event 事件对象</h1>
<p>最有用的两个操作：阻止事件冒泡。有时 <code>return false;</code> 不管用，这个或许就管用了。</p>
<pre><code class="language-javascript">// IE：
window.event.cancelBubble = true;//停止冒泡
window.event.returnValue = false;//阻止事件的默认行为

// Firefox：
event.preventDefault();  // 取消事件的默认行为  
event.stopPropagation(); // 阻止事件的传播
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[KeyCode 对照表]]></title>
        <id>https://faded.auspicious.space/post/keycode-map/</id>
        <link href="https://faded.auspicious.space/post/keycode-map/">
        </link>
        <updated>2020-04-24T04:51:17.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p><a href="http://www.t086.com/article/4315">Keycode对照表</a></p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p><a href="http://www.t086.com/article/4315">Keycode对照表</a></p>
</blockquote>
<!-- more -->
<h1 id="字母和数字键的键码值keycode">字母和数字键的键码值(keyCode)</h1>
<table>
<thead>
<tr>
<th style="text-align:center">按键</th>
<th style="text-align:center">键码</th>
<th style="text-align:center">按键</th>
<th style="text-align:center">键码</th>
<th style="text-align:center">按键</th>
<th style="text-align:center">键码</th>
<th style="text-align:center">按键</th>
<th style="text-align:center">键码</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">A</td>
<td style="text-align:center">65</td>
<td style="text-align:center">J</td>
<td style="text-align:center">74</td>
<td style="text-align:center">S</td>
<td style="text-align:center">83</td>
<td style="text-align:center">1</td>
<td style="text-align:center">49</td>
</tr>
<tr>
<td style="text-align:center">B</td>
<td style="text-align:center">66</td>
<td style="text-align:center">K</td>
<td style="text-align:center">75</td>
<td style="text-align:center">T</td>
<td style="text-align:center">84</td>
<td style="text-align:center">2</td>
<td style="text-align:center">50</td>
</tr>
<tr>
<td style="text-align:center">C</td>
<td style="text-align:center">67</td>
<td style="text-align:center">L</td>
<td style="text-align:center">76</td>
<td style="text-align:center">U</td>
<td style="text-align:center">85</td>
<td style="text-align:center">3</td>
<td style="text-align:center">51</td>
</tr>
<tr>
<td style="text-align:center">D</td>
<td style="text-align:center">68</td>
<td style="text-align:center">M</td>
<td style="text-align:center">77</td>
<td style="text-align:center">V</td>
<td style="text-align:center">86</td>
<td style="text-align:center">4</td>
<td style="text-align:center">52</td>
</tr>
<tr>
<td style="text-align:center">E</td>
<td style="text-align:center">69</td>
<td style="text-align:center">N</td>
<td style="text-align:center">78</td>
<td style="text-align:center">W</td>
<td style="text-align:center">87</td>
<td style="text-align:center">5</td>
<td style="text-align:center">53</td>
</tr>
<tr>
<td style="text-align:center">F</td>
<td style="text-align:center">70</td>
<td style="text-align:center">O</td>
<td style="text-align:center">79</td>
<td style="text-align:center">X</td>
<td style="text-align:center">88</td>
<td style="text-align:center">6</td>
<td style="text-align:center">54</td>
</tr>
<tr>
<td style="text-align:center">G</td>
<td style="text-align:center">71</td>
<td style="text-align:center">P</td>
<td style="text-align:center">80</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">89</td>
<td style="text-align:center">7</td>
<td style="text-align:center">55</td>
</tr>
<tr>
<td style="text-align:center">H</td>
<td style="text-align:center">72</td>
<td style="text-align:center">Q</td>
<td style="text-align:center">81</td>
<td style="text-align:center">Z</td>
<td style="text-align:center">90</td>
<td style="text-align:center">8</td>
<td style="text-align:center">56</td>
</tr>
<tr>
<td style="text-align:center">I</td>
<td style="text-align:center">73</td>
<td style="text-align:center">R</td>
<td style="text-align:center">82</td>
<td style="text-align:center">0</td>
<td style="text-align:center">48</td>
<td style="text-align:center">9</td>
<td style="text-align:center">57</td>
</tr>
</tbody>
</table>
<h1 id="数字键盘上的键的键码值keycode">数字键盘上的键的键码值(keyCode)</h1>
<table>
<thead>
<tr>
<th style="text-align:center">按键</th>
<th style="text-align:center">键码</th>
<th style="text-align:center">按键</th>
<th style="text-align:center">键码</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">96</td>
<td style="text-align:center">8</td>
<td style="text-align:center">104</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">97</td>
<td style="text-align:center">9</td>
<td style="text-align:center">105</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">98</td>
<td style="text-align:center">*</td>
<td style="text-align:center">106</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">99</td>
<td style="text-align:center">+</td>
<td style="text-align:center">107</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">100</td>
<td style="text-align:center">Enter</td>
<td style="text-align:center">108</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">101</td>
<td style="text-align:center">-</td>
<td style="text-align:center">109</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">102</td>
<td style="text-align:center">.</td>
<td style="text-align:center">110</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">103</td>
<td style="text-align:center">/</td>
<td style="text-align:center">111</td>
</tr>
</tbody>
</table>
<h1 id="功能键键码表keycode">功能键键码表(keyCode)</h1>
<table>
<thead>
<tr>
<th style="text-align:center">按键</th>
<th style="text-align:center">键码</th>
<th style="text-align:center">按键</th>
<th style="text-align:center">键码</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">F1</td>
<td style="text-align:center">112</td>
<td style="text-align:center">F7</td>
<td style="text-align:center">118</td>
</tr>
<tr>
<td style="text-align:center">F2</td>
<td style="text-align:center">113</td>
<td style="text-align:center">F8</td>
<td style="text-align:center">119</td>
</tr>
<tr>
<td style="text-align:center">F3</td>
<td style="text-align:center">114</td>
<td style="text-align:center">F9</td>
<td style="text-align:center">120</td>
</tr>
<tr>
<td style="text-align:center">F4</td>
<td style="text-align:center">115</td>
<td style="text-align:center">F10</td>
<td style="text-align:center">121</td>
</tr>
<tr>
<td style="text-align:center">F5</td>
<td style="text-align:center">116</td>
<td style="text-align:center">F11</td>
<td style="text-align:center">122</td>
</tr>
<tr>
<td style="text-align:center">F6</td>
<td style="text-align:center">117</td>
<td style="text-align:center">F12</td>
<td style="text-align:center">123</td>
</tr>
</tbody>
</table>
<h1 id="控制键键码表keycode">控制键键码表(keyCode)</h1>
<table>
<thead>
<tr>
<th style="text-align:center">按键</th>
<th style="text-align:center">键码</th>
<th style="text-align:center">按键</th>
<th style="text-align:center">键码</th>
<th style="text-align:center">按键</th>
<th style="text-align:center">键码</th>
<th style="text-align:center">按键</th>
<th style="text-align:center">键码</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">BackSpace</td>
<td style="text-align:center">8</td>
<td style="text-align:center">Esc</td>
<td style="text-align:center">27</td>
<td style="text-align:center">Right Arrow</td>
<td style="text-align:center">39</td>
<td style="text-align:center">-_</td>
<td style="text-align:center">189</td>
</tr>
<tr>
<td style="text-align:center">Tab</td>
<td style="text-align:center">9</td>
<td style="text-align:center">Spacebar</td>
<td style="text-align:center">32</td>
<td style="text-align:center">Dw Arrow</td>
<td style="text-align:center">40</td>
<td style="text-align:center">.&gt;</td>
<td style="text-align:center">190</td>
</tr>
<tr>
<td style="text-align:center">Clear</td>
<td style="text-align:center">12</td>
<td style="text-align:center">Page Up</td>
<td style="text-align:center">33</td>
<td style="text-align:center">Insert</td>
<td style="text-align:center">45</td>
<td style="text-align:center">/?</td>
<td style="text-align:center">191</td>
</tr>
<tr>
<td style="text-align:center">Enter</td>
<td style="text-align:center">13</td>
<td style="text-align:center">Page Down</td>
<td style="text-align:center">34</td>
<td style="text-align:center">Delete</td>
<td style="text-align:center">46</td>
<td style="text-align:center">`~</td>
<td style="text-align:center">192</td>
</tr>
<tr>
<td style="text-align:center">Shift</td>
<td style="text-align:center">16</td>
<td style="text-align:center">End</td>
<td style="text-align:center">35</td>
<td style="text-align:center">Num Lock</td>
<td style="text-align:center">144</td>
<td style="text-align:center">[{</td>
<td style="text-align:center">219</td>
</tr>
<tr>
<td style="text-align:center">Control</td>
<td style="text-align:center">17</td>
<td style="text-align:center">Home</td>
<td style="text-align:center">36</td>
<td style="text-align:center">;:</td>
<td style="text-align:center">186</td>
<td style="text-align:center">|</td>
<td style="text-align:center">220</td>
</tr>
<tr>
<td style="text-align:center">Alt</td>
<td style="text-align:center">18</td>
<td style="text-align:center">Left Arrow</td>
<td style="text-align:center">37</td>
<td style="text-align:center">=+</td>
<td style="text-align:center">187</td>
<td style="text-align:center">]}</td>
<td style="text-align:center">221</td>
</tr>
<tr>
<td style="text-align:center">Cape Lock</td>
<td style="text-align:center">20</td>
<td style="text-align:center">Up Arrow</td>
<td style="text-align:center">38</td>
<td style="text-align:center">,&lt;</td>
<td style="text-align:center">188</td>
<td style="text-align:center">'&quot;</td>
<td style="text-align:center">222</td>
</tr>
</tbody>
</table>
<h1 id="多媒体键码值keycode">多媒体键码值(keyCode)</h1>
<table>
<thead>
<tr>
<th style="text-align:center">按键</th>
<th style="text-align:center">键码</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">音量加</td>
<td style="text-align:center">175</td>
</tr>
<tr>
<td style="text-align:center">音量减</td>
<td style="text-align:center">174</td>
</tr>
<tr>
<td style="text-align:center">停止</td>
<td style="text-align:center">179</td>
</tr>
<tr>
<td style="text-align:center">静音</td>
<td style="text-align:center">173</td>
</tr>
<tr>
<td style="text-align:center">浏览器</td>
<td style="text-align:center">172</td>
</tr>
<tr>
<td style="text-align:center">邮件</td>
<td style="text-align:center">180</td>
</tr>
<tr>
<td style="text-align:center">搜索</td>
<td style="text-align:center">170</td>
</tr>
<tr>
<td style="text-align:center">收藏</td>
<td style="text-align:center">171</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[TCP 状态机]]></title>
        <id>https://faded.auspicious.space/post/tcp-state-machine/</id>
        <link href="https://faded.auspicious.space/post/tcp-state-machine/">
        </link>
        <updated>2020-04-24T04:33:45.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p><a href="https://www.jianshu.com/p/3c7a0771b67e">TCP状态机</a></p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p><a href="https://www.jianshu.com/p/3c7a0771b67e">TCP状态机</a></p>
</blockquote>
<!-- more -->
<h1 id="前言">前言</h1>
<p>本文将会首先介绍 TCP 的各个状态，然后描述 TCP 三次握手和四次挥手时的状态变化，最后重点介绍 <code>TIME_WAIT</code> 状态。</p>
<h1 id="tcp-连接状态">TCP 连接状态</h1>
<p>一个 TCP 连接在它的生命周期内会有不同的状态。</p>
<p>下图说明了 TCP 连接可能会有的状态，以及基于事件的状态转换。事件中有的是应用程序的操作，有的是接收到了网络发过来的请求。<br>
<img src="https://faded.auspicious.space/post-images/1587702959414.png" alt="" loading="lazy"></p>
<p>TCP状态及其描述如下表：</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>LISTEN</td>
<td>等待来自远程 TCP 应用程序的请求</td>
</tr>
<tr>
<td>SYN_SENT</td>
<td>发送连接请求后等待来自远程端点的确认。TCP 第一次握手后客户端所处的状态</td>
</tr>
<tr>
<td>SYN-RECEIVED</td>
<td>该端点已经接收到连接请求并发送确认。该端点正在等待最终确认。TCP 第二次握手后服务端所处的状态</td>
</tr>
<tr>
<td>ESTABLISHED</td>
<td>代表连接已经建立起来了。这是连接数据传输阶段的正常状态</td>
</tr>
<tr>
<td>FIN_WAIT_1</td>
<td>等待来自远程 TCP 的终止连接请求或终止请求的确认</td>
</tr>
<tr>
<td>FIN_WAIT_2</td>
<td>在此端点发送终止连接请求后，等待来自远程 TCP 的连接终止请求</td>
</tr>
<tr>
<td>CLOSE_WAIT</td>
<td>该端点已经收到来自远程端点的关闭请求，此 TCP 正在等待本地应用程序的连接终止请求</td>
</tr>
<tr>
<td>CLOSING</td>
<td>等待来自远程 TCP 的连接终止请求确认</td>
</tr>
<tr>
<td>LAST_ACK</td>
<td>等待先前发送到远程 TCP 的连接终止请求的确认</td>
</tr>
<tr>
<td>TIME_WAIT</td>
<td>等待足够的时间来确保远程  TCP 接收到其连接终止请求的确认</td>
</tr>
</tbody>
</table>
<h1 id="tcp三次握手">TCP三次握手</h1>
<p>当一个 TCP 连接建立时，发生了以下事情：</p>
<ol>
<li>服务端必须准备接收传入的连接。这通常通过调用 <code>socket</code>，<code>bind</code> 和 <code>listen</code> 来完成，称为被动打开。</li>
<li>客户端通过调用 <code>connect</code> 方法来发起一个主动的打开。客户端 TCP 会发送一个“同步”（<code>SYN</code>）段，它告诉服务器客户端在连接上发送的数据的初始序列号。通常情况下，<code>SYN</code> 没有发送数据，它只包含一个 IP 头，TCP 头和可能的 TCP 选项。</li>
<li>服务器必须确认（<code>ACK</code>）客户端的 <code>SYN</code>，并且服务器还必须发送自己的 <code>SYN</code>，其中包含服务器将在连接上发送的数据的初始序列号。</li>
<li>客户端必须确认服务器的 <code>SYN</code>。</li>
</ol>
<p>下图显示了 TCP 三次握手的过程，以及客户端和服务端状态的变化。</p>
<figure data-type="image" tabindex="1"><img src="https://faded.auspicious.space/post-images/1587703398483.png" alt="" loading="lazy"></figure>
<h1 id="tcp四次挥手">TCP四次挥手</h1>
<p>一个 TCP 连接需要四步断开：</p>
<ol>
<li>一个应用程序首先执行 <code>close</code>，发送 <code>FIN</code> 段，这个操作被称为主动关闭，这意味着这一端完成数据的发送。</li>
<li>执行 <code>FIN</code> 的另一端执行被动关闭，该端发送 <code>ACK</code>，确认该 <code>FIN</code>。</li>
<li>被动关闭的一端执行 <code>close</code>，向主动关闭的一方发送 <code>FIN</code>。</li>
<li>主动关闭的一方确认收到的 <code>FIN</code>。</li>
</ol>
<p>下图显示了一次典型的 TCP 四次挥手的过程，以及主动关闭方和被动关闭方的状态变化。在图中是客户端主动断开了连接，这里只是举个例子，服务端一样可以主动断开连接。<br>
<img src="https://faded.auspicious.space/post-images/1587703504332.png" alt="" loading="lazy"></p>
<h1 id="time_wait状态">TIME_WAIT状态</h1>
<p><code>TIME_WAIT</code> 状态应该是最让人疑惑的一个状态了。在上图中可以看到，执行主动断开的节点最后会进入这个状态，该节点会在此状态保存 2 倍的 MSL（最大段生存期）。</p>
<p>TCP 的每个实现都必须为 MSL 选择一个值。RFC 1122 推荐的值为两分钟，伯克利派的实现使用 30 秒。这也就是说 <code>TIME_WAIT</code> 状态会维持 1 到 4 分钟。MSL 是任何 IP 数据报可以在网络中生存的最长时间。这个时间是有限制的，因为每个数据报都包含一个 8 位的跳数限制，最大值是 255。虽然这是一个跳数限制而不是一个真正的时间限制，但是根据这个限制来假设数据报的最长生命周期依然是有意义的。</p>
<p>网络中数据报丢失的原因通常是路由异常。一旦路由崩溃或者两个路由之间的链路断开，路由协议需要几秒或几分钟才能稳定，并找到一条备用路径。在这段时间内，可能发生路由回路。同时假设丢失是一个 TCP 数据报，则发生 TCP 超时，并且重新发送分组，重传的分组通过一些备用路径达到最终目的地。但是一段时间后（该时间小于 MSL），路由循环被更正，在循环中丢失的数据报被发送到最终目的地。这个原始的数据报被称为丢失的副本或漫游副本。TCP 协议必须处理这些数据报。</p>
<p>维持 <code>TIME_WAIT</code> 有两个原因：</p>
<ol>
<li>可靠地实现 TCP 的全双工连接终止。</li>
<li>允许旧的重复数据段在网络中过期</li>
</ol>
<p>在四次挥手中，假设最后的 <code>ACK</code> 丢失了，被动关闭方会重发 <code>FIN</code>。主动关闭端必须维护状态，来允许被动关闭方重发最后的 <code>ACK</code>；如果它没有维护这个状态，将会对重发 <code>FIN</code> 返回 <code>RST</code>，被动关闭方会认为这是个错误。如果 TCP 正在执行彻底终止数据流的两个方向所需的所有工作（即全双工关闭），则必须正确处理这四个段中任何一个的丢失。所以执行主动关闭的一方必须在结束时保持 <code>TIME_WAIT</code> 状态：因为它可能必须重传最后的 <code>ACK</code>。</p>
<p>现在来聊维持 <code>TIME_WAIT</code> 状态的第二个原因。假设在主机 12.106.32.254 的 1500 端口和 206.168.112.219 的 21 端口之间有一个 TCP 连接。此连接关闭后，在相通的地址和端口建立了另外一个连接。由于 IP 地址和端口相同，所以后一种连接被称为先前连接的“化身”。TCP 必须防止连接中的旧副本在稍后再次出现，并被误解为属于同一连接的新“化身”。为此，TCP 将不会启动当前处于 <code>TIME_WAIT</code> 状态的连接的新“化身”。由于 <code>TIME_WAIT</code> 状态的持续时间时两倍的 MSL，因此 TCP 允许一个方向的数据在 MSL 秒内丢失，也允许回复在一个 MSL 秒内丢失。通过强制执行此规则，可以保证当一个 TCP 连接成功建立时，来自先前连接的所有旧的副本在网络中已过期。</p>
]]></content>
    </entry>
</feed>