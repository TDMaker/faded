<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://faded.auspicious.space</id>
    <title>Typhoeus</title>
    <updated>2020-04-29T07:02:53.502Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://faded.auspicious.space"/>
    <link rel="self" href="https://faded.auspicious.space/atom.xml"/>
    <logo>https://faded.auspicious.space/images/avatar.png</logo>
    <icon>https://faded.auspicious.space/favicon.ico</icon>
    <rights>All rights reserved 2020, Typhoeus</rights>
    <entry>
        <title type="html"><![CDATA[二维码的生成细节和原理]]></title>
        <id>https://faded.auspicious.space/post/qr-code-generation-details-and-principles/</id>
        <link href="https://faded.auspicious.space/post/qr-code-generation-details-and-principles/">
        </link>
        <updated>2020-04-29T03:11:23.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p><a href="https://coolshell.cn/articles/10590.html">二维码的生成细节和原理</a></p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p><a href="https://coolshell.cn/articles/10590.html">二维码的生成细节和原理</a></p>
</blockquote>
<!-- more -->
<p>二维码又称QR Code，QR 全称Quick Response，是一个近几年来移动设备上超流行的一种编码方式，它比传统的 Bar Code 条形码能存更多的信息，也能表示更多的数据类型：比如：字符，数字，日文，中文等等。这两天学习了一下二维码图片生成的相关细节，觉得这个玩意就是一个密码算法，在此写一这篇文章 ，揭露一下。供好学的人一同学习之。</p>
<p>关于QR Code Specification，可参看这个PDF：<a href="http://raidenii.net/files/datasheets/misc/qr_code.pdf">http://raidenii.net/files/datasheets/misc/qr_code.pdf</a>。</p>
<h1 id="1-基础知识">1 基础知识</h1>
<p>首先，我们先说一下二维码一共有 40 个尺寸。官方叫版本 Version。Version 1 是 21 x 21 的矩阵，Version 2 是  25 x 25 的矩阵，Version 3 是 29 的尺寸，每增加一个 version，就会增加 4 的尺寸，公式是：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>V</mi><mo>−</mo><mn>1</mn><mo>)</mo><mo>×</mo><mn>4</mn><mo>+</mo><mn>21</mn></mrow><annotation encoding="application/x-tex">(V-1)\times 4 + 21</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">1</span></span></span></span>（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span></span></span></span> 是版本号） 最高 Version 40，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mn>40</mn><mo>−</mo><mn>1</mn><mo>)</mo><mo>×</mo><mn>4</mn><mo>+</mo><mn>21</mn><mo>=</mo><mn>177</mn></mrow><annotation encoding="application/x-tex">(40-1)\times 4+21 = 177</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">4</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">7</span><span class="mord">7</span></span></span></span>，所以最高是 177 x 177 的正方形。</p>
<p>下面我们看看一个二维码的样例：<br>
<img src="https://faded.auspicious.space/post-images/1588130301517.jpeg" alt="" loading="lazy"></p>
<h2 id="11-定位图案">1.1 定位图案</h2>
<ul>
<li><strong>Position Detection Pattern</strong> 是定位图案，用于标记二维码的矩形大小。这三个定位图案有白边叫 Separators for Postion Detection Patterns。之所以三个而不是四个意思就是三个就可以标识一个矩形了。</li>
<li><strong>Timing Patterns</strong> 也是用于定位的。原因是二维码有 40 种尺寸，尺寸过大了后需要有根标准线，不然扫描的时候可能会扫歪了。</li>
<li><strong>Alignment Patterns</strong> 只有 Version 2 以上（包括 Version2）的二维码需要这个东东，同样是为了定位用的。</li>
</ul>
<h2 id="12-功能性数据">1.2 功能性数据</h2>
<ul>
<li><strong>Format Information</strong> 存在于所有的尺寸中，用于存放一些格式化数据的。</li>
<li><strong>Version Information</strong> 在 &gt;= Version 7 以上，需要预留两块 3 x 6 的区域存放一些版本信息。</li>
</ul>
<h2 id="13-数据码和纠错码">1.3 数据码和纠错码</h2>
<p>除了上述的那些地方，剩下的地方存放 Data Code 数据码 和 Error Correction Code 纠错码。</p>
<h1 id="2-数据编码">2 数据编码</h1>
<p>我们先来说说数据编码。QR码支持如下的编码：</p>
<ul>
<li><strong>Numeric mode</strong> 数字编码，从 0 到 9。如果需要编码的数字的个数不是 3 的倍数，那么，最后剩下的 1 或 2 位数会被转成 4 或 7 bits，则其它的每 3 位数字会被编成 10，12，14 bits，编成多长还要看二维码的尺寸（下面有一个表 Table 3 说明了这点）。</li>
<li><strong>Alphanumeric mode</strong> 字符编码。包括 0-9，大写的 A 到 Z（没有小写），以及符号 <code>$ % * + – . / :</code> 包括空格。这些字符会映射成一个字符索引表。如下所示：（其中的 SP 是空格，Char 是字符，Value 是其索引值） 编码的过程是把字符两两分组，然后转成下表的 45 进制，然后转成 11 bits 的二进制，如果最后有一个落单的，那就转成 6bits 的二进制。而编码模式和字符的个数需要根据不同的 version 尺寸编成 9，11 或 13 个二进制（如下表中 Table 3）。</li>
</ul>
<table>
<thead>
<tr>
<th>Char</th>
<th>Value</th>
<th>Char</th>
<th>Value</th>
<th>Char</th>
<th>Value</th>
<th>Char</th>
<th>Value</th>
<th>Char</th>
<th>Value</th>
<th>Char</th>
<th>Value</th>
<th>Char</th>
<th>Value</th>
<th>Char</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>6</td>
<td>6</td>
<td>C</td>
<td>12</td>
<td>I</td>
<td>18</td>
<td>O</td>
<td>24</td>
<td>U</td>
<td>30</td>
<td>SP</td>
<td>36</td>
<td>.</td>
<td>42</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>7</td>
<td>7</td>
<td>D</td>
<td>13</td>
<td>J</td>
<td>19</td>
<td>P</td>
<td>25</td>
<td>V</td>
<td>31</td>
<td>$</td>
<td>37</td>
<td>/</td>
<td>43</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>8</td>
<td>8</td>
<td>E</td>
<td>14</td>
<td>K</td>
<td>20</td>
<td>Q</td>
<td>26</td>
<td>W</td>
<td>32</td>
<td>%</td>
<td>38</td>
<td>:</td>
<td>44</td>
</tr>
<tr>
<td>3</td>
<td>3</td>
<td>9</td>
<td>9</td>
<td>F</td>
<td>15</td>
<td>L</td>
<td>21</td>
<td>R</td>
<td>27</td>
<td>X</td>
<td>33</td>
<td>*</td>
<td>39</td>
<td></td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>4</td>
<td>A</td>
<td>10</td>
<td>G</td>
<td>16</td>
<td>M</td>
<td>22</td>
<td>S</td>
<td>28</td>
<td>Y</td>
<td>34</td>
<td>+</td>
<td>40</td>
<td></td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>5</td>
<td>B</td>
<td>11</td>
<td>H</td>
<td>17</td>
<td>N</td>
<td>23</td>
<td>T</td>
<td>29</td>
<td>Z</td>
<td>35</td>
<td>-</td>
<td>41</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li><strong>Byte mode</strong>，字节编码，可以是 <code>0-255</code> 的 <code>ISO-8859-1</code> 字符。有些二维码的扫描器可以自动检测是否是 <code>UTF-8</code> 的编码。</li>
<li><strong>Kanji mode</strong> 这是日文编码，也是双字节编码。同样，也可以用于中文编码。日文和汉字的编码会减去一个值。如：在 <code>0x8140</code> to <code>0x9FFC</code> 中的字符会减去 <code>8140</code>，在 <code>0xE040</code> 到 <code>0xEBBF</code> 中的字符要减去 <code>0xC140</code>，然后把结果前两个 16 进制位拿出来乘以 <code>0xC0</code>，然后再加上后两个 16 进制位，最后转成 13 bit 的编码。如下图示例：</li>
</ul>
<table>
<thead>
<tr>
<th>Input character</th>
<th>“点”</th>
<th>“茗”</th>
</tr>
</thead>
<tbody>
<tr>
<td>(Shift JIS value):</td>
<td>935F</td>
<td>E4AA</td>
</tr>
<tr>
<td>1. Subtract 8140 or C140</td>
<td>935F - 8140 = 121F</td>
<td>E4AA - C140 = 236A</td>
</tr>
<tr>
<td>2. Multiply m.s.b. by C0</td>
<td>12 × C0 = D80</td>
<td>23 × C0 = 1A40</td>
</tr>
<tr>
<td>3. Add I.s.b.</td>
<td>D80 + 1F = D9F</td>
<td>1A40 + 6A = 1AAA</td>
</tr>
<tr>
<td>4. Convert to 13 bit binary</td>
<td>0D9F → 0 1101 1001 1111</td>
<td>1AAA → 1 1010 1010 1010</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>Extended Channel Interpretation (ECI) mode</strong> 主要用于特殊的字符集。并不是所有的扫描器都支持这种编码。</li>
<li><strong>Structured Append mode</strong> 用于混合编码，也就是说，这个二维码中包含了多种编码格式。</li>
<li><strong>FNC1 mode</strong> 这种编码方式主要是给一些特殊的工业或行业用的。比如 GS1 条形码之类的。</li>
</ul>
<p>简单起见，后面三种不会在本文 中讨论。</p>
<p>下面两张表中，</p>
<ul>
<li><strong>Table 2</strong> 是各个编码格式的“编号”，这个东西要写在 Format Information 中。注：中文是 <code>1101</code>。</li>
<li><strong>Table 3</strong> 表示了，不同版本（尺寸）的二维码，对于，数字，字符，字节和 Kanji 模式下，对于单个编码的 2 进制的位数。（在二维码的规格说明书中，有各种各样的编码规范表，后面还会提到）。</li>
</ul>
<p><strong>Table 2 - Mode indicators</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">Mode</th>
<th style="text-align:center">Indicator</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ECI</td>
<td style="text-align:center">0111</td>
</tr>
<tr>
<td style="text-align:center">Numeric</td>
<td style="text-align:center">0001</td>
</tr>
<tr>
<td style="text-align:center">Alphanumeric</td>
<td style="text-align:center">0010</td>
</tr>
<tr>
<td style="text-align:center">8-bit Byte</td>
<td style="text-align:center">0100</td>
</tr>
<tr>
<td style="text-align:center">Kanji</td>
<td style="text-align:center">1000</td>
</tr>
<tr>
<td style="text-align:center">Structured Append</td>
<td style="text-align:center">0011</td>
</tr>
<tr>
<td style="text-align:center">FNC1</td>
<td style="text-align:center">0101(First position) <br> 1001(Second posotion)</td>
</tr>
<tr>
<td style="text-align:center">Terminator(End of Message)</td>
<td style="text-align:center">0000</td>
</tr>
</tbody>
</table>
<p><strong>Table 3 - Number of bits in Character Count Indicator</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">Version</th>
<th style="text-align:center">Numeric Mode</th>
<th style="text-align:center">Alphanumeric Mode</th>
<th style="text-align:center">8-bit Byte Mode</th>
<th style="text-align:center">Kanji Mode</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1 to 9</td>
<td style="text-align:center">10</td>
<td style="text-align:center">9</td>
<td style="text-align:center">8</td>
<td style="text-align:center">8</td>
</tr>
<tr>
<td style="text-align:center">10 to 26</td>
<td style="text-align:center">12</td>
<td style="text-align:center">11</td>
<td style="text-align:center">16</td>
<td style="text-align:center">10</td>
</tr>
<tr>
<td style="text-align:center">27 to 40</td>
<td style="text-align:center">14</td>
<td style="text-align:center">13</td>
<td style="text-align:center">16</td>
<td style="text-align:center">12</td>
</tr>
</tbody>
</table>
<p>下面我们看几个示例：</p>
<h2 id="21-示例一数字编码">2.1 示例一：数字编码</h2>
<p>在 Version 1 的尺寸下，纠错级别为 <code>H</code> 的情况下，编码：<code>01234567</code>：</p>
<ol>
<li>把上述数字分成三组：<code>012 345 67</code>。</li>
<li>把他们转成二进制：<code>012</code> 转成 <code>0000001100</code>；<code>345</code> 转成 <code>0101011001</code>；<code>67</code> 转成 <code>1000011</code>。</li>
<li>把这三个二进制串起来：<code>0000001100 0101011001 1000011</code>。</li>
<li>把数字的个数转成二进制（Version 1-H 是10 bits）：8 个数字的二进制是 <code>0000001000</code>。</li>
<li>把数字编码的标志 <code>0001</code> 和第 4 步的编码加到前面：<code>0001 0000001000 0000001100 0101011001 1000011</code>。</li>
</ol>
<h2 id="22-示例二字符编码">2.2 示例二：字符编码</h2>
<p>在 Version 1 的尺寸下，纠错级别为 <code>H</code> 的情况下，编码：<code>AC-42</code>：</p>
<ol>
<li>从字符索引表中找到 <code>AC-42</code> 这五个字条的索引 <code>(10,12,41,4,2)</code>。</li>
<li>两两分组：<code>(10,12) (41,4) (2)</code>。</li>
<li>把每一组转成 11 bits 的二进制:
<ul>
<li><code>(10,12) 10*45+12</code> 等于 <code>462</code> 转成 <code>00111001110</code>；</li>
<li><code>(41,4) 41*45+4</code> 等于 <code>1849</code> 转成 <code>11100111001</code>；</li>
<li><code>(2)</code> 等于 <code>2</code> 转成 <code>000010</code>。</li>
</ul>
</li>
<li>把这些二进制连接起来：<code>00111001110 11100111001 000010</code>。</li>
<li>把字符的个数转成二进制（Version 1-H 为 9 bits）：5 个字符，5 转成 <code>000000101</code>。</li>
<li>在头上加上编码标识 <code>0010</code> 和第 5 步的个数编码:  <code>0010 000000101 00111001110 11100111001 000010</code>。</li>
</ol>
<h1 id="3-结束符和补齐符">3 结束符和补齐符</h1>
<p>假如我们有个 HELLO WORLD 的字符串要编码，根据上面的示例二，我们可以得到下面的编码：</p>
<table>
<thead>
<tr>
<th style="text-align:center">编码</th>
<th style="text-align:center">字符数</th>
<th style="text-align:center">HELLO WORLD 的编码</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0010</td>
<td style="text-align:center">000001011</td>
<td style="text-align:center">01100001011 01111000110 10001011100 10110111000 10011010100 001101</td>
</tr>
</tbody>
</table>
<p>我们还要加上结束符：</p>
<table>
<thead>
<tr>
<th style="text-align:center">编码</th>
<th style="text-align:center">字符数</th>
<th style="text-align:center">HELLO WORLD 的编码</th>
<th style="text-align:center">结束</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0010</td>
<td style="text-align:center">000001011</td>
<td style="text-align:center">01100001011 01111000110 10001011100 10110111000 10011010100 001101</td>
<td style="text-align:center">0000</td>
</tr>
</tbody>
</table>
<h2 id="31-按-8-bits-重排">3.1 按 8 bits 重排</h2>
<p>如果所有的编码加起来不是 8 个倍数我们还要在后面加上足够的 <code>0</code>，比如上面一共有 78 个 bits，所以，我们还要加上 2 个 <code>0</code>，然后按 8 个 bits 分好组：</p>
<p>00100000   01011011   00001011   01111000   11010001   01110010   11011100   01001101   01000011   010000<font color="red">00</font></p>
<h2 id="32-补齐码padding-bytes">3.2 补齐码（Padding Bytes）</h2>
<p>最后，如果如果还没有达到我们最大的 bits 数的限制，我们还要加一些补齐码（Padding Bytes），Padding Bytes 就是重复下面的两个 bytes：<code>11101100 00010001</code>（这两个二进制转成十进制是 <code>236</code> 和 <code>17</code>，我也不知道为什么，只知道 Spec 上是这么写的）关于每一个 version 的每一种纠错级别的最大 Bits 限制，可以参看 QR Code Spec 的第 28 页到 32 页的 Table-7 一表。</p>
<p>假设我们需要编码的是 Version 1 的 Q 纠错级，那么，其最大需要 104 个 bits，而我们上面只有 80 个 bits，所以，还需要补 24 个 bits，也就是需要 3 个 Padding Bytes，我们就添加三个，于是得到下面的编码：</p>
<p>00100000 01011011 00001011 01111000 11010001 01110010 11011100 01001101 01000011 01000000 <font color="red">11101100 00010001 11101100</font></p>
<p>上面的编码就是数据码了，叫 Data Codewords，每一个 8 bits 叫一个 codeword，我们还要对这些数据码加上纠错信息。</p>
<h1 id="4-纠错码">4 纠错码</h1>
<p>上面我们说到了一些纠错级别，Error Correction Code Level，二维码中有四种级别的纠错，这就是为什么二维码有残缺还能扫出来，也就是为什么有人在二维码的中心位置加入图标。</p>
<table>
<thead>
<tr>
<th style="text-align:center">错误</th>
<th style="text-align:center">修正容量</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">L 水平</td>
<td style="text-align:center">7% 的字码可被修正</td>
</tr>
<tr>
<td style="text-align:center">M 水平</td>
<td style="text-align:center">15% 的字码可被修正</td>
</tr>
<tr>
<td style="text-align:center">Q 水平</td>
<td style="text-align:center">25% 的字码可被修正</td>
</tr>
<tr>
<td style="text-align:center">H 水平</td>
<td style="text-align:center">30% 的字码可被修正</td>
</tr>
</tbody>
</table>
<p>那么，QR 是怎么对数据码加上纠错码的？首先，我们需要对数据码进行分组，也就是分成不同的 Block，然后对各个 Block 进行纠错编码，对于如何分组，我们可以查看 QR Code Spec 的第 33 页到 44 页的 Table-13 到 Table-22 的定义表。注意最后两列：</p>
<ul>
<li><strong>Number of Error Code Correction Blocks</strong>：需要分多少个块。</li>
<li><strong>Error Correction Code Per Blocks</strong>：每一个块中的 code 个数，所谓的 code 的个数，也就是有多少个 8 bits 的字节。</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">134</td>
<td style="text-align:center">L</td>
<td style="text-align:center">26</td>
<td style="text-align:center">1</td>
<td style="text-align:center">(134, 108, 13)</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">M</td>
<td style="text-align:center">48</td>
<td style="text-align:center">2</td>
<td style="text-align:center">(67, 43, 12)</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">Q</td>
<td style="text-align:center">72</td>
<td style="text-align:center">2<br>2</td>
<td style="text-align:center">(33, 15, 9)<br>(34, 16, 9)</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">H</td>
<td style="text-align:center">88</td>
<td style="text-align:center">2<br>2</td>
<td style="text-align:center">(33, 11, 11)<br>(34, 12, 11)</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">172</td>
<td style="text-align:center">L</td>
<td style="text-align:center">36</td>
<td style="text-align:center">2</td>
<td style="text-align:center">(86, 68, 9)</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">M</td>
<td style="text-align:center">64</td>
<td style="text-align:center">4</td>
<td style="text-align:center">(43, 27, 8)</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">Q</td>
<td style="text-align:center">96</td>
<td style="text-align:center">4</td>
<td style="text-align:center">(43, 19, 12)</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">H</td>
<td style="text-align:center">112</td>
<td style="text-align:center">4</td>
<td style="text-align:center">(43, 15, 14)</td>
</tr>
</tbody>
</table>
<ul>
<li>a (c, k, r):
<ul>
<li>c = total number of codewords</li>
<li>k = number of data codewords</li>
<li>r = number of error correction capacity</li>
</ul>
</li>
<li>b Error correction capacity is less than half the number of error correction codewords to reduce the probability of misdecodes.</li>
</ul>
<p>举个例子：上述的 Version 5 + Q 纠错级：需要 4 个 Blocks（2 个 Blocks 为一组，共两组），头一组的两个 Blocks 中各 15 个 bits 数据 + 各 9 个 bits 的纠错码（注：表中的 codewords 就是一个 8 bits 的 byte）（再注：最后一例中的（c, k, r）的公式为：<code>c = k + 2 * r</code>，因为后脚注解释了：纠错码的容量小于纠错码的一半）。</p>
<p>下图给一个 5-Q 的示例（因为二进制写起来会让表格太大，所以，我都用了十进制，我们可以看到每一块的纠错码有 18 个 codewords，也就是 18 个 8 bits 的二进制数）。</p>
<table>
<thead>
<tr>
<th style="text-align:center">组</th>
<th style="text-align:center">块</th>
<th style="text-align:center">数据</th>
<th style="text-align:center">对每个块的纠错码</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">67 85 70 134 87 38 85 194 119 50 6 18 6 103 38</td>
<td style="text-align:center">213 199 11 45 115 247 241 223 229 248 154 117 154 111 86 161 111 39</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">2</td>
<td style="text-align:center">246 246 66 7 118 134 242 7 38 86 22 198 199 146 6</td>
<td style="text-align:center">87 204 96 60 202 182 124 157 200 134 27 129 209 17 163 163 120 133</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
<td style="text-align:center">182 230 247 119 50 7 118 134 87 38 82 6 134 151 50 7</td>
<td style="text-align:center">148 116 177 212 76 133 75 242 238 76 195 230 189 10 108 240 192 141</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">2</td>
<td style="text-align:center">70 247 118 86 194 6 151 50 16 236 17 236 17 236 17 236</td>
<td style="text-align:center">235 159 5 173 24 147 59 33 106 40 255 172 82 2 131 32 178 236</td>
</tr>
</tbody>
</table>
<p>注：二维码的纠错码主要是通过 Reed-Solomon error correction（里德-所罗门纠错算法）来实现的。对于这个算法，对于我来说是相当的复杂，里面有很多的数学计算，比如：多项式除法，把 1-255 的数映射成 2 的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 次方（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>255</mn></mrow><annotation encoding="application/x-tex">0\le n \le 255</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">5</span><span class="mord">5</span></span></span></span>）的伽罗瓦域 Galois Field 之类的神一样的东西，以及基于这些基础的纠错数学公式，因为我的数据基础差，对于我来说太过复杂，所以我一时半会儿还有点没搞明白，还在学习中，所以，我在这里就不展开说这些东西了。还请大家见谅了。（当然，如果有朋友很明白，也繁请教教我）</p>
<h1 id="5-最终编码">5 最终编码</h1>
<h2 id="51-穿插放置">5.1 穿插放置</h2>
<p>如果你以为我们可以开始画图，你就错了。二维码的混乱技术还没有玩完，它还要把数据码和纠错码的各个 codewords 交替放在一起。如何交替呢，规则如下：</p>
<p>对于数据码：把每个块的第一个 codewords 先拿出来按顺度排列好，然后再取第一块的第二个，如此类推。如：上述示例中的 Data Codewords 如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">块 1</td>
<td style="text-align:center">67</td>
<td style="text-align:center">85</td>
<td style="text-align:center">70</td>
<td style="text-align:center">134</td>
<td style="text-align:center">87</td>
<td style="text-align:center">38</td>
<td style="text-align:center">85</td>
<td style="text-align:center">194</td>
<td style="text-align:center">119</td>
<td style="text-align:center">50</td>
<td style="text-align:center">6</td>
<td style="text-align:center">18</td>
<td style="text-align:center">6</td>
<td style="text-align:center">103</td>
<td style="text-align:center">38</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">块 2</td>
<td style="text-align:center">246</td>
<td style="text-align:center">246</td>
<td style="text-align:center">66</td>
<td style="text-align:center">7</td>
<td style="text-align:center">118</td>
<td style="text-align:center">134</td>
<td style="text-align:center">242</td>
<td style="text-align:center">7</td>
<td style="text-align:center">38</td>
<td style="text-align:center">86</td>
<td style="text-align:center">22</td>
<td style="text-align:center">198</td>
<td style="text-align:center">199</td>
<td style="text-align:center">146</td>
<td style="text-align:center">6</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">块 3</td>
<td style="text-align:center">182</td>
<td style="text-align:center">230</td>
<td style="text-align:center">247</td>
<td style="text-align:center">119</td>
<td style="text-align:center">50</td>
<td style="text-align:center">7</td>
<td style="text-align:center">118</td>
<td style="text-align:center">134</td>
<td style="text-align:center">87</td>
<td style="text-align:center">38</td>
<td style="text-align:center">82</td>
<td style="text-align:center">6</td>
<td style="text-align:center">134</td>
<td style="text-align:center">151</td>
<td style="text-align:center">50</td>
<td style="text-align:center">7</td>
</tr>
<tr>
<td style="text-align:center">块 4</td>
<td style="text-align:center">70</td>
<td style="text-align:center">247</td>
<td style="text-align:center">118</td>
<td style="text-align:center">86</td>
<td style="text-align:center">194</td>
<td style="text-align:center">6</td>
<td style="text-align:center">151</td>
<td style="text-align:center">50</td>
<td style="text-align:center">16</td>
<td style="text-align:center">236</td>
<td style="text-align:center">17</td>
<td style="text-align:center">236</td>
<td style="text-align:center">17</td>
<td style="text-align:center">236</td>
<td style="text-align:center">17</td>
<td style="text-align:center">236</td>
</tr>
</tbody>
</table>
<p>我们先取第一列的：67，246，182，70</p>
<p>然后再取第二列的：67，246，182，70，85，246，230，247</p>
<p>如此类推：67，246，182，70，85，246，230，247………，38，6，50，17，7，236</p>
<p>对于纠错码，也是一样：</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">块 1</td>
<td style="text-align:center">213</td>
<td style="text-align:center">199</td>
<td style="text-align:center">11</td>
<td style="text-align:center">45</td>
<td style="text-align:center">115</td>
<td style="text-align:center">247</td>
<td style="text-align:center">241</td>
<td style="text-align:center">223</td>
<td style="text-align:center">229</td>
<td style="text-align:center">248</td>
<td style="text-align:center">154</td>
<td style="text-align:center">117</td>
<td style="text-align:center">154</td>
<td style="text-align:center">111</td>
<td style="text-align:center">86</td>
<td style="text-align:center">161</td>
<td style="text-align:center">111</td>
<td style="text-align:center">39</td>
</tr>
<tr>
<td style="text-align:center">块 2</td>
<td style="text-align:center">87</td>
<td style="text-align:center">204</td>
<td style="text-align:center">96</td>
<td style="text-align:center">60</td>
<td style="text-align:center">202</td>
<td style="text-align:center">182</td>
<td style="text-align:center">124</td>
<td style="text-align:center">157</td>
<td style="text-align:center">200</td>
<td style="text-align:center">134</td>
<td style="text-align:center">27</td>
<td style="text-align:center">129</td>
<td style="text-align:center">209</td>
<td style="text-align:center">17</td>
<td style="text-align:center">163</td>
<td style="text-align:center">163</td>
<td style="text-align:center">120</td>
<td style="text-align:center">133</td>
</tr>
<tr>
<td style="text-align:center">块 3</td>
<td style="text-align:center">148</td>
<td style="text-align:center">116</td>
<td style="text-align:center">177</td>
<td style="text-align:center">212</td>
<td style="text-align:center">76</td>
<td style="text-align:center">133</td>
<td style="text-align:center">75</td>
<td style="text-align:center">242</td>
<td style="text-align:center">238</td>
<td style="text-align:center">76</td>
<td style="text-align:center">195</td>
<td style="text-align:center">230</td>
<td style="text-align:center">189</td>
<td style="text-align:center">10</td>
<td style="text-align:center">108</td>
<td style="text-align:center">240</td>
<td style="text-align:center">192</td>
<td style="text-align:center">141</td>
</tr>
<tr>
<td style="text-align:center">块 4</td>
<td style="text-align:center">235</td>
<td style="text-align:center">159</td>
<td style="text-align:center">5</td>
<td style="text-align:center">173</td>
<td style="text-align:center">24</td>
<td style="text-align:center">147</td>
<td style="text-align:center">59</td>
<td style="text-align:center">33</td>
<td style="text-align:center">106</td>
<td style="text-align:center">40</td>
<td style="text-align:center">255</td>
<td style="text-align:center">172</td>
<td style="text-align:center">82</td>
<td style="text-align:center">2</td>
<td style="text-align:center">131</td>
<td style="text-align:center">32</td>
<td style="text-align:center">178</td>
<td style="text-align:center">236</td>
</tr>
</tbody>
</table>
<p>和数据码取的一样，得到：213，87，148，235，199，204，116，159，…… …… 39，133，141，236</p>
<p>然后，再把这两组放在一起（纠错码放在数据码之后）得到：</p>
<p>67, 246, 182, 70, 85, 246, 230, 247, 70, 66, 247, 118, 134, 7, 119, 86, 87, 118, 50, 194, 38, 134, 7, 6, 85, 242, 118, 151, 194, 7, 134, 50, 119, 38, 87, 16, 50, 86, 38, 236, 6, 22, 82, 17, 18, 198, 6, 236, 6, 199, 134, 17, 103, 146, 151, 236, 38, 6, 50, 17, 7, 236, 213, 87, 148, 235, 199, 204, 116, 159, 11, 96, 177, 5, 45, 60, 212, 173, 115, 202, 76, 24, 247, 182, 133, 147, 241, 124, 75, 59, 223, 157, 242, 33, 229, 200, 238, 106, 248, 134, 76, 40, 154, 27, 195, 255, 117, 129, 230, 172, 154, 209, 189, 82, 111, 17, 10, 2, 86, 163, 108, 131, 161, 163, 240, 32, 111, 120, 192, 178, 39, 133, 141, 236</p>
<p>这就是我们的数据区。</p>
<h2 id="52-remainder-bits">5.2 Remainder Bits</h2>
<p>最后再加上 Reminder Bits，对于某些 version 的 QR，上面的还不够长度，还要加上 Remainder Bits，比如：上述的 5Q 版的二维码，还要加上 7 个 bits，Remainder Bits 加零就好了。关于哪些 version 需要多少个 Remainder bit，可以参看 <a href="http://raidenii.net/files/datasheets/misc/qr_code.pdf">QR Code Spec</a> 的第 15 页的 Table-1 的定义表。</p>
<h1 id="6-画二维码图">6 画二维码图</h1>
<h2 id="61-position-detection-pattern">6.1 Position Detection Pattern</h2>
<p>首先，先把 Position Detection 图案画在三个角上。（无论 version 如何，这个图案的尺寸就是这么大）。<br>
<img src="https://faded.auspicious.space/post-images/1588136941190.png" alt="" loading="lazy"></p>
<h2 id="62-alignment-pattern">6.2 Alignment Pattern</h2>
<p>然后，再把 Alignment 图案画上（无论 version 如何，这个图案的尺寸就是这么大）。<br>
<img src="https://faded.auspicious.space/post-images/1588136972101.png" alt="" loading="lazy"></p>
<p>关于 Alignment 的位置，可以查看 <a href="http://raidenii.net/files/datasheets/misc/qr_code.pdf">QR Code Spec</a>  的第 81 页的 Table-E.1 的定义表（下表是不完全表格）。</p>
<table>
  <caption>Table E.1 - Row/column coordinates of center module of Alignment Patterns</caption>
  <theader>
    <tr>
      <td>Version</td>
      <td>Number of Alignment Patterns</td>
      <td colspan="7">Row/Column coordinates of center module</td>
    </tr>
  </theader>
  <tbody>
    <tr><td>1</td><td>0</td><td>-</td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
    <tr><td>2</td><td>1</td><td>6</td><td>18</td><td></td><td></td><td></td><td></td><td></td></tr>
    <tr><td>3</td><td>1</td><td>6</td><td>22</td><td></td><td></td><td></td><td></td><td></td></tr>
    <tr><td>4</td><td>1</td><td>6</td><td>26</td><td></td><td></td><td></td><td></td><td></td></tr>
    <tr><td>5</td><td>1</td><td>6</td><td>30</td><td></td><td></td><td></td><td></td><td></td></tr>
    <tr><td>6</td><td>1</td><td>6</td><td>34</td><td></td><td></td><td></td><td></td><td></td></tr>
    <tr><td>7</td><td>6</td><td>6</td><td>22</td><td>38</td><td></td><td></td><td></td><td></td></tr>
    <tr><td>8</td><td>6</td><td>6</td><td>24</td><td>42</td><td></td><td></td><td></td><td></td></tr>
    <tr><td>9</td><td>6</td><td>6</td><td>26</td><td>46</td><td></td><td></td><td></td><td></td></tr>
    <tr><td>10</td><td>6</td><td>6</td><td>28</td><td>50</td><td></td><td></td><td></td><td></td></tr>
  </tbody>
</table>
<p>下图是根据上述表格中的 Version 8 的一个例子（6，24，42）<br>
<img src="https://faded.auspicious.space/post-images/1588140727054.png" alt="" loading="lazy"></p>
<h2 id="63-timing-pattern">6.3 Timing Pattern</h2>
<p>接下来是 Timing Pattern 的线（这个不用多说了）<br>
<img src="https://faded.auspicious.space/post-images/1588140769566.png" alt="" loading="lazy"></p>
<h2 id="64-format-information">6.4 Format Information</h2>
<p>再接下来是 Formation Information，下图中的蓝色部分。<br>
<img src="https://faded.auspicious.space/post-images/1588140809329.png" alt="" loading="lazy"><br>
Format Information 是一个 15 个 bits 的信息，每一个 bit 的位置如下图所示：（注意图中的 Dark Module，那是永远出现的）<br>
<img src="https://faded.auspicious.space/post-images/1588140853639.png" alt="" loading="lazy"></p>
<p>这 15 个 bits 中包括：</p>
<ul>
<li>5 个数据 bits：其中，2 个 bits 用于表示使用什么样的 Error Correction Level， 3 个 bits 表示使用什么样的 Mask。</li>
<li>10 个纠错 bits。主要通过 BCH Code 来计算。</li>
</ul>
<p>然后 15 个 bits 还要与 <code>101010000010010</code> 做 <code>XOR</code> 操作。这样就保证不会因为我们选用了 <code>00</code> 的纠错级别和 <code>000</code> 的 Mask，从而造成全部为白色，这会增加我们的扫描器的图像识别的困难。</p>
<p>下面是一个示例：<br>
<img src="https://faded.auspicious.space/post-images/1588140948528.png" alt="" loading="lazy"></p>
<p>关于 Error Correction Level 如下表所示：</p>
<table>
<thead>
<tr>
<th style="text-align:center">Error Correction Level</th>
<th style="text-align:center">Binary indicator</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">L</td>
<td style="text-align:center">01</td>
</tr>
<tr>
<td style="text-align:center">M</td>
<td style="text-align:center">00</td>
</tr>
<tr>
<td style="text-align:center">Q</td>
<td style="text-align:center">11</td>
</tr>
<tr>
<td style="text-align:center">H</td>
<td style="text-align:center">10</td>
</tr>
</tbody>
</table>
<p>关于Mask图案如后面的Table 23所示。</p>
<h2 id="65-version-information">6.5 Version Information</h2>
<p>再接下来是 Version Information（版本 7 以后需要这个编码），下图中的蓝色部分。<br>
<img src="https://faded.auspicious.space/post-images/1588141142733.png" alt="" loading="lazy"><br>
Version Information 一共是 18 个 bits，其中包括 6 个 bits 的版本号以及 12 个 bits 的纠错码，下面是一个示例：<br>
<img src="https://faded.auspicious.space/post-images/1588141174000.png" alt="" loading="lazy"><br>
而其填充位置如下：<br>
<img src="https://faded.auspicious.space/post-images/1588141190178.png" alt="" loading="lazy"></p>
<h2 id="66-数据和数据纠错码">6.6 数据和数据纠错码</h2>
<p>然后是填接我们的最终编码，最终编码的填充方式如下：从左下角开始沿着红线填我们的各个 bits，<code>1</code> 是黑色，<code>0</code> 是白色。如果遇到了上面的非数据区，则绕开或跳过。<br>
<img src="https://faded.auspicious.space/post-images/1588141231547.png" alt="" loading="lazy"></p>
<h2 id="67-掩码图案">6.7 掩码图案</h2>
<p>这样下来，我们的图就填好了，但是，也许那些点并不均衡，如果出现大面积的空白或黑块，会告诉我们扫描识别的困难。所以，我们还要做 Masking 操作（靠，还嫌不复杂）QR 的 Spec 中说了，QR 有 8 个 Mask 你可以使用，如下所示：其中，各个 mask 的公式在各个图下面。所谓 mask，说白了，就是和上面生成的图做 <code>XOR</code> 操作。Mask 只会和数据区进行 <code>XOR</code>，不会影响功能区。（注：选择一个合适的 Mask 也是有算法的）<br>
<img src="https://faded.auspicious.space/post-images/1588141296426.png" alt="" loading="lazy"><br>
其 Mask 的标识码如下所示：（其中的 i, j 分别对应于上图的 x, y）</p>
<p><strong>Table 23 - Mask pattern generation conditions</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">Mask Pattern Reference</th>
<th>Condition</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">000</td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>i</mi><mo>+</mo><mi>j</mi><mo>)</mo><mspace></mspace><mspace width="0.6666666666666666em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mn>2</mn><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">(i+j)\mod 2 = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6666666666666666em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></td>
</tr>
<tr>
<td style="text-align:center">001</td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mspace></mspace><mspace width="0.6666666666666666em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mn>2</mn><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">i \mod 2 = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6666666666666666em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></td>
</tr>
<tr>
<td style="text-align:center">010</td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi><mspace></mspace><mspace width="0.6666666666666666em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mn>3</mn><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">j \mod 3 = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6666666666666666em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></td>
</tr>
<tr>
<td style="text-align:center">011</td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>i</mi><mo>+</mo><mi>j</mi><mo>)</mo><mspace></mspace><mspace width="0.6666666666666666em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mn>3</mn><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">(i+j)\mod 3 = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6666666666666666em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></td>
</tr>
<tr>
<td style="text-align:center">100</td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mo>(</mo><mi>i</mi><mtext> div </mtext><mn>2</mn><mo>)</mo><mo>+</mo><mo>(</mo><mi>j</mi><mtext> div </mtext><mn>3</mn><mo>)</mo><mo>)</mo><mspace></mspace><mspace width="0.6666666666666666em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mn>2</mn><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">((i \text{ div } 2)+(j \text{ div } 3)) \mod 2 = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mord text"><span class="mord"> div </span></span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord text"><span class="mord"> div </span></span><span class="mord">3</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6666666666666666em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></td>
</tr>
<tr>
<td style="text-align:center">101</td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>i</mi><mi>j</mi><mo>)</mo><mspace></mspace><mspace width="0.6666666666666666em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mn>2</mn><mo>+</mo><mo>(</mo><mi>i</mi><mi>j</mi><mo>)</mo><mspace></mspace><mspace width="0.6666666666666666em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mn>3</mn><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">(ij)\mod 2 + (ij)\mod 3 = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6666666666666666em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6666666666666666em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></td>
</tr>
<tr>
<td style="text-align:center">110</td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mo>(</mo><mi>i</mi><mi>j</mi><mo>)</mo><mspace></mspace><mspace width="0.6666666666666666em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mn>2</mn><mo>+</mo><mo>(</mo><mi>i</mi><mi>j</mi><mo>)</mo><mspace></mspace><mspace width="0.6666666666666666em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mn>3</mn><mo>)</mo><mspace></mspace><mspace width="0.6666666666666666em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mn>2</mn><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">((ij)\mod 2 + (ij)\mod 3) \mod 2 = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6666666666666666em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6666666666666666em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mclose">)</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6666666666666666em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></td>
</tr>
<tr>
<td style="text-align:center">111</td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mo>(</mo><mi>i</mi><mi>j</mi><mo>)</mo><mspace></mspace><mspace width="0.6666666666666666em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mn>3</mn><mo>+</mo><mo>(</mo><mi>i</mi><mo>+</mo><mi>j</mi><mo>)</mo><mspace></mspace><mspace width="0.6666666666666666em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mn>2</mn><mo>)</mo><mspace></mspace><mspace width="0.6666666666666666em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mn>2</mn><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">((ij) \mod 3 + (i+j) \mod 2) \mod 2 = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6666666666666666em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6666666666666666em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6666666666666666em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></td>
</tr>
</tbody>
</table>
<p>下面是 Mask 后的一些样子，我们可以看到被某些 Mask <code>XOR</code> 了的数据变得比较零散了。<br>
<img src="https://faded.auspicious.space/post-images/1588142938463.png" alt="" loading="lazy"></p>
<p>Mask 过后的二维码就成最终的图了。</p>
<p>好了，大家可以去尝试去写一下 QR 的编码程序，当然，你可以用网上找个 Reed Soloman 的纠错算法的库，或是看看别人的源代码是怎么实现这个繁锁的编码。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[curl 与 wget 高级用法]]></title>
        <id>https://faded.auspicious.space/post/curl-and-wget-in-deep/</id>
        <link href="https://faded.auspicious.space/post/curl-and-wget-in-deep/">
        </link>
        <updated>2020-04-29T03:04:04.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzA4NzQzMzU4Mg==&amp;mid=2652922380&amp;idx=2&amp;sn=5ad7705fdca944e606f9e9f5a0062812&amp;chksm=8bed4a0dbc9ac31b5119d16183ac0491d9bf8b68ad90d662e546460d3411da1665e4eba221b2&amp;mpshare=1&amp;scene=23&amp;srcid=0819jJReiMzSV6hda9i2QKTl#rd">curl与wget高级用法</a></p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzA4NzQzMzU4Mg==&amp;mid=2652922380&amp;idx=2&amp;sn=5ad7705fdca944e606f9e9f5a0062812&amp;chksm=8bed4a0dbc9ac31b5119d16183ac0491d9bf8b68ad90d662e546460d3411da1665e4eba221b2&amp;mpshare=1&amp;scene=23&amp;srcid=0819jJReiMzSV6hda9i2QKTl#rd">curl与wget高级用法</a></p>
</blockquote>
<!-- more -->
<h1 id="curl文件传输工具">curl（文件传输工具）</h1>
<h2 id="常用参数">常用参数</h2>
<pre><code class="language-bash">-c，–cookie-jar：将cookie写入到文件
-b，–cookie：从文件中读取cookie
-C，–continue-at：断点续传
-d，–data：http post方式传送数据
-D，–dump-header：把header信息写入到文件
-F，–from：模拟http表达提交数据
-s，–slient：减少输出信息
-o，–output：将信息输出到文件
-O，–remote-name：按照服务器上的文件名，存在本地
–l，–head：仅返回头部信息
-u，–user[user:pass]：设置http认证用户和密码
-T，–upload-file：上传文件
-e，–referer：指定引用地址
-x，–proxy：指定代理服务器地址和端口
-w，–write-out：输出指定格式内容
–retry：重试次数
–connect-timeout：指定尝试连接的最大时间/s
</code></pre>
<h2 id="使用示例">使用示例</h2>
<p>例1：抓取页面到指定文件，如果有乱码可以使用 <code>iconv</code> 转码</p>
<pre><code class="language-bash"># curl -o baidu.html www.baidu.com
# curl –s –o baidu.html www.baidu.com |iconv -f utf-8 #减少输出信息
</code></pre>
<p>例2：模拟浏览器头（user-agent）</p>
<pre><code class="language-bash"># curl -A “Mozilla/4.0 (compatible;MSIE 6.0; &lt;a href=&quot;http://www.ttlsa.com/windows/&quot; title=&quot;windows&quot;target=&quot;_blank&quot;&gt;Windows&lt;/a&gt; NT 5.0)” www.baidu.com
</code></pre>
<p>例3：处理重定向页面</p>
<pre><code class="language-bash"># curl –L http://192.168.1.100/301.&lt;a href=&quot;http://www.ttlsa.com/php/&quot; title=&quot;php&quot;target=&quot;_blank&quot;&gt;php&lt;/a&gt; #默认curl是不处理重定向
</code></pre>
<p>例4：模拟用户登陆，保存cookie信息到cookies.txt文件，再使用cookie登陆</p>
<pre><code class="language-bash"># curl -c ./cookies.txt -F NAME=user -F PWD=***URL #NAME和PWD是表单属性不同，每个网站基本都不同
# curl -b ./cookies.txt –o URL
</code></pre>
<p>例5：获取HTTP响应头headers</p>
<pre><code class="language-bash"># curl -I http://www.baidu.com
# curl -D ./header.txt http://www.baidu.com #将headers保存到文件中

例6：访问HTTP认证页面
```bash
# curl –u user:pass URL
</code></pre>
<p>例7：通过ftp上传和下载文件</p>
<pre><code class="language-bash"># curl -T filename ftp://user:pass@ip/docs #上传
# curl -O ftp://user:pass@ip/filename #下载
</code></pre>
<h1 id="wget文件下载工具">wget（文件下载工具）</h1>
<h2 id="常用参数-2">常用参数</h2>
<h3 id="启动参数">启动参数</h3>
<pre><code class="language-bash">-V，–version：显示版本号
-h，–help：查看帮助
-b，–background：启动后转入后台执行
</code></pre>
<h3 id="日志记录和输入文件参数">日志记录和输入文件参数</h3>
<pre><code class="language-bash">-o，–output-file=file：把记录写到file文件中
-a，–append-output=file：把记录追加到file文件中
-i，–input-file=file：从file读取url来下载
</code></pre>
<h3 id="下载参数">下载参数</h3>
<pre><code class="language-bash">-bind-address=address：指定本地使用地址
-t，-tries=number：设置最大尝试连接次数
-c，-continue：接着下载没有下载完的文件
-O，-output-document=file：将下载内容写入到file文件中
-spider：不下载文件
-T，-timeout=sec：设置响应超时时间
-w，-wait=sec：两次尝试之间间隔时间
–limit-rate=rate：限制下载速率
-progress=type：设置进度条
</code></pre>
<h3 id="目录参数">目录参数</h3>
<pre><code class="language-bash">-P，-directory-prefix=prefix：将文件保存到指定目录
</code></pre>
<h3 id="http参数">HTTP参数</h3>
<pre><code class="language-bash">-http-user=user：设置http用户名
-http-passwd=pass：设置http密码
-U，–user-agent=agent：伪装代理
-no-http-keep-alive：关闭http活动链接，变成永久链接
-cookies=off：不使用cookies
-load-cookies=file：在开始会话前从file文件加载cookies
-save-cookies=file：在会话结束将cookies保存到file文件
</code></pre>
<h3 id="ftp参数">FTP参数</h3>
<pre><code class="language-bash">-passive-ftp：默认值，使用被动模式
-active-ftp：使用主动模式
</code></pre>
<h3 id="递归下载排除参数">递归下载排除参数</h3>
<pre><code class="language-bash">-A，–accept=list：分号分割被下载扩展名的列表
-R，–reject=list：分号分割不被下载扩展名的列表
-D，–domains=list：分号分割被下载域的列表
–exclude-domains=list：分号分割不被下载域的列表
</code></pre>
<h2 id="使用示例-2">使用示例</h2>
<p>例1：下载单个文件到当前目录下，也可以-P指定下载目录</p>
<pre><code class="language-bash"># wget http://nginx.org/download/nginx-1.8.0.tar.gz
</code></pre>
<p>例2：对于网络不稳定的用户可以使用-c和–tries参数，保证下载完成</p>
<pre><code class="language-bash"># wget –tries=20 -c http://nginx.org/download/nginx-1.8.0.tar.gz
</code></pre>
<p>例3：下载大的文件时，我们可以放到后台去下载，这时会生成wget-log文件来保存下载进度</p>
<pre><code class="language-bash"># wget -b http://nginx.org/download/nginx-1.8.0.tar.gz
</code></pre>
<p>例4：可以利用—spider参数判断网址是否有效</p>
<pre><code class="language-bash"># wget –spider http://nginx.org/download/nginx-1.8.0.tar.gz
</code></pre>
<p>例5：自动从多个链接下载文件</p>
<pre><code class="language-bash"># cat url_list.txt #先创建一个URL文件
http://nginx.org/download/nginx-1.8.0.tar.gz
http://nginx.org/download/nginx-1.6.3.tar.gz
# wget -i url_list.txt
</code></pre>
<p>例6：限制下载速度</p>
<pre><code class="language-bash"># wget –limit-rate=1m http://nginx.org/download/nginx-1.8.0.tar.gz
</code></pre>
<p>例7：登陆ftp下载文件</p>
<pre><code class="language-bash"># wget –ftp-user=user –ftp-password=pass ftp://ip/filenam
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[追 MM 与设计模式]]></title>
        <id>https://faded.auspicious.space/post/chasing-mm-and-design-patterns/</id>
        <link href="https://faded.auspicious.space/post/chasing-mm-and-design-patterns/">
        </link>
        <updated>2020-04-28T05:03:27.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p><a href="https://mp.weixin.qq.com/s?__biz=MjM5NzA1MTcyMA==&amp;mid=206725951&amp;idx=3&amp;sn=9528c2947a2e0427faa5f4a2c346cc52#rd">追MM与设计模式（23种设计模式巧妙解析，趣味理解）</a><br>
在网络上流畅很广的一篇旧文，暂时没找到原作者，目前所看到的最早转载时间是 2005 年 2 月 28 日。作者用轻松的语言，形象解释了 23 种模式，有很好的启发作用。</p>
</blockquote>
<h1 id="创建型模式">创建型模式</h1>
<h2 id="factory">FACTORY</h2>
<p>追 MM 少不了请吃饭了，麦当劳的鸡翅和肯德基的鸡翅都是 MM 爱吃的东西，虽然口味有所不同，但不管你带 MM 去麦当劳或肯德基，只管向服务员说“来四个鸡翅”就行了。麦当劳和肯德基就是生产鸡翅的 Factory。</p>
<h3 id="工厂模式">工厂模式</h3>
<p>客户类和工厂类分开。消费者任何时候需要某种产品，只需向工厂请求即可。消费者无须修改就可以接纳新产品。缺点是当产品修改时，工厂类也要做相应的修改。如：如何创建及如何向客户端提供。</p>
<h2 id="builder">BUILDER</h2>
<p>MM 最爱听的就是“我爱你”这句话了，见到不同地方的 MM，要能够用她们的方言跟她说这句话哦，我有一个多种语言翻译机，上面每种语言都有一个按键，见到 MM 我只要按对应的键，它就能够用相应的语言说出“我爱你”这句话了，国外的 MM 也可以轻松搞掂，这就是我的“我爱你”builder。（这一定比美军在伊拉克用的翻译机好卖）。</p>
<h3 id="建造模式">建造模式</h3>
<p>将产品的内部表象和产品的生成过程分割开来，从而使一个建造过程生成具有不同的内部表象的产品对象。建造模式使得产品内部表象可以独立的变化，客户不必知道产品内部组成的细节。建造模式可以强制实行一种分步骤进行的建造过程。</p>
<h2 id="factory-method">FACTORY METHOD</h2>
<p>请 MM 去麦当劳吃汉堡，不同的MM有不同的口味，要每个都记住是一件烦人的事情，我一般采用 Factory Method 模式，带着MM到服务员那儿，说“要一个汉堡”，具体要什么样的汉堡呢，让 MM 直接跟服务员说就行了。</p>
<h3 id="工厂方法模式">工厂方法模式</h3>
<p>核心工厂类不再负责所有产品的创建，而是将具体创建的工作交给子类去做，成为一个抽象工厂角色，仅负责给出具体工厂类必须实现的接口，而不接触哪一个产品类应当被实例化这种细节。</p>
<h2 id="prototype">PROTOTYPE</h2>
<p>跟 MM 用 QQ 聊天，一定要说些深情的话语了，我搜集了好多肉麻的情话，需要时只要 copy 出来放到 QQ 里面就行了，这就是我的情话 prototype 了。（100 块钱一份，你要不要）</p>
<h3 id="原始模型模式">原始模型模式</h3>
<p>通过给出一个原型对象来指明所要创建的对象的类型，然后用复制这个原型对象的方法创建出更多同类型的对象。原始模型模式允许动态的增加或减少产品类，产品类不需要非得有任何事先确定的等级结构，原始模型模式适用于任何的等级结构。缺点是每一个类都必须配备一个克隆方法。</p>
<h2 id="singleton">SINGLETON</h2>
<p>俺有 6 个漂亮的老婆，她们的老公都是我，我就是我们家里的老公 Sigleton，她们只要说道“老公”，都是指的同一个人，那就是我（刚才做了个梦啦，哪有这么好的事）。</p>
<h3 id="单例模式">单例模式</h3>
<p>单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例单例模式。单例模式只应在有真正的“单一实例”的需求时才可使用。</p>
<h1 id="结构型模式">结构型模式</h1>
<h2 id="adapter">ADAPTER</h2>
<p>在朋友聚会上碰到了一个美女 Sarah，从香港来的，可我不会说粤语，她不会说普通话，只好求助于我的朋友 Kent 了，他作为我和 Sarah 之间的 Adapter，让我和 Sarah 可以相互交谈了(也不知道他会不会耍我)。</p>
<h3 id="适配器变压器模式">适配器（变压器）模式</h3>
<p>把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口原因不匹配而无法一起工作的两个类能够一起工作。适配类可以根据参数返还一个合适的实例给客户端。</p>
<h2 id="bridge">BRIDGE</h2>
<p>早上碰到 MM，要说早上好，晚上碰到 MM，要说晚上好；碰到 MM 穿了件新衣服，要说你的衣服好漂亮哦，碰到 MM 新做的发型，要说你的头发好漂亮哦。不要问我“早上碰到 MM 新做了个发型怎么说”这种问题，自己用 BRIDGE 组合一下不就行了。</p>
<h3 id="桥梁模式">桥梁模式</h3>
<p>将抽象化与实现化脱耦，使得二者可以独立的变化，也就是说将他们之间的强关联变成弱关联，也就是指在一个软件系统的抽象化和实现化之间使用组合/聚合关系而不是继承关系，从而使两者可以独立的变化。</p>
<h2 id="composite">COMPOSITE</h2>
<p>Mary 今天过生日。“我过生日，你要送我一件礼物。”“嗯，好吧，去商店，你自己挑。”“这件 T 恤挺漂亮，买，这条裙子好看，买，这个包也不错，买。”“喂，买了三件了呀，我只答应送一件礼物的哦。”“什么呀，T 恤加裙子加包包，正好配成一套呀，小姐，麻烦你包起来。”“……”，MM 都会用 Composite 模式了，你会了没有？</p>
<h3 id="合成模式">合成模式</h3>
<p>合成模式将对象组织到树结构中，可以用来描述整体与部分的关系。合成模式就是一个处理对象的树结构的模式。合成模式把部分与整体的关系用树结构表示出来。合成模式使得客户端把一个个单独的成分对象和由他们复合而成的合成对象同等看待。</p>
<h2 id="decorator">DECORATOR</h2>
<p>Mary 过完轮到 Sarly 过生日，还是不要叫她自己挑了，不然这个月伙食费肯定玩完，拿出我去年在华山顶上照的照片，在背面写上“最好的的礼物，就是爱你的Fita”，再到街上礼品店买了个像框（卖礼品的 MM 也很漂亮哦），再找隔壁搞美术设计的 Mike 设计了一个漂亮的盒子装起来……，我们都是 Decorator，最终都在修饰我这个人呀，怎么样，看懂了吗？</p>
<h3 id="装饰模式">装饰模式</h3>
<p>装饰模式以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案，提供比继承更多的灵活性。动态给一个对象增加功能，这些功能可以再动态的撤消。增加由一些基本功能的排列组合而产生的非常大量的功能。</p>
<h2 id="facade">FACADE</h2>
<p>我有一个专业的 Nikon 相机，我就喜欢自己手动调光圈、快门，这样照出来的照片才专业，但 MM 可不懂这些，教了半天也不会。幸好相机有 Facade 设计模式，把相机调整到自动档，只要对准目标按快门就行了，一切由相机自动调整，这样 MM 也可以用这个相机给我拍张照片了。</p>
<h3 id="门面模式">门面模式</h3>
<p>外部与一个子系统的通信必须通过一个统一的门面对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用。每一个子系统只有一个门面类，而且此门面类只有一个实例，也就是说它是一个单例模式。但整个系统可以有多个门面类。</p>
<h2 id="flyweight">FLYWEIGHT</h2>
<p>每天跟 MM 发短信，手指都累死了，最近买了个新手机，可以把一些常用的句子存在手机里，要用的时候，直接拿出来，在前面加上 MM 的名字就可以发送了，再不用一个字一个字敲了。共享的句子就是 Flyweight，MM 的名字就是提取出来的外部特征，根据上下文情况使用。</p>
<h3 id="享元模式">享元模式</h3>
<p>FLYWEIGHT 在拳击比赛中指最轻量级。享元模式以共享的方式高效的支持大量的细粒度对象。享元模式能做到共享的关键是区分内蕴状态和外蕴状态。内蕴状态存储在享元内部，不会随环境的改变而有所不同。外蕴状态是随环境的改变而改变的。外蕴状态不能影响内蕴状态，它们是相互独立的。将可以共享的状态和不可以共享的状态从常规类中区分开来，将不可以共享的状态从类里剔除出去。客户端不可以直接创建被共享的对象，而应当使用一个工厂对象负责创建被共享的对象。享元模式大幅度的降低内存中对象的数量。</p>
<h2 id="proxy">PROXY</h2>
<p>跟 MM 在网上聊天，一开头总是“hi，你好”,“你从哪儿来呀？”“你多大了？”“身高多少呀？”这些话，真烦人，写个程序做为我的 Proxy 吧，凡是接收到这些话都设置好了自动的回答，接收到其他的话时再通知我回答，怎么样，酷吧。</p>
<h3 id="代理模式">代理模式</h3>
<p>代理模式给某一个对象提供一个代理对象，并由代理对象控制对源对象的引用。代理就是一个人或一个机构代表另一个人或者一个机构采取行动。某些情况下，客户不想或者不能够直接引用一个对象，代理对象可以在客户和目标对象直接起到中介的作用。客户端分辨不出代理主题对象与真实主题对象。代理模式可以并不知道真正的被代理对象，而仅仅持有一个被代理对象的接口，这时候代理对象不能够创建被代理对象，被代理对象必须有系统的其他角色代为创建并传入。</p>
<h1 id="行为模式">行为模式</h1>
<h2 id="chain-of-responsibleity">CHAIN OF RESPONSIBLEITY</h2>
<p>晚上去上英语课，为了好开溜坐到了最后一排，哇，前面坐了好几个漂亮的 MM 哎，找张纸条，写上“Hi，可以做我的女朋友吗？如果不愿意请向前传”，纸条就一个接一个的传上去了，糟糕，传到第一排的 MM 把纸条传给老师了，听说是个老处女呀，快跑!</p>
<h3 id="责任链模式">责任链模式</h3>
<p>在责任链模式中，很多对象由每一个对象对其下家的引用而接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。客户并不知道链上的哪一个对象最终处理这个请求，系统可以在不影响客户端的情况下动态的重新组织链和分配责任。处理者有两个选择：承担责任或者把责任推给下家。一个请求可以最终不被任何接收端对象所接受。</p>
<h2 id="command">COMMAND</h2>
<p>俺有一个 MM 家里管得特别严，没法见面，只好借助于她弟弟在我们俩之间传送信息，她对我有什么指示，就写一张纸条让她弟弟带给我。这不，她弟弟又传送过来一个 COMMAND，为了感谢他，我请他吃了碗杂酱面，哪知道他说：“我同时给我姐姐三个男朋友送 COMMAND，就数你最小气，才请我吃面。”，😦</p>
<h3 id="命令模式">命令模式</h3>
<p>命令模式把一个请求或者操作封装到一个对象中。命令模式把发出命令的责任和执行命令的责任分割开，委派给不同的对象。命令模式允许请求的一方和发送的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否执行，何时被执行以及是怎么被执行的。系统支持命令的撤消。</p>
<h2 id="interpreter">INTERPRETER</h2>
<p>俺有一个《泡 MM 真经》，上面有各种泡 MM 的攻略，比如说去吃西餐的步骤、去看电影的方法等等，跟 MM 约会时，只要做一个 Interpreter，照着上面的脚本执行就可以了。</p>
<h3 id="解释器模式">解释器模式</h3>
<p>给定一个语言后，解释器模式可以定义出其文法的一种表示，并同时提供一个解释器。客户端可以使用这个解释器来解释这个语言中的句子。解释器模式将描述怎样在有了一个简单的文法后，使用模式设计解释这些语句。在解释器模式里面提到的语言是指任何解释器对象能够解释的任何组合。在解释器模式中需要定义一个代表文法的命令类的等级结构，也就是一系列的组合规则。每一个命令对象都有一个解释方法，代表对命令对象的解释。命令对象的等级结构中的对象的任何排列组合都是一个语言。</p>
<h2 id="iterator">ITERATOR</h2>
<p>我爱上了 Mary，不顾一切的向她求婚。</p>
<p>Mary：“想要我跟你结婚，得答应我的条件”</p>
<p>我：“什么条件我都答应，你说吧”</p>
<p>Mary：“我看上了那个一克拉的钻石”</p>
<p>我：“我买，我买，还有吗？”</p>
<p>Mary：“我看上了湖边的那栋别墅”</p>
<p>我：“我买，我买，还有吗？”</p>
<p>Mary：“你的小弟弟必须要有 50cm 长”</p>
<p>我脑袋嗡的一声，坐在椅子上，一咬牙：“我剪，我剪，还有吗？”</p>
<p>……</p>
<h3 id="迭代子模式">迭代子模式</h3>
<p>迭代子模式可以顺序访问一个聚集中的元素而不必暴露聚集的内部表象。多个对象聚在一起形成的总体称之为聚集，聚集对象是能够包容一组对象的容器对象。迭代子模式将迭代逻辑封装到一个独立的子对象中，从而与聚集本身隔开。迭代子模式简化了聚集的界面。每一个聚集对象都可以有一个或一个以上的迭代子对象，每一个迭代子的迭代状态可以是彼此独立的。迭代算法可以独立于聚集角色变化。</p>
<h2 id="mediator">MEDIATOR</h2>
<p>四个 MM 打麻将，相互之间谁应该给谁多少钱算不清楚了，幸亏当时我在旁边，按照各自的筹码数算钱，赚了钱的从我这里拿，赔了钱的也付给我，一切就 OK 啦，俺得到了四个 MM 的电话。</p>
<h3 id="调停者模式">调停者模式</h3>
<p>调停者模式包装了一系列对象相互作用的方式，使得这些对象不必相互明显作用。从而使他们可以松散偶合。当某些对象之间的作用发生改变时，不会立即影响其他的一些对象之间的作用。保证这些作用可以彼此独立的变化。调停者模式将多对多的相互作用转化为一对多的相互作用。调停者模式将对象的行为和协作抽象化，把对象在小尺度的行为上与其他对象的相互作用分开处理。</p>
<h2 id="memento">MEMENTO</h2>
<p>同时跟几个 MM 聊天时，一定要记清楚刚才跟 MM 说了些什么话，不然 MM 发现了会不高兴的哦，幸亏我有个备忘录，刚才与哪个 MM 说了什么话我都拷贝一份放到备忘录里面保存，这样可以随时察看以前的记录啦。</p>
<h3 id="备忘录模式">备忘录模式</h3>
<p>备忘录对象是一个用来存储另外一个对象内部状态的快照的对象。备忘录模式的用意是在不破坏封装的条件下，将一个对象的状态捉住，并外部化，存储起来，从而可以在将来合适的时候把这个对象还原到存储起来的状态。</p>
<h2 id="observer">OBSERVER</h2>
<p>想知道咱们公司最新 MM 情报吗？加入公司的 MM 情报邮件组就行了，Tom 负责搜集情报，他发现的新情报不用一个一个通知我们，直接发布给邮件组，我们作为订阅者（观察者）就可以及时收到情报啦</p>
<h3 id="观察者模式">观察者模式</h3>
<p>观察者模式定义了一种一队多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使他们能够自动更新自己。</p>
<h2 id="state">STATE</h2>
<p>跟 MM 交往时，一定要注意她的状态哦，在不同的状态时她的行为会有不同，比如你约她今天晚上去看电影，对你没兴趣的 MM 就会说“有事情啦”，对你不讨厌但还没喜欢上的 MM 就会说“好啊，不过可以带上我同事么？”，已经喜欢上你的 MM 就会说“几点钟？看完电影再去泡吧怎么样？”，当然你看电影过程中表现良好的话，也可以把 MM 的状态从不讨厌不喜欢变成喜欢哦。</p>
<h3 id="状态模式">状态模式</h3>
<p>状态模式允许一个对象在其内部状态改变的时候改变行为。这个对象看上去象是改变了它的类一样。状态模式把所研究的对象的行为包装在不同的状态对象里，每一个状态对象都属于一个抽象状态类的一个子类。状态模式的意图是让一个对象在其内部状态改变的时候，其行为也随之改变。状态模式需要对每一个系统可能取得的状态创立一个状态类的子类。当系统的状态变化时，系统便改变所选的子类。</p>
<h2 id="strategy">STRATEGY</h2>
<p>跟不同类型的 MM 约会，要用不同的策略，有的请电影比较好，有的则去吃小吃效果不错，有的去海边浪漫最合适，单目的都是为了得到 MM 的芳心，我的追 MM 锦囊中有好多 Strategy 哦。</p>
<h3 id="策略模式">策略模式</h3>
<p>策略模式针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。策略模式使得算法可以在不影响到客户端的情况下发生变化。策略模式把行为和环境分开。环境类负责维持和查询行为类，各种算法在具体的策略类中提供。由于算法和环境独立开来，算法的增减，修改都不会影响到环境和客户端。</p>
<h2 id="template-method">TEMPLATE METHOD</h2>
<p>看过《如何说服女生上床》这部经典文章吗？女生从认识到上床的不变的步骤分为巧遇、打破僵局、展开追求、接吻、前戏、动手、爱抚、进去八大步骤（Template method），但每个步骤针对不同的情况，都有不一样的做法，这就要看你随机应变啦(具体实现)；</p>
<h3 id="模板方法模式">模板方法模式</h3>
<p>模板方法模式准备一个抽象类，将部分逻辑以具体方法以及具体构造子的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。先制定一个顶级逻辑框架，而将逻辑的细节留给具体的子类去实现。</p>
<h2 id="visitor">VISITOR</h2>
<p>情人节到了，要给每个 MM 送一束鲜花和一张卡片，可是每个 MM 送的花都要针对她个人的特点，每张卡片也要根据个人的特点来挑，我一个人哪搞得清楚，还是找花店老板和礼品店老板做一下 Visitor，让花店老板根据 MM 的特点选一束花，让礼品店老板也根据每个人特点选一张卡，这样就轻松多了；</p>
<h3 id="访问者模式">访问者模式</h3>
<p>访问者模式的目的是封装一些施加于某种数据结构元素之上的操作。一旦这些操作需要修改的话，接受这个操作的数据结构可以保持不变。访问者模式适用于数据结构相对未定的系统，它把数据结构和作用于结构上的操作之间的耦合解脱开，使得操作集合可以相对自由的演化。访问者模式使得增加新的操作变的很容易，就是增加一个新的访问者类。访问者模式将有关的行为集中到一个访问者对象中，而不是分散到一个个的节点类中。当使用访问者模式时，要将尽可能多的对象浏览逻辑放在访问者类中，而不是放到它的子类中。访问者模式可以跨过几个类的等级结构访问属于不同的等级结构的成员类。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[嵌入式知识总汇]]></title>
        <id>https://faded.auspicious.space/post/embedded-summary/</id>
        <link href="https://faded.auspicious.space/post/embedded-summary/">
        </link>
        <updated>2020-04-27T06:32:22.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p><a href="https://raw.githubusercontent.com/phodal/eks/master/README.md">嵌入式知识总汇</a></p>
</blockquote>
<h1 id="嵌入式工程师">嵌入式工程师</h1>
<h2 id="硬件核心hardware-core">硬件核心(Hardware Core)</h2>
<h3 id="controller控制器">Controller(控制器)</h3>
<ul>
<li>CPU
<ul>
<li>AMD x86 x64</li>
<li>Intel x86 x64</li>
</ul>
</li>
<li>MCU
<ul>
<li>MCS-51</li>
<li>HCS12</li>
<li>AVR XMEGA</li>
<li>ESP</li>
<li>Coldfire</li>
<li>ARM</li>
<li>STM32</li>
<li>FreeScale K60 K40</li>
<li>PIC32 PIC12/14/16</li>
<li>TM4C123 TM4C129X</li>
<li>Stellaris lm4f120</li>
<li>CC3200</li>
<li>Renesas R-Car Boards</li>
<li>MIPS Creator CI20</li>
</ul>
</li>
<li>MPU</li>
<li>SOC
<ul>
<li>OMAP</li>
<li>BCM2835(Raspberry Pi A+、B、B+)</li>
<li>BCM2836(Raspberry Pi 2B)</li>
</ul>
</li>
<li>CPLD
<ul>
<li>Altera EPM7128S</li>
<li>Lattice LC4128V</li>
<li>Xilinx XC9500</li>
</ul>
</li>
<li>FPGA
<ul>
<li>Altera Cyclone</li>
<li>Lattice MachXO2 MachXO3</li>
</ul>
</li>
<li>PowerPC
<ul>
<li>MPC505、821、850、860、8240、8245</li>
<li>QUICC ⅡMPC826</li>
<li>QUICC Ⅲ MPC8560</li>
</ul>
</li>
<li>DSC
<ul>
<li>TMS320F28x</li>
<li>MC56 F83x</li>
</ul>
</li>
<li>MIPS</li>
</ul>
<h3 id="actuator执行器">Actuator(执行器)</h3>
<ul>
<li>直流电机
<ul>
<li>有刷直流电机</li>
<li>无刷直流电机</li>
</ul>
</li>
<li>交流电机
<ul>
<li>单相电机</li>
<li>三相电机</li>
</ul>
</li>
<li>步进电机</li>
<li>直线电机</li>
<li>舵机</li>
<li>伺服电机</li>
</ul>
<h3 id="sensor传感器">Sensor(传感器)</h3>
<ul>
<li>RIP(人体红外)</li>
<li>Temperature(温度)</li>
<li>humidity sensor（湿度传感器）</li>
<li>geomagnetic sensor（地磁传感器）</li>
<li>acceleration transducer（加速度传感器）</li>
<li>optoelectronic switch （光电开关）</li>
<li>pneumatic sensor (气流传感器)</li>
<li>current sensor (电流传感器)</li>
<li>soil sensor (土壤传感器)</li>
<li>llumination sensor (光照传感器)</li>
<li>laser sensor (激光传感器)</li>
<li>Motion(运动)</li>
<li>Moisture sensor (土壤温度传感器)</li>
<li>电压传感器</li>
<li>three-axis gyroscope（三轴陀螺仪）</li>
<li>Camera 感光元件（图像传感器）</li>
<li>baroceptor（气压传感器）</li>
<li>gas sensor（气敏传感器）</li>
<li>Dust concentration sensor（粉尘浓度传感器）PM2.5</li>
<li>Water level sensor（水位传感器）</li>
<li>Pulse sensor（脉搏传感器）</li>
<li>EEG sensor（脑皮质电位传感器）</li>
<li>Flex Sensor (弯曲传感器）</li>
<li>proximity sensor (近距离传感器)</li>
<li>Atmospheric Pressure Sensor （气压传感器）</li>
</ul>
<h2 id="electronic-component电子元件">Electronic Component(电子元件)</h2>
<ul>
<li>电容</li>
<li>保护装置</li>
<li>端子与连接器</li>
<li>电线</li>
<li>开关
<ul>
<li>Switch</li>
<li>Keypad</li>
<li>Relay</li>
</ul>
</li>
<li>电阻
<ul>
<li>Thermistor (热敏电阻)</li>
<li>Varistor(压敏电阻)</li>
<li>Photosensitive resistance(光敏电阻)</li>
</ul>
</li>
<li>电磁感应装置</li>
<li>network
<ul>
<li>电阻排</li>
</ul>
</li>
<li>忆阻器</li>
<li>压电装置、晶体谐振器</li>
<li>电源</li>
<li>二极管</li>
<li>晶体管</li>
</ul>
<h2 id="mcucpudspsoc-peripherals">MCU/CPU/DSP/SOC peripherals</h2>
<ul>
<li>ADC / DAC</li>
<li>RTC</li>
<li>Timer / Watchdog Timer (定时器)</li>
<li>Flash / NAND Flash</li>
<li>ROM / EEPROM</li>
<li>RAM
<ul>
<li>SDRAM</li>
<li>DDR1 DDR2 DDR3 DDR4</li>
</ul>
</li>
<li>Cache</li>
<li>PWM</li>
<li>I/O / GPIO</li>
<li>UART</li>
<li>Modem</li>
<li>DTMF</li>
<li>CAN</li>
<li>SPI</li>
<li>I2C</li>
<li>IEEE</li>
<li>CRC</li>
<li>Interrupt (中断)</li>
</ul>
<h2 id="communication通信">Communication(通信)</h2>
<ul>
<li>硬件间无线通信
<ul>
<li>Bluetooth</li>
<li>Xbee / Zigbee</li>
<li>Z-Wave</li>
<li>6LoWPAN</li>
<li>NFC</li>
<li>Wifi</li>
<li>Radio</li>
<li>IR (红外)</li>
<li>802.11</li>
<li>Sub-GHZ 1Ghz以下RF</li>
</ul>
</li>
<li>硬件通信
<ul>
<li>UART</li>
<li>I2C</li>
<li>RS232C/RS485</li>
<li>HDLC</li>
<li>SPI/SCI/SI</li>
<li>CAN</li>
<li>USB</li>
<li>FireWire</li>
<li>1-wire</li>
</ul>
</li>
<li>网络协议
<ul>
<li>HTTP</li>
<li>CoAP</li>
<li>MQTT</li>
<li>XMPP</li>
<li>WebSocket</li>
<li>UDP</li>
<li>TCP</li>
</ul>
</li>
</ul>
<h2 id="软件编程">软件编程</h2>
<ul>
<li>Common
<ul>
<li>ISR</li>
<li>Driver</li>
<li>DMA</li>
<li>I2C</li>
</ul>
</li>
<li>OS
<ul>
<li>uCOS</li>
<li>Contiki</li>
<li>TinyOS</li>
<li>VXWorks</li>
<li>FreeRTOS</li>
<li>mbed OS</li>
<li>emOS</li>
<li>Salvo</li>
<li>MQX</li>
<li>RIOT</li>
<li>rt-thread</li>
<li>Linux
<ul>
<li>uCLinux</li>
<li>openWRT</li>
</ul>
</li>
<li>Windows
<ul>
<li>Windows CE</li>
<li>Windows 10 IoT Core</li>
</ul>
</li>
</ul>
</li>
<li>non-OS
<ul>
<li>LwIP</li>
</ul>
</li>
</ul>
<h2 id="电路">电路</h2>
<ul>
<li>基础
<ul>
<li>焊电路</li>
<li>模拟电路</li>
<li>数字电路</li>
</ul>
</li>
<li>PCB设计
<ul>
<li>设计工具
<ul>
<li>Eagle</li>
<li>Cadence</li>
<li>Protel</li>
<li>Altium</li>
<li>Mentor</li>
<li>Kicad</li>
<li>gEAD</li>
<li>ZUKEN</li>
<li>PADS</li>
<li>FreePCB</li>
<li>Fritzing</li>
<li>PCBmodE</li>
</ul>
</li>
<li>布线/布线</li>
</ul>
</li>
<li>电路仿真
<ul>
<li>原理仿真软件
<ul>
<li>Multisim</li>
<li>Proteus</li>
<li>Pspice</li>
</ul>
</li>
<li>信号仿真软件
<ul>
<li>ADS</li>
<li>HFSS</li>
<li>HyperLynx</li>
<li>Sigrity</li>
<li>MATLAB</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[负载均衡集群 LVS 详解]]></title>
        <id>https://faded.auspicious.space/post/a-detailed-explanation-of-load-balancing-cluster-lvs/</id>
        <link href="https://faded.auspicious.space/post/a-detailed-explanation-of-load-balancing-cluster-lvs/">
        </link>
        <updated>2020-04-27T02:38:53.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p><a href="http://liaoph.com/lvs/">负载均衡集群 LVS 详解</a></p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p><a href="http://liaoph.com/lvs/">负载均衡集群 LVS 详解</a></p>
</blockquote>
<!-- more -->
<h1 id="服务器扩展">服务器扩展</h1>
<p>当服务器遇到性能瓶颈需要进行扩展时，一般来说有两种解决思路：<strong>Scale-up</strong> 和 <strong>Scale out</strong>，也称作垂直扩展和水平扩展。</p>
<h2 id="垂直扩展">垂直扩展</h2>
<p>通常指增加 CPU 和内存，购买昂贵的高性能服务器。</p>
<p><strong>优点：</strong></p>
<ul>
<li>耗电量相比使用多台服务器要少；</li>
<li>实施简单。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>价格太昂贵；</li>
<li>由于资源的争用，服务器性能的增长会越来越小；</li>
<li>有很大的硬件故障导致服务不可用的风险；</li>
<li>受限制于供应商，且可扩展升级的空间是有限的。</li>
</ul>
<h2 id="水平扩展">水平扩展</h2>
<p>通常指增加多台普通配置的服务器。</p>
<p><strong>优点：</strong></p>
<ul>
<li>比起垂直扩展要便宜的多；</li>
<li>有容错能力；</li>
<li>易升级；</li>
<li>有着很大的扩展空间。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>服务器的维护和管理更加麻烦；</li>
<li>耗电和制冷的费用会比垂直扩展要高；</li>
<li>如果使用付费授权软件，那么会增加 lisence 的费用。</li>
</ul>
<p>一般来说，随着服务器性能提升，其价格也是指数级上升的，使用水平扩展的方式能够节约很多成本，同时还能够增加整个服务的容错能力。</p>
<h1 id="负载均衡集群">负载均衡集群</h1>
<p>负载均衡集群指使用多台提供相同服务的服务器组成集群系统，提高服务的并发处理能力。负载均衡集群的前端使用一个调度器，将客户端请求平均分配到后端的服务器中，同时调度器可能还具有后端服务器状态检测的功能，将故障的服务器自动下线，使得集群具有一定的容错能力。</p>
<p>使用负载均衡集群能够有效的扩展服务的并发能力，负载均衡集群中的主机间应该尽量的「低耦合」，最好是「无状态」的，这样就能够方便的增加主机实现扩展。</p>
<h2 id="常见的负载均衡器">常见的负载均衡器</h2>
<p>根据工作在的协议层划分可划分为：</p>
<ul>
<li>四层负载均衡：根据请求报文中的目标地址和端口进行调度；</li>
<li>七层负载均衡：根据请求报文的内容进行调度，这种调度属于「代理」的方式。</li>
</ul>
<p><strong>根据软硬件划分：</strong></p>
<ul>
<li>硬件负载均衡：
<ul>
<li>F5 的 BIG-IP；</li>
<li>Citrix 的 NetScaler。<br>
这类硬件负载均衡器通常能同时提供四层和七层负载均衡，但同时也价格不菲。</li>
</ul>
</li>
<li>软件负载均衡：
<ul>
<li>TCP 层：LVS，HaProxy，Nginx；</li>
<li>基于 HTTP 协议：Haproxy，Nginx，ATS（Apache Traffic Server），squid，varnish；</li>
<li>基于 MySQL 协议：mysql-proxy。</li>
</ul>
</li>
</ul>
<h1 id="lvs">LVS</h1>
<p>LVS 是一个工作在四层的负载均衡器，它的实现和 <code>iptables/netfilter</code> 类似，工作在内核空间的 TCP/IP 协议栈上，LVS 工作在 INPUT Hook Funtion 上，并在 INPUT 设置附加规则，一旦客户端请求的是集群服务，LVS 会强行修改请求报文，将报文发往 POSTROUTING，转发至后端的主机。</p>
<p>和 iptables/netfilter 类似，LVS 也是两段式的：</p>
<ul>
<li><code>ipvsadm</code>：工作在用户空间，负责定义和管理集群服务的规则；</li>
<li><code>ipvs</code>：工作在内核中，在 2.4.23 之前，必须向内核打补丁，并重新编译内核。在 2.4.23 和 2.6 之后的版本，<code>ipvs</code> 直接内置在内核中。</li>
</ul>
<p><strong>LVS 集群的设备地址命名：</strong></p>
<ul>
<li>VIP：Virtual IP，LVS 面向用户请求的 IP 地址；</li>
<li>RIP：Real server IP，后端服务器用于和 LVS 通信的 IP 地址；</li>
<li>DIP：Director IP，LVS 用户和后端服务器通信的 IP 地址；</li>
<li>CIP：Client IP，客户端 IP 地址。</li>
</ul>
<h2 id="lvs-的工作模型">LVS 的工作模型</h2>
<h3 id="lvs-nat">LVS-NAT</h3>
<p><img src="https://faded.auspicious.space/post-images/1587956377129.png" alt="" loading="lazy"><br>
LVS-NAT 模型类似于 DNAT，工作机制与 DNAT 一样，当客户端请求的是集群服务时，LVS 修改请求报文的目标地址为 RIP，转发至后端的 RealServer，并修改后端响应报文的源地址为 VIP，响应至客户端。</p>
<p>在 LVS-NAT 模型下，Director 进出请求报文都经过 Director，因此 Director 的压力是比较大的。</p>
<p><strong>LVS-NAT 的特性：</strong></p>
<ul>
<li>集群节点跟 Director 必须在同一个 IP 网络中；</li>
<li>RIP 通常是私有地址，仅用于各集群节点间的通信；</li>
<li>Director 位于 client 和 Realserver 之间，负责处理进出的所有报文；</li>
<li>Realserver 必须将网关指向 DIP；</li>
<li>支持端口映射；</li>
<li>较大规模应用场景中，Director 易成为系统瓶颈（bottleneck）。</li>
</ul>
<h3 id="lvs-dr">LVS-DR</h3>
<p><img src="https://faded.auspicious.space/post-images/1587957110278.png" alt="" loading="lazy"><br>
DR 值 Direct Routing，直接路由，DR 模型中，Director 和 Realserver 处在同一网络中，对于 Director，VIP 用于接受客户端请求，DIP 用于和 Realserver 通信。对于 Realserver，每个 Realserver 都配有和 Director 相同的 VIP（此 VIP 隐藏，关闭对 ARP 请求的响应），仅用户响应客户端的请求，RIP 用于和 Director 通信。</p>
<p>当客户端请求集群服务时，请求报文发送至 Director 的 VIP（Realserver的 VIP 不会响应 ARP 请求），Director 将客户端报文的源和目标 MAC 地址进行重新封装，将报文转发至 Realserver，Realserver 接收转发的报文。此时报文的源 IP 和目标 IP 都没有被修改，因此 Realserver 接受到的请求报文的目标 IP 地址为本机配置的 VIP，它将使用自己的 VIP 直接响应客户端。</p>
<p>LVS-DR 模型中，客户端的响应报文不会经过 Director，因此 Director 的并发能力有很大提升。</p>
<p><strong>LVS-DR 模型的特性：</strong></p>
<ul>
<li>保证前端路由器将目标地址为 VIP 的报文通过 ARP 解析后送往 Director。
<ul>
<li>静态绑定：在前端路由将 VIP 对应的目标 MAC 地址静态配置为Director VIP 接口的 MAC 地址。</li>
<li>arptables：在各 Realserver 上，通过 arptables 规则拒绝其响应对 VIP 的 ARP 广播请求。</li>
<li>修改内核参数：在 Realserver 上修改内核参数，并结合地址的配置方式实现拒绝响应对 VIP 的 ARP 广播请求。</li>
</ul>
</li>
<li>各RIP 必须与 DIP 在同一个物理网络中。</li>
<li>RS 的 RIP 可以使用私有地址，也可以使用公网地址，以方便配置。</li>
<li>Director 仅负责处理入站请求，响应报文由 Realserver 直接发往客户端。</li>
<li>Realserver 不能将网关指向 DIP，而直接使用前端网关。</li>
<li>不支持端口映射。</li>
</ul>
<h3 id="lvs-tun">LVS-TUN</h3>
<p><img src="https://faded.auspicious.space/post-images/1587957103642.png" alt="" loading="lazy"><br>
和 DR 模型类似，Realserver 都配有不可见的 VIP，Realserver 的 RIP 是公网地址，且可能和 DIP 不再同一网络中。当请求到达 Director 后，Director 不修改请求报文的源 IP 和目标 IP 地址，而是使用 IP 隧道技术，使用 DIP 作为源 IP，RIP 作为目标 IP 再次封装此请求报文，转发至 RIP 的 Realserver 上，Realserver 解析报文后仍然使用 VIP 作为源地址响应客户端。</p>
<p><strong>LVS-TUN 的特性：</strong></p>
<ul>
<li>集群节点和可以跨越 Internet；</li>
<li>RIP，DIP，VIP 都是公网地址；</li>
<li>Director 仅负责处理入站请求，响应报文由 Realserver 直接发往客户端；</li>
<li>Realserver 使用自己的网关而不是 Director；</li>
<li>Realserver 只能使用支持隧道功能的操作系统；</li>
<li>不支持端口映射。</li>
</ul>
<h3 id="lvs-fullnat">LVS-FULLNAT</h3>
<p>FULLNAT 由淘宝研发，目前还没有加入至 CentOS 可用的内核中，使用时需要向内核打补丁。</p>
<p>类似于 DNAT，它修改请求报文的源地址为 DIP，目标地址为 RIP 来实现转发。对于响应报文，源地址修改为 VIP，目标地址修改为 CIP 来实现转发。</p>
<p><strong>特点：</strong></p>
<ul>
<li>RIP，DIP 可以使用私有地址；</li>
<li>RIP 和 DIP 可以不再同一网络中，且 RIP 的网关不需要指向 DIP；</li>
<li>支持端口映射；</li>
<li>请求和响应报文都经由 Director。</li>
</ul>
<h2 id="lvs-的调度算法">LVS 的调度算法</h2>
<p>当 LVS 接受到一个客户端对集群服务的请求后，它需要进行决策将请求调度至某一台后端主机进行响应。LVS 的调度算法共有 10 种，按类别可以分为动态和静态两种类型。</p>
<h3 id="静态调度算法">静态调度算法</h3>
<p>静态调度算法调度时不会考虑后端服务器的状态</p>
<ul>
<li><code>rr</code>：round robin，轮询，即简单在各主机间轮流调度</li>
<li><code>wrr</code>：weighted round robin，加权轮询，根据各主机的权重进行轮询</li>
<li><code>sh</code>：source hash，源地址哈希，对客户端地址进行哈希计算，保存在 Director 的哈希表中，在一段时间内，同一个客户端 IP 地址的请求会被调度至相同的 Realserver。sh 算法的目的是实现 session affinity（会话绑定），但是它也在一定程度上损害了负载均衡的效果。如果集群本身有 session sharing 机制或者没有 session 信息，那么不需要使用 sh 算法</li>
<li><code>dh</code>：destination hash，和 sh 类似，dh 将请求的目标地址进行哈希，将相同 IP 的请求发送至同一主机，dh 机制的目的是，当 Realserver 为透明代理缓存服务器时，提高缓存的命中率。</li>
</ul>
<h3 id="动态调度算法">动态调度算法</h3>
<p>动态调度算法在调度时，会根据后端 Realserver 的负载状态来决定调度选择，Realserver 的负载状态通常由活动链接（active），非活动链接（inactive）和权重来计算。</p>
<ul>
<li><code>lc</code>：least connted，最少连接，LVS 根据 <code>overhead = active*256 + inactive</code> 计算服务器的负载状态，每次选择 overhead 最小的服务器</li>
<li><code>wlc</code>：weighted lc，加权最少连接，LVS 根据 <code>overhead = (active*256+inactive)/weight</code> 来计算服务器负载，每次选择 overhead 最小的服务器，它是 LVS 的默认调度算法</li>
<li><code>sed</code>：shortest expected delay，最短期望延迟，它不对 inactive 状态的连接进行计算，根据 <code>overhead = (active+1)*256/weight</code> 计算服务器负载，选择 overhead 最小的服务器进行调度</li>
<li><code>nq</code>：never queue，当有空闲服务器时，直接调度至空闲服务器，当没有空闲服务器时，使用 SED 算法进行调度</li>
<li>LBLC：locality based least connection，基于本地的最少连接，相当于 dh + wlc，正常请求下使用 dh 算法进行调度，如果服务器超载，则使用 wlc 算法调度至其他服务器</li>
<li>LBLCR：locality based least connection with replication，基于本地的带复制功能的最少连接，与 LBLC 不同的是 LVS 将请求 IP 映射至一个服务池中，使用 dh 算法调度请求至对应的服务池中，使用 lc 算法选择服务池中的节点，当服务池中的所有节点超载，使用 lc 算法从所有后端 Realserver 中选择一个添加至服务吃中。</li>
</ul>
<h2 id="ipvsadm">ipvsadm</h2>
<p>ipvsadm 用于配置 LVS 的调度规则，管理集群服务和 Realserver。</p>
<p><strong>管理集群服务：</strong></p>
<pre><code class="language-bash">添加：-A -t|u|f service-address [-s scheduler]
	 -t: TCP协议的集群
	 -u: UDP协议的集群
		service-address:     IP:PORT
	 -f: FWM: 防火墙标记
		service-address: Mark Number
修改：-E
删除：-D -t|u|f service-address

例如：
# ipvsadm -A -t 10.10.0.1:80 -s rr
</code></pre>
<p><strong>管理集群服务中的 RS：</strong></p>
<pre><code class="language-bash">添加：-a -t|u|f service-address -r server-address [-g|i|m] [-w weight]
	-t|u|f service-address：事先定义好的某集群服务
	-r server-address: 某RS的地址，在NAT模型中，可使用IP：PORT实现端口映射；
	[-g|i|m]: LVS类型
		-g: DR
		-i: TUN
		-m: NAT
	[-w weight]: 定义服务器权重
修改：-e
删除：-d -t|u|f service-address -r server-address

例如：
# ipvsadm -a -t 10.10.0.2:80 -r 192.168.10.8 -m
# ipvsadm -a -t 10.10.0.3:80 -r 192.168.10.9 -m
</code></pre>
<p><strong>查看规则：</strong></p>
<pre><code class="language-bash">-L|-l
-n：数字格式显式主机地址和端口
--stats：统计数据
--rate: 速率
--timeout: 显示tcp、tcpfin和udp的会话超时时长
-c: 显示当前的ipvs连接状况
</code></pre>
<p><strong>删除所有集群服务：</strong></p>
<pre><code class="language-bash">-C：清空 ipvs 规则
</code></pre>
<p><strong>保存规则：</strong></p>
<pre><code class="language-bash">-S
如：
# ipvsadm -S &gt; /path/to/somefile
</code></pre>
<p><strong>载入保存的规则：</strong></p>
<pre><code class="language-bash">-R
如：
# ipvsadm -R &lt; /path/from/somefile
</code></pre>
<h2 id="dr-模型的配置">DR 模型的配置</h2>
<h3 id="dr-模型的-realserver-禁止-arp-响应">DR 模型的 Realserver 禁止 ARP 响应</h3>
<p>对于 Linux 来说，地址是属于主机的，Linux 主机在开机时会通告连接所有网络内的所有其他主机自己的所有 IP 地址和 MAC 地址。</p>
<p>可以利用 Linux 的特性，将VIP配置在 Realserver 的本地回环接口上作为别名，并使用 <code>arp_ignore</code> 和 <code>arp_annouce</code> 内核参数。</p>
<h3 id="禁止-arp-响应的方式">禁止 ARP 响应的方式</h3>
<p><code>arptables</code>：红帽系类系统上提供的程序</p>
<p>修改内核参数：</p>
<ul>
<li>arp_ignore：定义接收到 ARP 请i去时的响应级别
<ul>
<li>0：只要本地配置有响应地址，就给与响应；</li>
<li>1：仅在请求的目标地址配置请i去到达的接口上的时候，才进行响应。</li>
</ul>
</li>
<li>arp_announce：定义主机将自己的地址想外通告时的通告级别
<ul>
<li>0：将本地任何接口上的任何地址向外通告；</li>
<li>1：向目标网络通告与其网络匹配的地址；</li>
<li>2：仅向本地接口上匹配的网络进行通告。</li>
</ul>
</li>
</ul>
<h3 id="添加特殊的路由条目">添加特殊的路由条目</h3>
<p>Linux 主机在使用某一接口发出报文时，默认会使用此接口的 IP 作为源 IP 地址。</p>
<p>当请求 Realserver 时，Realserver 的 VIP 是 lo 接口的别名，而 VIP 对外的通信实际需要使用的却是 eth0 接口，因此需要添加路由条目，让主机在使用 VIP 向外通信时，强制使用 lo 端口，因而它会使用 lo 端口的地址作为源 IP 进行响应，并最终由 lo 接口转发至 eth0 接口发出报文。</p>
<pre><code class="language-bash"># /sbin/route add -host $VIP dev lo:0
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[快慢指针应用总结]]></title>
        <id>https://faded.auspicious.space/post/fast-and-slow-pointer-application-summary/</id>
        <link href="https://faded.auspicious.space/post/fast-and-slow-pointer-application-summary/">
        </link>
        <updated>2020-04-26T13:39:22.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p><a href="https://blog.csdn.net/qq_21815981/article/details/79833976">快慢指针应用总结</a></p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p><a href="https://blog.csdn.net/qq_21815981/article/details/79833976">快慢指针应用总结</a></p>
</blockquote>
<!-- more -->
<h1 id="快慢指针">快慢指针</h1>
<p>快慢指针中的快慢指的是移动的步长，即每次向前移动速度的快慢。例如可以让快指针每次沿链表向前移动 2，慢指针每次向前移动 1 次。</p>
<h1 id="快慢指针的应用">快慢指针的应用</h1>
<h2 id="判断单链表是否存在环">判断单链表是否存在环</h2>
<p>如果链表存在环，就好像操场的跑道是一个环形一样。此时让快慢指针都从链表头开始遍历，快指针每次向前移动两个位置，慢指针每次向前移动一个位置；如果快指针到达 <code>NULL</code>，说明链表以 <code>NULL</code> 为结尾，没有环。如果快指针追上慢指针，则表示有环。代码如下：</p>
<pre><code class="language-c">bool HasCircle(Node *head) {
	if(head == NULL)
	    return false;
	Node *slow = head, *fast = head;
	while(fast != NULL &amp;&amp; fast-&gt;next!=NULL) {
		slow = slow-&gt;next;
		//慢指针每次前进一步
		fast = fast-&gt;next-&gt;next;
		//快指针每次前进两步
		if(slow == fast) //相遇，存在环
		return true;
	}
	return false;
}
</code></pre>
<h2 id="在有序链表中寻找中位数">在有序链表中寻找中位数</h2>
<p>快指针的移动速度是慢指针移动速度的 2 倍，因此当快指针到达链表尾时，慢指针到达中点。</p>
<p>程序还要考虑链表结点个数的奇偶数因素，当快指针移动 <code>x</code> 次后到达表尾（<code>1+2x</code>），说明链表有奇数个结点，直接返回慢指针指向的数据即可。</p>
<p>如果快指针是倒数第二个结点，说明链表结点个数是偶数，这时可以根据“规则”返回上中位数或下中位数或（上中位数+下中位数）的一半。</p>
<pre><code class="language-c">while (fast &amp;&amp; slow) {
	if (fast-&gt;next==NULL)
	　　    return slow -&gt;data; else if (fast-&gt;next!= NULL &amp;&amp; fast-&gt;next-&gt;next== NULL)
	　　    return (slow -&gt;data + slow -&gt;next-&gt;data)/2; else {
		fast= fast-&gt;next;
		fast= fast-&gt;next;
		slow = slow -&gt;next;
	}
}
</code></pre>
<h2 id="输出链表中的倒数第-k-个节点即正数第-k-1-个节点">输出链表中的倒数第 K 个节点(即正数第 K-1 个节点)</h2>
<p>可以定义两个指针，第一个指针从链表的头指针开始遍历向前走 <code>k-1</code> 步，第二个指针保持不动；从第 <code>k</code> 步开始，第二个指针也开始从链表的头指针开始遍历。由于两个指针的距离保持在 <code>k-1</code>，当第一个指针到达链表的尾节点时候，第二个指针正好是倒数第 <code>k</code> 个节点，代码如下：</p>
<pre><code class="language-c">// 查找单链表中倒数第K个结点  
ListNode * RGetKthNode(ListNode * pHead, unsigned int k) // 函数名前面的R代表反向 {
	if(k == 0 || pHead == NULL) // 这里k的计数是从1开始的，若k为0或链表为空返回NULL  
	return NULL;
	ListNode * pAhead = pHead;
	ListNode * pBehind = pHead;
	for (int i=0;i&lt;k-1;i++) {
		pAhead=pAhead-&gt;next;
		if(pAhead==null)  return null;
		//当链表长度小于k时候，返回Null
	}
	while(pAhead-&gt;next != NULL)  // 前后两个指针一起向前走，直到前面的指针指向最后一个结点 {
		pBehind = pBehind-&gt;next;
		pAhead = pAhead-&gt;next;
	}
	return pBehind;
	// 后面的指针所指结点就是倒数第k个结点
}
</code></pre>
<h2 id="判断链表是否存在环如果存在找到环入口">判断链表是否存在环，如果存在，找到环入口</h2>
<p>有一个单链表，其中可能有一个环，也就是某个节点的 <code>next</code> 指向的是链表中在它之前的节点，这样在链表的尾部形成一环。</p>
<p>如何判断一个链表是否存在环？设定两个指针 <code>slow</code>，<code>fast</code>，均从头指针开始，每次分别前进 1 步、2 步。如存在环，则两者相遇；如不存在环，<code>fast</code> 遇到 <code>NULL</code> 退出。</p>
<p>如果链表存在环，如果找到环的入口点？当 <code>fast</code> 若与 <code>slow</code> 相遇时，<code>slow</code> 肯定没有走遍历完链表或者恰好遍历一圈。于是我们从链表头与相遇点分别设一个指针，每次各走一步，两个指针必定相遇，且相遇第一点为环入口点。</p>
<pre><code class="language-c">node* findLoopPort(node *head) {
	node *fast, *slow;
	fast = slow = head;
	while (fast &amp;&amp; fast-&gt;next) {
		//第一步：判断链表是否存在环
		slow = slow-&gt;next;
		fast = fast-&gt;next-&gt;next;
		if (slow == fast) {
			//链表存在环
			break;
		}
	}
	if ((fast == NULL) || (fast-&gt;next == NULL)) {
		//链表不存在环
		return NULL;
	}
	//第二步：寻找环的入口点
	slow = head;
	//让slow回到链表的起点，fast留在相遇点
	while (slow != fast) {
		//当slow和fast再次相遇时，那个点就是环的入口点
		slow = slow-&gt;next;
		fast = fast-&gt;next;
	}
	return slow;
}
</code></pre>
<h2 id="判断两个单链表是否相交如果相交给出相交的第一个点假设两个链表都不存在环">判断两个单链表是否相交,如果相交，给出相交的第一个点（假设两个链表都不存在环）。</h2>
<p><strong>思路</strong>：</p>
<blockquote>
<p>首先利用快慢指针判断链表是否存在环。</p>
</blockquote>
<ol>
<li>如果都不存在环，则如果两个单向链表有公共节点，也就是两个链表从某一节点开始，他们的 <code>p_next</code> 都指向同一个节点，每个节点只有一个 <code>p-&gt;next</code>。因此从第一个公共节点开始，之后它们所有节点都是重合的。因此，首先两个链表各遍历一次，求出两个链表的长度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>L</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">L_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>L</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">L_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，然后可以得到它们的长度差 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span></span></span></span>。然后现在长的链表上遍历 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span></span></span></span> 个节点，之后再同步遍历，于是在遍历中，第一个相同的节点就是第一个公共的节点。此时，若两个链表长度分别为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>，则时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>M</mi><mo>+</mo><mi>N</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(M+N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>。</li>
<li>如果一个存在环，另外一个不存在环，则这两个链表是不可能相交的。</li>
<li>如果利用快慢指针发现两个链表都存在环，则判断任意一个链表上快慢指针相遇的那个节点，在不在另外一个链表上，如果在，则相交，不在，则不相交。</li>
</ol>
<p>下面讨论两个没有环的链表如果是相交于某一结点的情况：</p>
<p>相交的链表示意图如下所示：<br>
<img src="https://faded.auspicious.space/post-images/1587909877666.jfif" alt="" loading="lazy"></p>
<h3 id="方法一">方法一</h3>
<p>两个没有环的链表如果是相交于某一结点，如上图所示，这个结点后面都是共有的。所以如果两个链表相交，那么两个链表的尾结点的地址也是一样的。程序实现时分别遍历两个单链表，直到尾结点。判断尾结点地址是否相等即可。时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msub><mi>L</mi><mn>1</mn></msub><mo>+</mo><msub><mi>L</mi><mn>2</mn></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">O(L_1+L_2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</p>
<p>如何找到第一个相交结点？判断是否相交的时候，记录下两个链表的长度，算出长度差 <code>len</code>，接着先让较长的链表遍历 <code>len</code> 个长度，然后两个链表同时遍历，判断是否相等，如果相等，就是第一个相交的结点。</p>
<pre><code class="language-c">void Is_2List_Intersect(LinkList L1, LinkList L2) {
	if (L1 == NULL || L2 == NULL) {
		exit(ERROR);
	}
	LinkList p = L1;
	LinkList q = L2;
	int L1_length = 0;
	int L2_length = 0;
	int len = 0;
	while (p-&gt;next) {
		L1_length ++;
		p = p-&gt;next;
	}
	while (q-&gt;next) {
		L2_length ++;
		q = q-&gt;next;
	}
	printf(&quot;p: = %d\n&quot;, p);
	printf(&quot;q: = %d\n&quot;, q);
	printf(&quot;L1_length: = %d\n&quot;, L1_length);
	printf(&quot;L2_length: = %d\n&quot;, L2_length);
	if (p == q) {
		printf(&quot; 相交\n&quot;);
		/*p重新指向短的链表 q指向长链表*/
		if (L1_length &gt; L2_length) {
			len = L1_length - L2_length;
			p = L2;
			q = L1;
		} else {
			len = L2_length - L1_length;
			p = L1;
			q = L2;
		}
		while (len) {
			q = q-&gt;next;
			len--;
		}
		while (p != q) {
			p = p-&gt;next;
			q = q-&gt;next;
		}
		printf(&quot;相交的第一个结点是：%d\n&quot;, p-&gt;data );
	} else {
		printf(&quot;不相交 \n&quot;);
	}
}
</code></pre>
<h3 id="方法二">方法二</h3>
<p>另外一个方法则是将一个链表首尾相接，然后判断另外一个链表是否有环，如果有环，则两个链表相交。那么求第一个交点则求出有环的的那个链表的环结点即是。</p>
<pre><code class="language-c">int Is_ListLoop(LinkList L) {
	LinkList fast, slow;
	if (L == NULL || L-&gt;next == NULL) {
		exit(ERROR);
	}
	fast = slow = L;
	while (fast-&gt;next != NULL &amp;&amp; fast-&gt;next-&gt;next != NULL) {
		slow = slow-&gt;next;
		fast = fast-&gt;next-&gt;next;
		if (fast == slow) {
			return True;
		}
	}
	return False;
}
int Find_Loop(LinkList L) {
	LinkList fast, slow;
	if (L == NULL || L-&gt;next == NULL) {
		exit(ERROR);
	}
	fast = slow = L;
	while (fast-&gt;next != NULL &amp;&amp; fast-&gt;next-&gt;next != NULL) {
		slow = slow-&gt;next;
		fast = fast-&gt;next-&gt;next;
		if (fast == slow) {
			break;
		}
	}
	slow = L;
	while (fast != slow) {
		slow = slow-&gt;next;
		fast = fast-&gt;next;
	}
	printf(&quot;%d\n&quot;, slow-&gt;data );
	return TRUE;
}
void Is_2List_Intersect2(LinkList L1, LinkList L2) {
	if (L1 == NULL || L2 == NULL) {
		exit(ERROR);
	}
	LinkList p = L1;
	LinkList q = L2;
	while (p-&gt;next) {
		p = p-&gt;next;
	}
	p-&gt;next = L1-&gt;next;
	if(Is_ListLoop(L2)) {
		printf(&quot;相交\n&quot;);
		printf(&quot;相交的第一个结点是：&quot;);
		Find_Loop(L2);
	} else {
		printf(&quot;不相交\n&quot;);
	}
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[漫谈《大型网站技术架构》]]></title>
        <id>https://faded.auspicious.space/post/a-random-talk-on-large-website-technical-architecture/</id>
        <link href="https://faded.auspicious.space/post/a-random-talk-on-large-website-technical-architecture/">
        </link>
        <updated>2020-04-25T04:13:45.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p><a href="https://www.jianshu.com/p/9cf3ff1ecb88">漫谈《大型网站技术架构》</a></p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p><a href="https://www.jianshu.com/p/9cf3ff1ecb88">漫谈《大型网站技术架构》</a></p>
</blockquote>
<!-- more -->
<h1 id="一-大型网站的架构演化">一、大型网站的架构演化</h1>
<h2 id="11-大型网站软件的特点">1.1 大型网站软件的特点</h2>
<ul>
<li>高并发、大流量</li>
<li>高可用：系统7*24小时不间断提供服务</li>
<li>海量数据</li>
<li>用户分布广泛</li>
<li>安全环境恶劣</li>
<li>需求变更快，发布频繁</li>
<li>渐进式发展</li>
</ul>
<h2 id="12-大型网站架构演化发展历程">1.2 大型网站架构演化发展历程</h2>
<ul>
<li><strong>初始阶段的网站架构</strong>：一台服务器，上面同时拥有应用程序，数据库，文件，等所有资源。例如 LAMP 架构。</li>
<li><strong>应用和数据服务分离</strong>：三台服务器（硬件资源各不相同），分别是应用服务器，文件服务器和数据库服务器。</li>
<li><strong>使用缓存改善网站性能</strong>：分为两种，缓存在应用服务器上的本地缓存和缓存在专门的分布式缓存服务器的远程缓存。</li>
<li><strong>使用应用服务器集群改善网站并发处理能力</strong>：通过负载均衡调度服务器来将访问请求分发到应用服务器集群中的任何一台机器。</li>
<li><strong>数据库读写分离</strong>：数据库采用主从热备，应用服务器在写数据时访问主数据库，主数据库通过主从复制机制将数据更新同步到从数据库。应用服务器使用专门的数据访问模块从而对应用透明。</li>
<li><strong>使用反向代理和 CDN 加速网站响应</strong>：这两者基本原理都是缓存。反向代理部署在网站的中心机房，CDN 部署在网络提供商的机房。</li>
<li><strong>使用分布式文件系统和分布式数据库系统</strong>：数据库拆分的最后手段，更常用的是业务分库。</li>
<li><strong>使用 NoSQL 和搜索引擎</strong>：对可伸缩的分布式有更好的支持。</li>
<li><strong>业务拆分</strong>：将整个网站业务拆分成不同的应用，每个应用独立部署维护，应用之间通过超链接建立联系/消息队列进行数据分发/访问同一数据存储系统。</li>
<li><strong>分布式服务</strong>：公共业务提取出来独立部署。</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://faded.auspicious.space/post-images/1587788408370.png" alt="架构设计_分布式服务" loading="lazy"></figure>
<h2 id="13-大型网站架构演化的价值观">1.3 大型网站架构演化的价值观</h2>
<ul>
<li>大型网站架构的核心价值是随网站所需灵活应对。</li>
<li>驱动大型网站技术发展的主要力量是网站的业务发展。</li>
</ul>
<h2 id="14-网站架构设计误区">1.4 网站架构设计误区</h2>
<ul>
<li>一味追随大公司的解决方案。</li>
<li>为了技术而技术。</li>
<li>企图用技术解决所有问题。</li>
</ul>
<h1 id="二-大型网站架构模式">二、大型网站架构模式</h1>
<h2 id="21-网站架构模式">2.1 网站架构模式</h2>
<ul>
<li>分层<br>
-分割<br>
-分布式
<ul>
<li>分布式应用和服务</li>
<li>分布式静态资源</li>
<li>分布式数据和存储</li>
<li>分布式计算</li>
</ul>
</li>
<li>集群</li>
<li>缓存
<ul>
<li>CDN</li>
<li>反向代理</li>
<li>本地缓存</li>
<li>分布式缓存</li>
</ul>
</li>
<li>异步
<ul>
<li>提供系统可用性</li>
<li>加快网站响应速度</li>
<li>消除高并发访问高峰</li>
</ul>
</li>
<li>冗余
<ul>
<li>服务器冗余运行</li>
<li>数据库冗余备份</li>
</ul>
</li>
<li>自动化</li>
<li>安全
<ul>
<li>防止 XSS 攻击</li>
<li>SQL 注入</li>
</ul>
</li>
</ul>
<h1 id="三-大型网站核心架构要素">三、大型网站核心架构要素</h1>
<ul>
<li>性能</li>
<li>可用性</li>
<li>伸缩性：不断地向服务器集群加服务器</li>
<li>扩张性</li>
</ul>
<h1 id="四-瞬时响应网站的高性能架构">四、瞬时响应：网站的高性能架构</h1>
<h2 id="41-网站性能测试">4.1 网站性能测试</h2>
<ul>
<li>不同视角下网站的性能
<ul>
<li>用户视角网站性能 响应时间</li>
<li>开发人员视角的网站性能 响应时间、并发量</li>
<li>运维人员视角的网站性能 资源</li>
</ul>
</li>
<li>性能测试指标
<ul>
<li>响应时间</li>
<li>并发数</li>
<li>吞吐量 qps tps hps</li>
<li>性能计数器</li>
</ul>
</li>
<li>性能测试方法
<ul>
<li>性能测试</li>
<li>负载测试</li>
<li>压力测试</li>
<li>稳定性测试</li>
</ul>
</li>
<li>性能测试报告</li>
<li>性能优化策略
<ul>
<li>性能分析</li>
<li>性能优化</li>
</ul>
</li>
</ul>
<h2 id="42-web-前端性能优化">4.2 Web 前端性能优化</h2>
<ul>
<li>浏览器访问优化
<ul>
<li>减少 HTTP 请求</li>
<li>使用浏览器缓存</li>
<li>启用压缩</li>
<li>CSS 放在网页最上面 JS 最下面</li>
<li>减少 Cookie 传输</li>
</ul>
</li>
<li>CDN 加速。（Content Delivery Network)</li>
<li>反向代理</li>
</ul>
<h2 id="43-应用服务器性能优化">4.3 应用服务器性能优化</h2>
<ul>
<li>分布式缓存
<ul>
<li>缓存的基本原理</li>
<li>合理的使用缓存
<ul>
<li>频繁修改数据</li>
<li>没有热点的访问</li>
<li>数据不一致与脏读</li>
<li>缓存可用性</li>
<li>缓存预热</li>
<li>缓存穿透 缓存不存在，直接访问数据库</li>
</ul>
</li>
<li>分布式缓存架构</li>
<li>Memcached</li>
</ul>
</li>
<li>异步操作</li>
<li>使用集群</li>
<li>代码优化
<ul>
<li>多线程</li>
<li>资源复用</li>
<li>数据结构</li>
<li>垃圾回收</li>
</ul>
</li>
</ul>
<h2 id="44-存储性能优化">4.4 存储性能优化</h2>
<ul>
<li>机械硬盘 vs. 固态硬盘</li>
<li>B+ 树 vs. LSM 树</li>
<li>RAID vs. HDFS</li>
</ul>
<h1 id="五-万无一失网站的高可用架构">五、万无一失：网站的高可用架构</h1>
<h2 id="51-网站可用性的度量和考核">5.1 网站可用性的度量和考核</h2>
<ul>
<li>网站可行性度量</li>
<li>网站可用性考核</li>
</ul>
<h2 id="52-高可用的网站架构">5.2 高可用的网站架构</h2>
<h2 id="53-高可用的应用">5.3 高可用的应用</h2>
<ul>
<li>通过负载均衡进行无状态服务的失效转移</li>
<li>应用服务器集群的 Session 管理
<ul>
<li>Session复制</li>
<li>Session绑定</li>
<li>利用 Cookie 记录 Session</li>
<li>Session服务器</li>
</ul>
</li>
</ul>
<h2 id="54-高可用的应用">5.4 高可用的应用</h2>
<ul>
<li>分级管理</li>
<li>超时设置</li>
<li>异步调用</li>
<li>服务降级 随机拒绝访问（twitter)</li>
<li>幂等性设计</li>
</ul>
<h2 id="55-高可用的数据">5.5 高可用的数据</h2>
<ul>
<li>CAP 原理
<ul>
<li>数据持久性</li>
<li>数据可访问性</li>
<li>数据一致性
<ul>
<li>数据强一致性</li>
<li>数据用户一致性</li>
<li>数据最终一致性</li>
</ul>
</li>
<li>数据备份</li>
<li>失效转移
<ul>
<li>失效确认</li>
<li>访问转移</li>
<li>数据恢复</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="56-高可用软件质量保障">5.6 高可用软件质量保障</h2>
<ul>
<li>网站发布</li>
<li>自动化测试</li>
<li>预发布验证</li>
<li>代码控制
<ul>
<li>主干开发，分支发布</li>
<li>分支开发，主干发布</li>
</ul>
</li>
<li>自动化发布</li>
<li>灰度发布</li>
</ul>
<h2 id="57-网站运行监控">5.7 网站运行监控</h2>
<ul>
<li>监控数据采集
<ul>
<li>用户行为日志收集</li>
<li>服务器性能检测</li>
<li>运行数据报告</li>
</ul>
</li>
<li>监控管理
<ul>
<li>系统报警</li>
<li>失效转移</li>
<li>自动优雅降级</li>
</ul>
</li>
</ul>
<h1 id="六-永无止尽网站的伸缩性架构">六、永无止尽：网站的伸缩性架构</h1>
<h2 id="61-网站伸缩性设计">6.1 网站伸缩性设计</h2>
<ul>
<li>不同功能进行物理分离实现伸缩</li>
<li>单一功能通过集群实现伸缩</li>
</ul>
<h2 id="62-应用服务器集群伸缩设计">6.2 应用服务器集群伸缩设计</h2>
<ul>
<li>HTTP 重定向负载均衡</li>
<li>DNS 域名解析负载均衡</li>
<li>反向代理负载均衡</li>
<li>IP 负载均衡</li>
<li>数据链路层负载均衡</li>
<li>负载均衡算法
<ul>
<li>轮询</li>
<li>加权轮询</li>
<li>随机</li>
<li>最少链接</li>
<li>原地址散列</li>
</ul>
</li>
</ul>
<h2 id="63-分布式缓存集群的伸缩性设计">6.3 分布式缓存集群的伸缩性设计</h2>
<ul>
<li>Memcached 分布式缓存集群的访问模型</li>
<li>Memcached 分布式缓存集群的伸缩性挑战</li>
<li>分布式缓存的一致性 hash 算法</li>
</ul>
<h2 id="64-数据存储服务器集群的伸缩性设计">6.4 数据存储服务器集群的伸缩性设计</h2>
<ul>
<li>关系数据库集群的伸缩性设计</li>
<li>NoSQL 数据库的伸缩性设计</li>
</ul>
<h1 id="七-随机应变网站的可扩展性架构">七、随机应变：网站的可扩展性架构</h1>
<h2 id="71-构建可扩展性的网站架构">7.1 构建可扩展性的网站架构</h2>
<h2 id="72-利用分布式消息队列降低系统耦合性">7.2 利用分布式消息队列降低系统耦合性</h2>
<ul>
<li>事件驱动架构</li>
<li>分布式消息队列</li>
</ul>
<h2 id="73-利用分布式服务打造可复用的业务平台">7.3 利用分布式服务打造可复用的业务平台</h2>
<ul>
<li>Web Service 与企业级分布式服务</li>
<li>大型网站分布式服务的需求与特点
<ul>
<li>负载均衡</li>
<li>失效转移</li>
<li>高效的远程通信</li>
<li>整合异构系统</li>
<li>对应用最少侵入</li>
<li>版本控制</li>
<li>实时监控</li>
</ul>
</li>
<li>分布式服务框架设计</li>
</ul>
<h2 id="74-可扩展的数据结构">7.4 可扩展的数据结构</h2>
<h2 id="75-利用开放平台建设网站生态圈">7.5 利用开放平台建设网站生态圈</h2>
<ul>
<li>API 接口</li>
<li>协议转移</li>
<li>安全</li>
<li>审计</li>
<li>路由</li>
<li>流程</li>
</ul>
<h1 id="八-固若金汤网站的安全架构">八、固若金汤：网站的安全架构</h1>
<h2 id="81-道高一尺魔高一丈的网站应用攻击与防御">8.1 道高一尺魔高一丈的网站应用攻击与防御</h2>
<ul>
<li>xss攻击
<ul>
<li>消毒</li>
<li>HTTP Only</li>
</ul>
</li>
<li>注入攻击
<ul>
<li>开源</li>
<li>错误回显</li>
<li>盲注</li>
<li>消毒</li>
<li>参数绑定</li>
</ul>
</li>
<li>CSRF 攻击
<ul>
<li>表单token</li>
<li>验证码</li>
<li>Referer Check</li>
</ul>
</li>
<li>其他攻击和漏洞
<ul>
<li>Error Code</li>
<li>HTML 注释</li>
<li>文件上传</li>
<li>路径遍历</li>
</ul>
</li>
<li>Web 应用防火墙</li>
<li>网站安全漏洞扫描</li>
</ul>
<h2 id="82-信息加密技术及密钥安全管理">8.2 信息加密技术及密钥安全管理</h2>
<ul>
<li>单向散列加密</li>
<li>对称加密</li>
<li>非对称加密</li>
<li>密钥安全管理</li>
</ul>
<h2 id="83-信息过滤与反垃圾">8.3 信息过滤与反垃圾</h2>
<ul>
<li>文本匹配</li>
<li>分类算法</li>
<li>黑名单</li>
</ul>
<h2 id="84-电子商务风险控制">8.4 电子商务风险控制</h2>
<ul>
<li>风险
<ul>
<li>账号风险</li>
<li>买家风险</li>
<li>卖家风险</li>
<li>交易风险</li>
</ul>
</li>
<li>风控
<ul>
<li>规则引擎</li>
<li>统计模型</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[UML—简介]]></title>
        <id>https://faded.auspicious.space/post/uml-introduction/</id>
        <link href="https://faded.auspicious.space/post/uml-introduction/">
        </link>
        <updated>2020-04-25T02:48:03.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p><a href="https://www.jianshu.com/p/7e7a03de6d21">uml学习</a></p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p><a href="https://www.jianshu.com/p/7e7a03de6d21">uml学习</a></p>
</blockquote>
<!-- more -->
<h1 id="概念">概念</h1>
<ol>
<li><strong>类（Class）</strong>：使用三层矩形框表示。
<ul>
<li>第一层显示类的名称，如果是抽象类，则就用斜体显示。</li>
<li>第二层是字段和属性。</li>
<li>第三层是类的方法。<br>
注意前面的符号，<code>+</code> 表示 <code>public</code>，<code>-</code> 表示 <code>private</code>，<code>#</code> 表示 <code>protected</code>。</li>
</ul>
</li>
<li><strong>接口</strong>：使用两层矩形框表示，与类图的区别主要是顶端有 <code>&lt;&gt;</code> 显示 。
<ul>
<li>第一行是接口名称。</li>
<li>第二行是接口方法。</li>
</ul>
</li>
<li><strong>继承类（extends）</strong>：用空心三角形 + 实线来表示。</li>
<li><strong>实现接口（implements）</strong>：用空心三角形 + 虚线来表示。</li>
<li><strong>关联（Association）</strong>：用实线箭头来表示，例如：燕子与气候。</li>
<li><strong>聚合（Aggregation）</strong>：用空心的菱形 + 实线箭头来表示。<br>
聚合：表示一种弱的‘拥有’关系，体现的是 A 对象可以包含 B 对象，但 B 对象不是 A 对象的一部分，例如：公司和员工。</li>
<li><strong>组合（Composition）</strong>：用实心的菱形 + 实线箭头来表示。<br>
组合：部分和整体的关系，并且生命周期是相同的。例如：人与手。</li>
<li><strong>依赖（Dependency）</strong>：用虚线箭头来表示，例如：动物与氧气。</li>
<li><strong>基数</strong> ：连线两端的数字表明这一端的类可以有几个实例，比如：一个鸟应该有两只翅膀。如果一个类可能有无数个实例，则就用‘n’来表示。关联、聚合、组合是有基数的。</li>
</ol>
<h1 id="类之间的关系">类之间的关系</h1>
<p>UML 把类之间的关系分为以下 5 种：</p>
<ul>
<li><strong>关联</strong>：类 A 与类 B 的实例之间存在特定的对应关系；</li>
<li><strong>依赖</strong>：类 A 访问类 B 提供的服务；</li>
<li><strong>聚集</strong>：类 A 为整体类，类 B 为局部类，类 A 的对象由类 B 的对象组合而成；</li>
<li><strong>泛化</strong>：类 A 继承类 B；</li>
<li><strong>实现</strong>：类 A 实现了 B 接口</li>
</ul>
<h2 id="关联association">关联（Association）</h2>
<p>关联指的是类之间的特定对应关系，在 UML 中用带实线的箭头表示。按照类之间的数量对比，关联可以分为以下三种：</p>
<ul>
<li>一对一关联；</li>
<li>一对多关联；</li>
<li>多对多关联。</li>
</ul>
<p>注意：关联还要以分为<strong>单向关联</strong>和<strong>双向关联</strong>。</p>
<h2 id="依赖dependency">依赖（Dependency）</h2>
<p>依赖指的是类之间的调用关系，在 UML 中用带虚线的箭头表示。如果类 A 访问类 B 的属性或者方法，  或者类 A 负责实例化类 B，那么可以说类 A 依赖类 B。和关联关系不同，无须在类 A 中定义类 B 类型的属性。</p>
<h2 id="聚集aggregation">聚集（Aggregation）</h2>
<p>聚集指的是整体与部分之间的关系，在 UML 中用带实线的菱形箭头表示。</p>
<p>聚集关系还可以分为两种类型：</p>
<ul>
<li>被聚集的子系统允许被拆卸和替换，这是普通聚集关系。</li>
<li>被聚集的子系统不允许被拆卸和替换，这种聚集称为强聚集关系，或者组成关系。</li>
</ul>
<p>注：强聚集（组成）可用带实线的实心菱形箭头表示。</p>
<h2 id="泛化generalization">泛化（Generalization）</h2>
<p>泛化指的是类之间的继承关系，在 UML 中用带实线的三角形箭头表示。</p>
<h2 id="实现realization">实现（Realization）</h2>
<p>实现指的是类与接口之间的关系，在 UML 中用带虚线的三角形箭头表示。</p>
<ol>
<li><img src="https://faded.auspicious.space/post-images/1587783886562.png" alt="" loading="lazy"></li>
<li><img src="https://faded.auspicious.space/post-images/1587783928940.png" alt="" loading="lazy"></li>
<li><img src="https://faded.auspicious.space/post-images/1587783950528.png" alt="" loading="lazy"></li>
<li><img src="https://faded.auspicious.space/post-images/1587783975197.png" alt="" loading="lazy"></li>
<li><img src="https://faded.auspicious.space/post-images/1587783994785.png" alt="" loading="lazy"></li>
<li><img src="https://faded.auspicious.space/post-images/1587784018076.png" alt="" loading="lazy"></li>
<li><img src="https://faded.auspicious.space/post-images/1587784045445.png" alt="" loading="lazy"></li>
<li><img src="https://faded.auspicious.space/post-images/1587784066892.png" alt="" loading="lazy"></li>
<li><img src="https://faded.auspicious.space/post-images/1587784111857.png" alt="" loading="lazy"></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[现代 IM 系统中消息推送和存储架构的实现]]></title>
        <id>https://faded.auspicious.space/post/implementation-of-message-push-and-storage-architecture-in-modern-im-system/</id>
        <link href="https://faded.auspicious.space/post/implementation-of-message-push-and-storage-architecture-in-modern-im-system/">
        </link>
        <updated>2020-04-25T01:44:47.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p><a href="https://www.jianshu.com/p/6a5e7611435d">现代IM系统中消息推送和存储架构的实现</a></p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p><a href="https://www.jianshu.com/p/6a5e7611435d">现代IM系统中消息推送和存储架构的实现</a></p>
</blockquote>
<!-- more -->
<h1 id="前言">前言</h1>
<p>IM 全称是“Instant Messaging”，中文名是即时通讯。在这个高度信息化的移动互联网时代，生活中 IM 类产品已经成为必备品，比较有名的如钉钉、微信、QQ 等以 IM 为核心功能的产品。当然目前微信已经成长为一个生态型产品，但其核心功能还是 IM。还有一些非以 IM 系统为核心的应用，最典型的如一些在线游戏、社交应用，IM 也是其重要的功能模块。可以说，带有社交属性的应用，IM 功能一定是必不可少的。</p>
<p>IM 系统在互联网初期即存在，其基础技术架构在这十几年的发展中更新迭代多次，从早期的 CS、P2P 架构，到现在后台已经演变为一个复杂的分布式系统，涉及移动端、网络、安全和存储等技术的方方面面。其支撑的规模也从早期的少量日活，到现在微信这个巨头最新公布的达到 9 亿的日活的体量。</p>
<p>IM 系统中最核心的部分是消息系统，消息系统中最核心的功能是消息的同步和存储：</p>
<ul>
<li><strong>消息的同步</strong>：将消息完整的、快速的从发送方传递到接收方，就是消息的同步。消息同步系统最重要的衡量指标就是消息传递的实时性、完整性以及能支撑的消息规模。从功能上来说，一般至少要支持在线和离线推送，高级的 IM 系统还支持“<strong>多端同步</strong>”。</li>
<li><strong>消息的存储</strong>：消息存储即消息的持久化保存，这里不是指消息在客户端本地的保存，而是指云端的保存，功能上对应的就是“<strong>消息漫游</strong>”。“<strong>消息漫游</strong>”的好处是可以实现账号在任意端登陆查看所有历史消息，这也是高级 IM 系统特有的功能之一。</li>
</ul>
<p>本篇文章内容主要涉及 IM 系统中的消息系统架构，会介绍一种基于 TableStore 构建的消息同步以及存储系统的架构实现，能够支持消息系统中的高级特性“<strong>多端同步</strong>”以及“<strong>消息漫游</strong>”。在性能和规模上，能够做到全量消息云端存储，百万 TPS 以及毫秒级延迟的消息同步能力。</p>
<h1 id="架构设计">架构设计</h1>
<p>本章主要会介绍基于 TableStore 的现代 IM 消息系统的架构设计，在详细介绍架构设计之前，会先介绍一种 Timeline 逻辑模型，来抽象和简化对 IM 消息同步和存储模型的理解。理解了 Timeline 模型后，会介绍如何基于此模型对消息的同步以及存储进行建模。基于 Timeline 模型，在实现消息同步和存储时还会有各方面的技术权衡，例如如何对消息同步常见的读扩散和写扩散两种模型进行对比和选择，以及针对 Timeline 模型的特征如何来选择底层数据库。</p>
<h2 id="传统架构-vs-现代架构">传统架构 vs 现代架构</h2>
<figure data-type="image" tabindex="1"><img src="https://faded.auspicious.space/post-images/1587779925317.png" alt="消息系统传统架构与现代架构的简单对比" loading="lazy"></figure>
<p>传统架构下，消息是先同步后存储。对于在线的用户，消息会直接实时同步到在线的接收方，消息同步成功后，并不会进行持久化。而对于离线的用户或者消息无法实时同步成功时，消息会持久化到离线库，当接收方重新连接后，会从离线库拉取所有未读消息。当离线库中的消息成功同步到接收方后，消息会从离线库中删除。传统的消息系统，服务端的主要工作是维护发送方和接收方的连接状态，并提供在线消息同步和离线消息缓存的能力，保证消息一定能够从发送方传递到接收方。服务端不会对消息进行持久化，所以也无法支持消息漫游。</p>
<p>现代架构下，消息是先存储后同步。先存储后同步的好处是，如果接收方确认接收到了消息，那这条消息一定是已经在云端保存了。并且消息会有两个库来保存，一个是消息存储库，用于全量保存所有会话的消息，主要用于支持消息漫游。另一个是消息同步库，主要用于接收方的多端同步。消息从发送方发出后，经过服务端转发，服务端会先将消息保存到消息存储库，后保存到消息同步库。完成消息的持久化保存后，对于在线的接收方，会直接选择在线推送。但在线推送并不是一个必须路径，只是一个更优的消息传递路径。对于在线推送失败或者离线的接收方，会有另外一个统一的消息同步方式。接收方会主动的向服务端拉取所有未同步消息，但接收方何时来同步以及会在哪些端来同步消息对服务端来说是未知的，所以要求服务端必须保存所有需要同步到接收方的消息，这是消息同步库的主要作用。对于新的同步设备，会有消息漫游的需求，这是消息存储库的主要作用，在消息存储库中，可以拉取任意会话的全量历史消息。</p>
<p>以上是传统架构和现代架构的一个简单的对比，现代架构上整个消息的同步和存储流程，并没有变复杂太多，但是其能实现多端同步以及消息漫游。现代架构中最核心的就是两个消息库“<strong>消息同步库</strong>”和“<strong>消息存储库</strong>”，是消息同步和存储最核心的基础。而本篇文章接下来的部分，都是围绕这两个库的设计和实现来展开。</p>
<h2 id="timeline-模型">Timeline 模型</h2>
<p>在分析“<strong>消息同步库</strong>”和“<strong>消息存储库</strong>”的设计和实现之前，在本章会先介绍一个逻辑模型——Timeline。Timeline 模型会帮助我们简化对消息同步和存储模型的理解，而消息库的设计和实现也是围绕 Timeline 的特性和需求来展开。</p>
<figure data-type="image" tabindex="2"><img src="https://faded.auspicious.space/post-images/1587781148322.png" alt="" loading="lazy"></figure>
<p>如图是 Timeline 模型的一个抽象表述，Timeline 可以简单理解为是一个消息队列，但这个消息队列有如下特性：</p>
<ul>
<li>每个消息拥有一个顺序 ID（SeqId），在队列后面的消息的 SeqId 一定比前面的消息的 SeqId 大，也就是保证 SeqId 一定是增长的，但是不要求严格递增。</li>
<li>新的消息永远在尾部添加，保证新的消息的 SeqId 永远比已经存在队列中的消息都大。</li>
<li>可根据 SeqId 随机定位到具体的某条消息进行读取，也可以任意读取某个给定范围内的所有消息。</li>
</ul>
<p>有了这些特性后，消息的同步可以拿 Timeline 来很简单的实现。图中的例子中，消息发送方是 A，消息接收方是 B，同时 B 存在多个接收端，分别是 B1、B2 和 B3。A 向 B 发送消息，消息需要同步到 B 的多个端，待同步的消息通过一个 Timeline 来进行交换。A 向 B 发送的所有消息，都会保存在这个 Timeline 中，B 的每个接收端都是独立的从这个 Timeline 中拉取消息。每个接收端同步完毕后，都会在本地记录下最新同步到的消息的 SeqId，即最新的一个位点，作为下次消息同步的起始位点。服务端不会保存各个端的同步状态，各个端均可以在任意时间从任意点开始拉取消息。</p>
<p>消息漫游也是基于 Timeline，和消息同步唯一的区别是，消息漫游要求服务端能够对 Timeline 内的所有数据进行持久化。</p>
<p>基于 Timeline，从逻辑模型上能够很简单的理解在服务端如何去实现消息同步和存储，并支持多端同步和消息漫游这些高级功能。落地到实现的难点主要在如何将逻辑模型映射到物理模型，Timeline 的实现对数据库会有哪些要求？我们应该选择何种数据库去实现？这些是接下来会讨论到的问题。</p>
<h2 id="消息存储模型">消息存储模型</h2>
<p><img src="https://faded.auspicious.space/post-images/1587781324683.png" alt="" loading="lazy"><br>
如图是基于 Timeline 的消息存储模型，消息存储要求每个会话都对应一个独立的 Timeline。如图例子所示，A 与 B/C/D/E/F 均发生了会话，每个会话对应一个独立的 Timeline，每个 Timeline 内存有这个会话中的所有消息，服务端会对每个 Timeline 进行持久化。服务端能够对所有会话 Timeline 中的全量消息进行持久化，也就拥有了消息漫游的能力。</p>
<h2 id="消息同步模型">消息同步模型</h2>
<p>消息同步模型会比消息存储模型稍复杂一些，消息的同步一般有读扩散和写扩散两种不同的方式，分别对应不同的 Timeline 物理模型。<br>
<img src="https://faded.auspicious.space/post-images/1587781412550.png" alt="" loading="lazy"></p>
<p>如图是读扩散和写扩散两种不同同步模式下对应的不同的 Timeline 模型，按图中的示例，A 作为消息接收者，其与 B/C/D/E/F 发生了会话，每个会话中的新的消息都需要同步到 A 的某个端，看下读扩散和写扩散两种模式下消息如何做同步。</p>
<h3 id="读扩散">读扩散</h3>
<p>消息存储模型中，每个会话的 Timeline 中保存了这个会话的全量消息。读扩散的消息同步模式下，每个会话中产生的新的消息，只需要写一次到其用于存储的 Timeline 中，接收端从这个 Timeline 中拉取新的消息。优点是消息只需要写一次，相比写扩散的模式，能够大大降低消息写入次数，特别是在群消息这种场景下。但其缺点也比较明显，接收端去同步消息的逻辑会相对复杂和低效。接收端需要对每个会话都拉取一次才能获取全部消息，读被大大的放大，并且会产生很多无效的读，因为并不是每个会话都会有新消息产生。</p>
<h3 id="写扩散">写扩散</h3>
<p>写扩散的消息同步模式，需要有一个额外的 Timeline 来专门用于消息同步，通常是每个接收端都会拥有一个独立的同步 Timeline，用于存放需要向这个接收端同步的所有消息。每个会话中的消息，会产生多次写，除了写入用于消息存储的会话 Timeline，还需要写入需要同步到的接收端的同步 Timeline。在个人与个人的会话中，消息会被额外写两次，除了写入这个会话的存储 Timeline，还需要写入参与这个会话的两个接收者的同步 Timeline。而在群这个场景下，写入会被更加的放大，如果这个群拥有 N 个参与者，那每条消息都需要额外的写 N 次。写扩散同步模式的优点是，在接收端消息同步逻辑会非常简单，只需要从其同步 Timeline 中读取一次即可，大大降低了消息同步所需的读的压力。其缺点就是消息写入会被放大，特别是针对群这种场景。</p>
<p>在 IM 这种应用场景下，通常会选择写扩散这种消息同步模式。IM 场景下，一条消息只会产生一次，但是会被读取多次，是典型的读多写少的场景，消息的读写比例大概是 10:1。若使用读扩散同步模式，整个系统的读写比例会被放大到 100:1。一个优化的好的系统，必须从设计上去平衡这种读写压力，避免读或写任意一维触碰到天花板。所以 IM 系统这类场景下，通常会应用写扩散这种同步模式，来平衡读和写，将 100:1 的读写比例平衡到 30:30。当然写扩散这种同步模式，还需要处理一些极端场景，例如万人大群。针对这种极端写扩散的场景，会退化到使用读扩散。一个简单的 IM 系统，通常会在产品层面限制这种大群的存在，而对于一个高级的 IM 系统，会采用读写扩散混合的同步模式，来满足这类产品的需求。</p>
<h2 id="消息库设计">消息库设计</h2>
<p>基于 Timeline 模型，以及 Timeline 模型在消息存储和消息同步的应用，我们看下消息同步库和消息存储库的设计。<br>
<img src="https://faded.auspicious.space/post-images/1587781931258.png" alt="" loading="lazy"><br>
如图是基于Timeline的消息库设计。</p>
<h3 id="消息同步库">消息同步库</h3>
<p>消息同步库用于存储所有用于消息同步的 Timeline，每个 Timeline 对应一个接收端，主要用作写扩散模式的消息同步。这个库不需要永久保留所有需要同步的消息，因为消息在同步到所有端后其生命周期就可以结束，就可以被回收。但是如前面所介绍的，一个实现简单的多端同步消息系统，在服务端不会保存有所有端的同步状态，而是依赖端自己主动来做同步。所以服务端不知道消息何时可以回收，通常的做法是为这个库里的消息设定一个固定的生命周期，例如一周或者一个月，生命周期结束可被淘汰。</p>
<h3 id="消息存储库">消息存储库</h3>
<p>消息存储库用于存储所有会话的 Timeline，每个 Timeline 包含了一个会话中的所有消息。这个库主要用于消息漫游时拉取某个会话的所有历史消息，也用于读扩散模式的消息同步。</p>
<p>消息同步库和消息存储库，对数据库有不同的要求，如何对数据库做选型，在下面会讨论。</p>
<h2 id="数据库选型">数据库选型</h2>
<p>消息系统最核心的两个库是消息同步库和消息存储库，两个库对数据库有不同的要求：</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">消息同步库</th>
<th style="text-align:center">消息存储库</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>数据模型</strong></td>
<td style="text-align:center">Timeline 模型</td>
<td style="text-align:center">Timeline 模型</td>
</tr>
<tr>
<td style="text-align:center"><strong>写能力</strong></td>
<td style="text-align:center">高并发写，十万级 TPS</td>
<td style="text-align:center">高并发写，少量读，万级 TPS</td>
</tr>
<tr>
<td style="text-align:center"><strong>读能力</strong></td>
<td style="text-align:center">高并发范围读，十万级 TPS</td>
<td style="text-align:center">少量范围读，千级 TPS</td>
</tr>
<tr>
<td style="text-align:center"><strong>存储规模</strong></td>
<td style="text-align:center">保存一段时间内的同步消息，TB 级，保留千万级的 Timeline 规模</td>
<td style="text-align:center">保存全量消息，百 TB 级，保留亿级的 Timeline 规模</td>
</tr>
</tbody>
</table>
<p>总结下来，对数据库的要求有如下几点：</p>
<ul>
<li>表结构设计能够满足 Timeline 模型的功能要求：不要求关系模型，能够实现队列模型，并能够支持生成自增的 SeqId。</li>
<li>能够支持高并发写和范围读，规模在十万级TPS。</li>
<li>能够保存海量数据，百TB级。</li>
<li>能够为数据定义生命周期。</li>
</ul>
<p>阿里云表格存储（TableStore）是基于 LSM 存储引擎的分布式 NoSQL 数据库，支持百万 TPS 高并发读写，PB 级数据存储，数据支持 TTL，能够很好的满足以上需求，并且支持自增列，能够非常完美的设计和实现 Timeline 的物理模型。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Meta 标签设置]]></title>
        <id>https://faded.auspicious.space/post/meta-tag-configuration/</id>
        <link href="https://faded.auspicious.space/post/meta-tag-configuration/">
        </link>
        <updated>2020-04-25T01:37:05.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p><a href="https://www.jianshu.com/p/602e0a469255">meta标签设置</a></p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p><a href="https://www.jianshu.com/p/602e0a469255">meta标签设置</a></p>
</blockquote>
<!-- more -->
<p>meta 标签常用设置：</p>
<pre><code class="language-html">&lt;!-- 根据浏览器的屏幕大小自适应的展现合适的效果 --&gt;
&lt;meta name=&quot;applicable-device&quot; content=&quot;pc,mobile&quot; /&gt;

&lt;!-- 移动端 浏览器中页面将以原始大小显示，不允许缩放 --&gt;
&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no&quot; /&gt;

&lt;!--自动选择更好的浏览器--&gt;
&lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt;
//告诉浏览器这个网址应该用哪个内核渲染，那么浏览器就会在读取到这个标签后，立即切换对应的内核

&lt;!-- 优先使用 IE 最新版本和 Chrome --&gt;
&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot; /&gt;
//它必须显示在网页中除 title 元素和其他 meta 元素以外的所有其他元素之前。如果不是的话，它不起作用

&lt;!-- 描述文档类型 content表示文档类型，这里为text/html，如果JS就是text/javascript，charset表示页面字符集 --&gt;
&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;

&lt;!-- iphone会把一串数字识别为电话号码，点击的时候会提示是否呼叫，屏蔽这功能则把telephone设置为no --&gt;
&lt;meta content=&quot;telephone=no&quot; name=&quot;format-detection&quot; /&gt;

&lt;!-- iphone的私有标签，默认值为default（白色），可以定为black（黑色）和black-translucent（灰色半透明） --&gt;
&lt;meta content=&quot;black&quot; name=&quot;apple-mobile-web-app-status-bar-style&quot;&gt;

&lt;!-- iphone设备的是有标签 允许全屏模式浏览，隐藏浏览器导航栏 --&gt;
&lt;meta content=&quot;yes&quot; name=&quot;apple-mobile-web-app-capable&quot; /&gt;

&lt;!-- 全屏显示 --&gt;
&lt;meta content=&quot;yes&quot; name=&quot;apple-touch-fullscreen&quot; /&gt;

&lt;!-- UC强制全屏 --&gt;
&lt;meta name=&quot;full-screen&quot; content=&quot;yes&quot;&gt;

&lt;!-- QQ强制全屏 --&gt;
&lt;meta name=&quot;x5-fullscreen&quot; content=&quot;true&quot;&gt;

&lt;!-- 屏蔽百度转码 --&gt;
&lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-transform&quot; /&gt;
&lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-siteapp&quot; /&gt;

&lt;!-- 定义网页简短描述 --&gt;
&lt;meta name=&quot;description&quot; content=&quot;Cochemist&quot;&gt;

&lt;!-- 定义网页关键词 --&gt;
&lt;meta name=&quot;keywords&quot; content=&quot;生物化学&quot;&gt; 

&lt;!-- 定义网页的作者 --&gt;
&lt;meta name=&quot;author&quot; content=&quot;sun_Annie&quot;&gt;

&lt;!-- 避免HTML页面缓存 --&gt;
&lt;meta http-equiv=&quot;pragma&quot; content=&quot;no-cache&quot; /&gt;
&lt;meta http-equiv=&quot;cache-control&quot; content=&quot;no-cache&quot;&gt;
&lt;meta http-equiv=&quot;expires&quot; content=&quot;0&quot;&gt;

&lt;!-- 定义网页的缓存过期时间 --&gt;
&lt;meta http-equiv=&quot;expires&quot; content=&quot;Sunday 26 October 2016 00:00 GMT&quot;&gt;
//由于这是一个过去的日期，所以这个网页只要一打开，就会直接到网站服务器重新下载页面内容，而不是从cache调用。这是一种防止网页被cache缓存的措施。

</code></pre>
<h1 id="概要">概要</h1>
<blockquote>
<p>标签提供关于 HTML 文档的元数据。元数据不会显示在页面上，但是对于机器是可读的。它可用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他 web 服务。 —— W3School</p>
</blockquote>
<h2 id="必要属性">必要属性</h2>
<table>
<thead>
<tr>
<th>属性</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>content</td>
<td>some text</td>
<td>定义与http-equiv或name属性相关的元信息</td>
</tr>
</tbody>
</table>
<h2 id="可选属性">可选属性</h2>
<table>
<thead>
<tr>
<th>属性</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>http-equiv</td>
<td>content-type / expire / refresh / set-cookie</td>
<td>把 content 属性关联到 HTTP 头部。</td>
</tr>
<tr>
<td>name</td>
<td>author / description / keywords / generator / revised / others</td>
<td>把 content 属性关联到一个名称。</td>
</tr>
<tr>
<td>content</td>
<td>some text</td>
<td>定义用于翻译 content 属性值的格式。</td>
</tr>
</tbody>
</table>
<h1 id="seo">SEO</h1>
<p><a href="http://msdn.microsoft.com/zh-cn/library/ff724016">搜索引擎优化</a></p>
<h2 id="页面关键词">页面关键词</h2>
<p>每个网页应具有描述该网页内容的一组唯一的关键字。<br>
使用人们可能会搜索，并准确描述网页上所提供信息的描述性和代表性关键字及短语。标记内容太短，则搜索引擎可能不会认为这些内容相关。另外标记不应超过 874 个字符。</p>
<pre><code class="language-html">&lt;meta name=&quot;keywords&quot; content=&quot;your tags&quot; /&gt;
</code></pre>
<h2 id="页面描述">页面描述</h2>
<p>每个网页都应有一个不超过 150 个字符且能准确反映网页内容的描述标签。</p>
<pre><code class="language-html">&lt;meta name=&quot;description&quot; content=&quot;150 words&quot; /&gt;
</code></pre>
<h2 id="搜索引擎索引方式">搜索引擎索引方式</h2>
<p><code>robot terms</code> 是一组使用逗号 <code>,</code> 分割的值，通常有如下几种取值：<code>none</code>，<code>noindex</code>，<code>nofollow</code>，<code>all</code>，<code>index</code> 和 <code>follow</code>。确保正确使用 <code>nofollow</code> 和 <code>noindex</code> 属性值。</p>
<pre><code class="language-html">&lt;meta name=&quot;robots&quot; content=&quot;index,follow&quot; /&gt;
&lt;!--
    all：文件将被检索，且页面上的链接可以被查询；
    none：文件将不被检索，且页面上的链接不可以被查询；
    index：文件将被检索；
    follow：页面上的链接可以被查询；
    noindex：文件将不被检索；
    nofollow：页面上的链接不可以被查询。
 --&gt;
</code></pre>
<h2 id="页面重定向和刷新">页面重定向和刷新</h2>
<p><code>content</code> 内的数字代表时间（秒），既多少时间后刷新。如果加 <code>url</code>，则会重定向到指定网页（搜索引擎能够自动检测，也很容易被引擎视作误导而受到惩罚）。</p>
<pre><code class="language-html">&lt;meta http-equiv=&quot;refresh&quot; content=&quot;0;url=&quot; /&gt;
</code></pre>
<h2 id="其他">其他</h2>
<pre><code class="language-html">&lt;meta name=&quot;author&quot; content=&quot;author name&quot; /&gt; &lt;!-- 定义网页作者 --&gt;
&lt;meta name=&quot;google&quot; content=&quot;index,follow&quot; /&gt;
&lt;meta name=&quot;googlebot&quot; content=&quot;index,follow&quot; /&gt;
&lt;meta name=&quot;verify&quot; content=&quot;index,follow&quot; /&gt;
</code></pre>
<h1 id="移动设备">移动设备</h1>
<h2 id="viewport">viewport</h2>
<p>能优化移动浏览器的显示。如果不是响应式网站，不要使用 <code>initial-scale</code> 或者禁用缩放。<br>
大部分 4.7-5 寸设备的 <code>viewport</code> 宽设为 360px；5.5 寸设备设为 400px；iPhone6 设为 375px；iPone6 Plus 设为414px。</p>
<pre><code class="language-html">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0,maximum-scale=1.0, user-scalable=no&quot;/&gt;
&lt;!-- `width=device-width` 会导致 iPhone 5 添加到主屏后以 WebApp 全屏模式打开页面时出现黑边  --&gt;
</code></pre>
<ol>
<li><code>width</code>：宽度（数值 / <code>device-width</code>）（范围从 200 到 10,000，默认为 980 像素）；</li>
<li><code>height</code>：高度（数值 / <code>device-height</code>）（范围从 223 到 10,000）；</li>
<li><code>initial-scale</code>：初始的缩放比例 （范围从 &gt;0 到 10）；</li>
<li><code>minimum-scale</code>：允许用户缩放到的最小比例；</li>
<li><code>maximum-scale</code>：允许用户缩放到的最大比例；</li>
<li><code>user-scalable</code>：用户是否可以手动缩 (<code>no</code>, <code>yes</code>)；</li>
<li><code>minimal-ui</code>：可以在页面加载时最小化上下状态栏。（已弃用）</li>
</ol>
<p>注意，很多人使用 <code>initial-scale=1</code> 到非响应式网站上，这会让网站以 100% 宽度渲染，用户需要手动移动页面或者缩放。如果和 <code>initial-scale=1</code> 同时使用 <code>user-scalable=no</code> 或 <code>maximum-scale=1</code>，则用户将不能放大/缩小网页来看到全部的内容。</p>
<h2 id="webapp-全屏模式">WebApp 全屏模式</h2>
<p>伪装 App，离线应用。</p>
<pre><code class="language-html">&lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot; /&gt; &lt;!-- 启用 WebApp 全屏模式 --&gt;
</code></pre>
<h2 id="隐藏状态栏设置状态栏颜色">隐藏状态栏/设置状态栏颜色</h2>
<p>只有在开启 WebApp 全屏模式时才生效。<code>content</code> 的值为 <code>default | black | black-translucent</code>。</p>
<pre><code class="language-html">&lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black-translucent&quot; /&gt;
</code></pre>
<h2 id="添加到主屏后的标题">添加到主屏后的标题</h2>
<pre><code class="language-html">&lt;meta name=&quot;apple-mobile-web-app-title&quot; content=&quot;标题&quot;&gt;
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://faded.auspicious.space/post-images/1587787337510.png" alt="" loading="lazy"></figure>
<h2 id="忽略数字自动识别为电话号码">忽略数字自动识别为电话号码</h2>
<pre><code class="language-html">&lt;meta content=&quot;telephone=no&quot; name=&quot;format-detection&quot; /&gt; 
</code></pre>
<h2 id="忽略识别邮箱">忽略识别邮箱</h2>
<pre><code class="language-html">&lt;meta content=&quot;email=no&quot; name=&quot;format-detection&quot; /&gt;
</code></pre>
<h2 id="添加智能-app-广告条-smart-app-banner">添加智能 App 广告条 Smart App Banner</h2>
<p>告诉浏览器这个网站对应的 App，并在页面上显示下载 banner（如下图）。<a href="https://developer.apple.com/library/ios/documentation/AppleApplications/Reference/SafariWebContent/PromotingAppswithAppBanners/PromotingAppswithAppBanners.html">Promoting Apps with Smart App Banners</a></p>
<pre><code class="language-html">&lt;meta name=&quot;apple-itunes-app&quot; content=&quot;app-id=myAppStoreID, affiliate-data=myAffiliateData, app-argument=myURL&quot;&gt; 
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://faded.auspicious.space/post-images/1587787470047.jpg" alt="" loading="lazy"></figure>
<h2 id="其他-2">其他</h2>
<p><a href="http://fex.baidu.com/blog/2014/10/html-head-tags/">HTML head 头标签</a></p>
<pre><code class="language-html">&lt;!-- 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 --&gt;
&lt;meta name=&quot;HandheldFriendly&quot; content=&quot;true&quot;&gt;
&lt;!-- 微软的老式浏览器 --&gt;
&lt;meta name=&quot;MobileOptimized&quot; content=&quot;320&quot;&gt;
&lt;!-- uc强制竖屏 --&gt;
&lt;meta name=&quot;screen-orientation&quot; content=&quot;portrait&quot;&gt;
&lt;!-- QQ强制竖屏 --&gt;
&lt;meta name=&quot;x5-orientation&quot; content=&quot;portrait&quot;&gt;
&lt;!-- UC强制全屏 --&gt;
&lt;meta name=&quot;full-screen&quot; content=&quot;yes&quot;&gt;
&lt;!-- QQ强制全屏 --&gt;
&lt;meta name=&quot;x5-fullscreen&quot; content=&quot;true&quot;&gt;
&lt;!-- UC应用模式 --&gt;
&lt;meta name=&quot;browsermode&quot; content=&quot;application&quot;&gt;
&lt;!-- QQ应用模式 --&gt;
&lt;meta name=&quot;x5-page-mode&quot; content=&quot;app&quot;&gt;
&lt;!-- windows phone 点击无高光 --&gt;
&lt;meta name=&quot;msapplication-tap-highlight&quot; content=&quot;no&quot;&gt;
</code></pre>
<h1 id="网页相关">网页相关</h1>
<h2 id="申明编码">申明编码</h2>
<pre><code class="language-html">&lt;meta charset='utf-8' /&gt;
</code></pre>
<h2 id="优先使用-ie-最新版本和-chrome">优先使用 IE 最新版本和 Chrome</h2>
<pre><code class="language-html">&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot; /&gt;
&lt;!-- 关于X-UA-Compatible --&gt;
&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=6&quot; &gt;&lt;!-- 使用IE6 --&gt;
&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=7&quot; &gt;&lt;!-- 使用IE7 --&gt;
&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=8&quot; &gt;&lt;!-- 使用IE8 --&gt;
</code></pre>
<h2 id="浏览器内核控制">浏览器内核控制</h2>
<p>国内浏览器很多都是双内核（Webkit和Trident），Webkit内核高速浏览，IE 内核兼容网页和旧版网站。而添加 <code>meta</code> 标签的网站可以控制浏览器选择何种内核渲染。<a href="http://se.360.cn/v6/help/meta.html">浏览器内核控制标签meta说明</a></p>
<pre><code class="language-html">&lt;meta name=&quot;renderer&quot; content=&quot;webkit|ie-comp|ie-stand&quot;&gt;
</code></pre>
<p>国内双核浏览器默认内核模式如下：</p>
<ol>
<li>搜狗高速浏览器、QQ 浏览器：IE 内核（兼容模式）；</li>
<li>360 极速浏览器、遨游浏览器：Webkit 内核（极速模式）。</li>
</ol>
<h2 id="禁止浏览器从本地计算机的缓存中访问页面内容">禁止浏览器从本地计算机的缓存中访问页面内容</h2>
<p>这样设定，访问者将无法脱机浏览。</p>
<pre><code class="language-html">&lt;meta http-equiv=&quot;Pragma&quot; content=&quot;no-cache&quot;&gt;
</code></pre>
<h2 id="windows-8">Windows 8</h2>
<pre><code class="language-html">&lt;meta name=&quot;msapplication-TileColor&quot; content=&quot;#000&quot;/&gt; &lt;!-- Windows 8 磁贴颜色 --&gt;
&lt;meta name=&quot;msapplication-TileImage&quot; content=&quot;icon.png&quot;/&gt; &lt;!-- Windows 8 磁贴图标 --&gt;
</code></pre>
<h2 id="站点适配">站点适配</h2>
<p>主要用于 PC-手机页的对应关系。</p>
<pre><code class="language-html">&lt;meta name=&quot;mobile-agent&quot;content=&quot;format=[wml|xhtml|html5]; url=url&quot;/&gt;
&lt;!--
[wml|xhtml|html5]根据手机页的协议语言，选择其中一种；
url=&quot;url&quot; 后者代表当前PC页所对应的手机页URL，两者必须是一一对应关系。
 --&gt;
</code></pre>
<h2 id="转码申明">转码申明</h2>
<p>用百度打开网页可能会对其进行转码（比如贴广告），避免转码可添加如下 <code>meta</code></p>
<pre><code class="language-html">&lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-siteapp&quot;/&gt;
</code></pre>
<h1 id="其他参考文档">其他参考文档</h1>
<ul>
<li><a href="http://code.lancepollard.com/complete-list-of-html-meta-tags/">COMPLETE LIST OF HTML META TAGS</a></li>
<li><a href="http://www.w3.org/TR/html5/document-metadata.html#the-meta-element">W3C META TAGS</a></li>
<li><a href="http://www.html-5.com/metatags/">METATAGES in HTML5</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta">MDN META TAGS</a></li>
</ul>
]]></content>
    </entry>
</feed>