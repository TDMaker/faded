<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://tdmaker.github.io/faded/</id>
    <title>Typhoeus</title>
    <updated>2020-04-10T06:57:10.607Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://tdmaker.github.io/faded/"/>
    <link rel="self" href="https://tdmaker.github.io/faded/atom.xml"/>
    <logo>https://tdmaker.github.io/faded/images/avatar.png</logo>
    <icon>https://tdmaker.github.io/faded/favicon.ico</icon>
    <rights>All rights reserved 2020, Typhoeus</rights>
    <entry>
        <title type="html"><![CDATA[Vim——常用命令大全]]></title>
        <id>https://tdmaker.github.io/faded/post/vim-common-commands/</id>
        <link href="https://tdmaker.github.io/faded/post/vim-common-commands/">
        </link>
        <updated>2020-04-09T08:15:20.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p><a href="https://blog.csdn.net/chenyoca/article/details/38844681">VIM快捷键大全</a></p>
</blockquote>
<h1 id="目录">目录</h1>
<h1 id="1-关于vim">1 关于VIM</h1>
<h2 id="11-vim-的几种模式">1.1 VIM 的几种模式</h2>
<ol>
<li>正常模式：可以使用快捷键命令，或按:输入命令行。</li>
<li>插入模式：可以输入文本，在正常模式下，按 <code>i</code>、<code>a</code>、<code>o</code> 等都可以进入插入模式。</li>
<li>可视模式：正常模式下按v可以进入可视模式， 在可视模式下，移动光标可以选择文本。按 V 进入可视行模式， 总是整行整行的选中。<code>ctrl+v</code> 进入可视块模式。</li>
<li>替换模式：正常模式下，按 <code>R</code> 进入。</li>
</ol>
<h1 id="2-启动vim">2 启动Vim</h1>
<ol>
<li><code>vim -c cmd file</code>: 在打开文件前，先执行指定的命令；</li>
<li><code>vim -r file</code>: 恢复上次异常退出的文件；</li>
<li><code>vim -R file</code>: 以只读的方式打开文件，但可以强制保存；</li>
<li><code>vim -M file</code>: 以只读的方式打开文件，不可以强制保存；</li>
<li><code>vim -y num file</code>: 将编辑窗口的大小设为 <code>num</code> 行；</li>
<li><code>vim + file</code>: 从文件的末尾开始；</li>
<li><code>vim +num file</code>: 从第<code>num</code>行开始；</li>
<li><code>vim +/string file</code>: 打开 <code>file</code>，并将光标停留在第一个找到的 <code>string</code> 上。</li>
<li><code>vim --remote file</code>: 用已有的 VIM 进程打开指定的文件。 如果你不想启用多个 VIM 会话，这个很有用。但要注意， 如果你用 VIM，会寻找名叫 VIM 的服务器；如果你已经有一个 <code>gvim</code> 在运行了， 你可以用 <code>gvim --remote file</code> 在已有的 <code>gvim p</code> 中打开文件。</li>
</ol>
<h1 id="3-文档操作">3 文档操作</h1>
<ol>
<li><code>:e file</code> --关闭当前编辑的文件，并开启新的文件。 如果对当前文件的修改未保存，<code>vi</code> 会警告。</li>
<li><code>:e! file</code> --放弃对当前文件的修改，编辑新的文件。</li>
<li><code>:e+file</code> -- 开始新的文件，并从文件尾开始编辑。</li>
<li><code>:e+n file</code> -- 开始新的文件，并从第 <code>n</code> 行开始编辑。</li>
<li><code>:enew</code> --编译一个未命名的新文档。(<code>CTRL-W n</code>)。</li>
<li><code>:e</code> -- 重新加载当前文档。</li>
<li><code>:e!</code> -- 重新加载当前文档，并丢弃已做的改动。</li>
<li><code>:e#或ctrl+^</code> -- 回到刚才编辑的文件，很实用。</li>
<li><code>:f或ctrl+g</code> -- 显示文档名，是否修改，和光标位置。</li>
<li><code>:f filename</code> -- 改变编辑的文件名，这时再保存相当于另存为。</li>
<li><code>gf</code> -- 打开以光标所在字符串为文件名的文件。</li>
<li><code>:w</code> -- 保存修改。</li>
<li><code>:n1,n2w filename</code> -- 选择性保存从某 <code>n1</code> 行到另 <code>n2</code> 行的内容。</li>
<li><code>:wq</code> -- 保存并退出。</li>
<li><code>ZZ</code> -- 保存并退出。</li>
<li><code>:x</code> -- 保存并退出。</li>
<li><code>:q[uit]</code> --退出当前窗口。(<code>CTRL-W q</code> 或 <code>CTRL-W CTRL-Q</code>)</li>
<li><code>:saveas newfilename</code> -- 另存为</li>
<li><code>:browse e</code> -- 会打开一个文件浏览器让你选择要编辑的文件。 如果是终端中，则会打开 <code>netrw</code> 的文件浏览窗口； 如果是 <code>gvim</code>，则会打开一个图形界面的浏览窗口。 实际上 <code>:browse</code> 后可以跟任何编辑文档的命令，如 <code>sp</code> 等。 用 <code>browse</code> 打开的起始目录可以由 <code>browsedir</code> 来设置：
<ul>
<li><code>:set browsedir=last</code> -- 用上次访问过的目录（默认）；</li>
<li><code>:set browsedir=buffer</code> -- 用当前文件所在目录；</li>
<li><code>:set browsedir=current</code> -- 用当前工作目录；</li>
</ul>
</li>
<li><code>:Sex</code> -- 水平分割一个窗口，浏览文件系统；</li>
<li><code>:Vex</code> -- 垂直分割一个窗口，浏览文件系统；</li>
</ol>
<h1 id="4-光标的移动">4 光标的移动</h1>
<h2 id="41-基本移动">4.1 基本移动</h2>
<p>以下移动都是在 <code>normal</code> 模式下。</p>
<ol>
<li><code>h</code> 或退格: 左移一个字符；</li>
<li><code>l</code> 或空格: 右移一个字符；</li>
<li><code>j</code>: 下移一行；</li>
<li><code>k</code>: 上移一行；</li>
<li><code>gj</code>: 移动到一段内的下一行；</li>
<li><code>gk</code>: 移动到一段内的上一行；</li>
<li><code>+</code> 或 <code>Enter</code>: 把光标移至下一行第一个非空白字符。</li>
<li><code>-</code>: 把光标移至上一行第一个非空白字符。</li>
<li><code>w</code>: 前移一个单词，光标停在下一个单词开头；</li>
<li><code>W</code>: 移动下一个单词开头，但忽略一些标点；</li>
<li><code>e</code>: 前移一个单词，光标停在下一个单词末尾；</li>
<li><code>E</code>: 移动到下一个单词末尾，如果词尾有标点，则移动到标点；</li>
<li><code>b</code>: 后移一个单词，光标停在上一个单词开头；</li>
<li><code>B</code>: 移动到上一个单词开头，忽略一些标点；</li>
<li><code>ge</code>: 后移一个单词，光标停在上一个单词末尾；</li>
<li><code>gE</code>: 同 <code>ge</code> ，不过‘单词’包含单词相邻的标点。</li>
<li><code>(</code>: 前移 1 句。</li>
<li><code>)</code>: 后移 1 句。</li>
<li><code>{</code>: 前移 1 段。</li>
<li><code>}</code>: 后移 1 段。</li>
<li><code>fc</code>: 把光标移到同一行的下一个 <code>c</code> 字符处</li>
<li><code>Fc</code>: 把光标移到同一行的上一个 <code>c</code> 字符处</li>
<li><code>tc</code>: 把光标移到同一行的下一个 <code>c</code> 字符前</li>
<li><code>Tc</code>: 把光标移到同一行的上一个 <code>c</code> 字符后</li>
<li><code>;</code>: 配合 <code>f &amp; t</code> 使用，重复一次</li>
<li><code>,</code>: 配合 <code>f &amp; t</code> 使用，反向重复一次</li>
</ol>
<p>上面的操作都可以配合 <code>n</code> 使用，比如在正常模式(下面会讲到)下输入 <code>3h</code>， 则光标向左移动 3 个字符。<br>
27. <code>0</code>: 移动到行首。<br>
28. <code>g0</code>: 移到光标所在屏幕行行首。<br>
29. <code>^</code>: 移动到本行第一个非空白字符。<br>
30. <code>g^</code>: 同 <code>^</code> ，但是移动到当前屏幕行第一个非空字符处。<br>
31. <code>$</code>: 移动到行尾。<br>
32. <code>g$</code>: 移动光标所在屏幕行行尾。<br>
33. <code>n|</code>: 把光标移到递 <code>n</code> 列上。<br>
34. <code>nG</code>: 到文件第 <code>n</code> 行。<br>
35. <code>:n</code> 移动到第 <code>n</code> 行。<br>
36. <code>:$</code> 移动到最后一行。<br>
37. <code>H</code>: 把光标移到屏幕最顶端一行。<br>
38. <code>M</code>: 把光标移到屏幕中间一行。<br>
39. <code>L</code>: 把光标移到屏幕最底端一行。<br>
40. <code>gg</code>: 到文件头部。<br>
41. <code>G</code>: 到文件尾部。</p>
<h2 id="42-翻屏">4.2 翻屏</h2>
<ol>
<li><code>ctrl+f</code>: 下翻一屏。</li>
<li><code>ctrl+b</code>: 上翻一屏。</li>
<li><code>ctrl+d</code>: 下翻半屏。</li>
<li><code>ctrl+u</code>: 上翻半屏。</li>
<li><code>ctrl+e</code>: 向下滚动一行。</li>
<li><code>ctrl+y</code>: 向上滚动一行。</li>
<li><code>n%</code>: 到文件 <code>n%</code> 的位置。</li>
<li><code>zz</code>: 将当前行移动到屏幕中央。</li>
<li><code>zt</code>: 将当前行移动到屏幕顶端。</li>
<li><code>zb</code>: 将当前行移动到屏幕底端。</li>
</ol>
<h2 id="43-标记">4.3 标记</h2>
<p>使用标记可以快速移动。到达标记后，可以用 <code>Ctrl+o</code> 返回原来的位置。<code>Ctrl+o</code> 和 <code>Ctrl+i</code> 很像浏览器上的 后退 和 前进 。</p>
<ol>
<li><code>m{a-z}</code>: 标记光标所在位置，局部标记，只用于当前文件。</li>
<li><code>m{A-Z}</code>: 标记光标所在位置，全局标记。标记之后，退出 VIM， 重新启动，标记仍然有效。</li>
<li><code>`{a-z}</code>: 移动到标记位置。</li>
<li><code>'{a-z}</code>: 移动到标记行的行首。</li>
<li><code>`{0-9}</code>：回到上 <code>[2-10]</code> 次关闭 VIM 时最后离开的位置。</li>
<li><code>``</code>: 移动到上次编辑的位置。<code>''</code> 也可以，不过 <code>``</code> 精确到列，而 <code>''</code> 精确到行 。如果想跳转到更老的位置，可以按 <code>C-o</code>，跳转到更新的位置用 <code>C-i</code>。</li>
<li><code>`&quot;</code>: 移动到上次离开的地方。</li>
<li><code>`.:</code> 移动到最后改动的地方。</li>
<li><code>:marks</code> 显示所有标记。</li>
<li><code>:delmarks a b</code> -- 删除标记 <code>a</code> 和 <code>b</code>。</li>
<li><code>:delmarks a-c</code> -- 删除标记 <code>a</code>、<code>b</code> 和 <code>c</code>。</li>
<li><code>:delmarks a c-f</code> -- 删除标记 <code>a</code>、<code>c</code>、<code>d</code>、<code>e</code>、<code>f</code>。</li>
<li><code>:delmarks!</code> -- 删除当前缓冲区的所有标记。</li>
<li><code>:help mark-motions</code> 查看更多关于 <code>mark</code> 的知识。</li>
</ol>
<h1 id="5-插入文本">5 插入文本</h1>
<h2 id="51-基本插入">5.1 基本插入</h2>
<ol>
<li><code>i</code>: 在光标前插入；一个小技巧：按 <code>8</code>，再按 <code>i</code>，进入插入模式，输入 <code>=</code>， 按 <code>esc</code> 进入命令模式，就会出现 <code>8</code> 个 <code>=</code>。 这在插入分割线时非常有用，如 <code>30i+</code> 就插入了 <code>36</code> 个 <code>+</code> 组成的分割线。</li>
<li><code>I</code>: 在当前行第一个非空字符前插入；</li>
<li><code>gI</code>: 在当前行第一列插入；</li>
<li><code>a</code>: 在光标后插入；</li>
<li><code>A</code>: 在当前行最后插入；</li>
<li><code>o</code>: 在下面新建一行插入；</li>
<li><code>O</code>: 在上面新建一行插入；</li>
<li><code>:r filename</code> 在当前位置插入另一个文件的内容。</li>
<li><code>:[n]r filename</code> 在第 <code>n</code> 行插入另一个文件的内容。</li>
<li><code>:r !date</code> 在光标处插入当前日期与时间。同理，<code>:r !command</code> 可以将其它 shell 命令的输出插入当前文档。</li>
</ol>
<h2 id="52-改写插入">5.2 改写插入</h2>
<ol>
<li><code>c[n]w</code>: 改写光标后 <code>1(n)</code> 个词。</li>
<li><code>c[n]l</code>: 改写光标后 <code>n</code> 个字母。</li>
<li><code>c[n]h</code>: 改写光标前 <code>n</code> 个字母。</li>
<li><code>[n]cc</code>: 修改当前 <code>[n]</code> 行。</li>
<li><code>[n]s</code>: 以输入的文本替代光标之后 <code>1(n)</code> 个字符，相当于 <code>c[n]l</code>。</li>
<li><code>[n]S</code>: 删除指定数目的行，并以所输入文本代替之。</li>
</ol>
<p>注意，类似 <code>cnw</code>，<code>dnw</code>，<code>ynw</code> 的形式同样可以写为 <code>ncw</code>，<code>ndw</code>，<code>nyw</code>。</p>
<h1 id="6-剪切复制和寄存器">6 剪切复制和寄存器</h1>
<h2 id="61-剪切和复制-粘贴">6.1 剪切和复制、粘贴</h2>
<ol>
<li><code>[n]x</code>: 剪切光标右边 <code>n</code> 个字符，相当于 <code>d[n]l</code>。</li>
<li><code>[n]X</code>: 剪切光标左边 <code>n</code> 个字符，相当于 <code>d[n]h</code>。</li>
<li><code>y</code>: 复制在可视模式下选中的文本。</li>
<li><code>yy or Y</code>: 复制整行文本。</li>
<li><code>y[n]w</code>: 复制一<code>(n)</code>个词。</li>
<li><code>y[n]l</code>: 复制光标右边<code>1(n)</code>个字符。</li>
<li><code>y[n]h</code>: 复制光标左边<code>1(n)</code>个字符。</li>
<li><code>y$</code>: 从光标当前位置复制到行尾。</li>
<li><code>y0</code>: 从光标当前位置复制到行首。</li>
<li><code>:m,ny</code> 复制 <code>m</code> 行到 <code>n</code> 行的内容。</li>
<li><code>y1G</code> 或 <code>ygg</code>: 复制光标以上的所有行。</li>
<li><code>yG</code>: 复制光标以下的所有行。</li>
<li><code>yaw</code> 和 <code>yas</code>：复制一个词和复制一个句子，即使光标不在词首和句首也没关系。</li>
<li><code>d</code>: 删除（剪切）在可视模式下选中的文本。</li>
<li><code>d$ or D</code>: 删除（剪切）当前位置到行尾的内容。</li>
<li><code>d[n]w</code>: 删除（剪切）<code>1(n)</code> 个单词。</li>
<li><code>d[n]l</code>: 删除（剪切）光标右边 <code>1(n)</code> 个字符。</li>
<li><code>d[n]h</code>: 删除（剪切）光标左边 <code>1(n)</code> 个字符。</li>
<li><code>d0</code>: 删除（剪切）当前位置到行首的内容。</li>
<li><code>[n] dd</code>: 删除（剪切）<code>1(n)</code> 行。</li>
<li><code>:m,nd</code> 剪切 <code>m</code> 行到 <code>n</code> 行的内容。</li>
<li><code>d1G</code> 或 <code>dgg</code>: 剪切光标以上的所有行。</li>
<li><code>dG</code>: 剪切光标以下的所有行。</li>
<li><code>daw</code> 和 <code>das</code>：剪切一个词和剪切一个句子，即使光标不在词首和句首也没关系。</li>
<li><code>d/f</code>：这是一个比较高级的组合命令，它将删除当前位置 到下一个 <code>f</code> 之间的内容。</li>
<li><code>p</code>: 在光标之后粘贴。</li>
<li><code>P</code>: 在光标之前粘贴。</li>
</ol>
<h2 id="62-文本对象">6.2 文本对象</h2>
<ol>
<li><code>aw</code>：一个词</li>
<li><code>as</code>：一句。</li>
<li><code>ap</code>：一段。</li>
<li><code>ab</code>：一块（包含在圆括号中的）。</li>
</ol>
<p><code>y</code>，<code>d</code>，<code>c</code>，<code>v</code> 都可以跟文本对象。</p>
<h2 id="63-寄存器">6.3 寄存器</h2>
<ol>
<li><code>a-z</code>：都可以用作寄存器名。<code>&quot;ayy</code> 把当前行的内容放入 <code>a</code> 寄存器。</li>
<li><code>A-Z</code>：用大写字母索引寄存器，可以在寄存器中追加内容。 如 <code>&quot;Ayy</code> 把当前行的内容追加到 <code>a</code> 寄存器中。</li>
<li><code>:reg</code> 显示所有寄存器的内容。</li>
<li><code>&quot;&quot;</code>：不加寄存器索引时，默认使用的寄存器。</li>
<li><code>&quot;*</code>：当前选择缓冲区，<code>&quot;*yy</code> 把当前行的内容放入当前选择缓冲区。</li>
<li><code>&quot;+</code>：系统剪贴板。<code>&quot;+yy</code> 把当前行的内容放入系统剪贴板。</li>
</ol>
<h1 id="7-查找与替换">7 查找与替换</h1>
<h2 id="71-查找">7.1 查找</h2>
<ol>
<li><code>/something</code>: 在后面的文本中查找 <code>something</code>。</li>
<li><code>?something</code>: 在前面的文本中查找 <code>something</code>。</li>
<li><code>/pattern/+number</code>: 将光标停在包含 <code>pattern</code> 的行后面第 <code>number</code> 行上。</li>
<li><code>/pattern/-number</code>: 将光标停在包含 <code>pattern</code> 的行前面第 <code>number</code> 行上。</li>
<li><code>n</code>: 向后查找下一个。</li>
<li><code>N</code>: 向前查找下一个。</li>
</ol>
<p>可以用 <code>grep</code> 或 <code>vimgrep</code> 查找一个模式都在哪些地方出现过，其中: <code>grep</code> 是调用外部的 <code>grep</code> 程序，而 <code>:vimgrep</code> 是 VIM 自己的查找算法。用法为：<code>:vim[grep]/pattern/[g] [j] files</code></p>
<p><code>g</code> 的含义是如果一个模式在一行中多次出现，则这一行也在结果中多次出现。<code>j</code> 的含义是 <code>grep</code> 结束后，结果停在第 <code>j</code> 项，默认是停在第一项。<code>vimgrep</code> 前面可以加数字限定搜索结果的上限，如<br>
<code>:1vim/pattern/ %</code> 只查找那个模式在本文件中的第一个出现。</p>
<p>其实 <code>vimgrep</code> 在读纯文本电子书时特别有用，可以生成导航的目录。比如电子书中每一节的标题形式为：<code>n. xxxx</code>。你就可以这样：<code>:vim/^d{1,}./ %</code> 然后用 <code>:cw</code> 或 <code>:copen</code> 查看结果，可以用 <code>C-w H</code> 把 <code>quickfix</code> 窗口移到左侧，就更像个目录了。</p>
<h2 id="72-替换">7.2 替换</h2>
<ol>
<li><code>:s/old/new</code> - 用 <code>new</code> 替换当前行第一个 <code>old</code>。</li>
<li><code>:s/old/new/g</code> - 用 <code>new</code> 替换当前行所有的 <code>old</code>。</li>
<li><code>:n1,n2s/old/new/g</code> - 用 <code>new</code> 替换文件 <code>n1</code> 行到 <code>n2</code> 行所有的 <code>old</code>。</li>
<li><code>:%s/old/new/g</code> - 用 <code>new</code> 替换文件中所有的 <code>old</code>。</li>
<li><code>:%s/^/xxx/g</code> - 在每一行的行首插入 <code>xxx</code>，<code>^</code> 表示行首。</li>
<li><code>:%s/$/xxx/g</code> - 在每一行的行尾插入 <code>xxx</code>，<code>$</code> 表示行尾。</li>
<li>所有替换命令末尾加上 <code>c</code>，每个替换都将需要用户确认。 如：<code>%s/old/new/gc</code>，加上 <code>i</code> 则忽略大小写(ignore)。</li>
</ol>
<p>还有一种比替换更灵活的方式，它是匹配到某个模式后执行某种命令，<br>
语法为 <code>:[range]g/pattern/command</code><br>
例如 <code>:%g/^ xyz/normal dd</code>。<br>
表示对于以一个空格和 <code>xyz</code> 开头的行执行 <code>normal</code> 模式下的 <code>dd</code> 命令。<br>
关于 <code>range</code> 的规定为：</p>
<p>如果不指定 <code>range</code>，则表示当前行。</p>
<ul>
<li><code>m,n</code>: 从 <code>m</code> 行到 <code>n</code> 行。</li>
<li><code>0</code>: 最开始一行（可能是这样）。</li>
<li><code>$</code>: 最后一行</li>
<li><code>.</code>: 当前行</li>
<li><code>%</code>: 所有行</li>
</ul>
<h2 id="73-正则表达式">7.3 正则表达式</h2>
<p>高级的查找替换就要用到正则表达式。</p>
<ol>
<li><code>\d</code>: 表示十进制数（我猜的）</li>
<li><code>\s</code>: 表示空格</li>
<li><code>\S</code>: 非空字符</li>
<li><code>\a</code>: 英文字母</li>
<li><code>\|</code>: 表示 或</li>
<li><code>\.</code>: 表示.</li>
<li><code>{m,n}</code>: 表示 <code>m</code> 到 <code>n</code> 个字符。这要和 <code>\s</code> 与 <code>\a</code> 等连用，如 <code>\a\{m,n}</code> 表示 <code>m</code> 到 <code>n</code> 个英文字母。</li>
<li><code>{m,}</code>: 表示 <code>m</code> 到无限多个字符。</li>
<li><code>**</code>: 当前目录下的所有子目录。</li>
<li><code>:help pattern</code> 得到更多帮助。</li>
</ol>
<h1 id="8-排版">8 排版</h1>
<h2 id="81-基本排版">8.1 基本排版</h2>
<ol>
<li><code>&lt;&lt;</code> 向左缩进一个 shiftwidth</li>
<li><code>&gt;&gt;</code> 向右缩进一个 shiftwidth</li>
<li><code>:ce(nter)</code> 本行文字居中</li>
<li><code>:le(ft)</code> 本行文字靠左</li>
<li><code>:ri(ght)</code> 本行文字靠右</li>
<li><code>gq</code> 对选中的文字重排，即对过长的文字进行断行</li>
<li><code>gqq</code> 重排当前行</li>
<li><code>gqnq</code> 重排 <code>n</code> 行</li>
<li><code>gqap</code> 重排当前段</li>
<li><code>gqnap</code> 重排 <code>n</code> 段</li>
<li><code>gqnj</code> 重排当前行和下面 <code>n</code> 行</li>
<li><code>gqQ</code> 重排当前段对文章末尾</li>
<li><code>J</code> 拼接当前行和下一行</li>
<li><code>gJ</code> 同 <code>J</code>，不过合并后不留空格。</li>
</ol>
<h2 id="82-拼写检查">8.2 拼写检查</h2>
<ol>
<li><code>:set spell</code>－开启拼写检查功能</li>
<li><code>:set nospell</code>－关闭拼写检查功能</li>
<li><code>]s</code>－移到下一个拼写错误的单词</li>
<li><code>[s</code>－作用与上一命令类似，但它是从相反方向进行搜索</li>
<li><code>z=</code>－显示一个有关拼写错误单词的列表，可从中选择</li>
<li><code>zg</code>－告诉拼写检查器该单词是拼写正确的</li>
<li><code>zw</code>－与上一命令相反，告诉拼写检查器该单词是拼写错误的</li>
</ol>
<h2 id="83-统计字数">8.3 统计字数</h2>
<p><code>g ^g</code> 可以统计文档字符数，行数。 将光标放在最后一个字符上，用字符数减去行数可以粗略统计中文文档的字数。 以上对 <code>Mac</code> 或 <code>Unix</code> 的文件格式适用。 如果是 <code>Windows</code> 文件格式（即换行符有两个字节），字数的统计方法为：<code>字符数 - 行数 * 2</code>。</p>
<h1 id="9-编辑多个文件">9 编辑多个文件</h1>
<h2 id="91-一次编辑多个文件">9.1 一次编辑多个文件</h2>
<p>我们可以一次打开多个文件，如</p>
<pre><code class="language-bash">vi a.txt b.txt c.txt
</code></pre>
<ol>
<li>使用 <code>:next(:n)</code> 编辑下一个文件。</li>
<li><code>:2n</code> 编辑下 2 个文件。</li>
<li>使用 <code>:previous</code> 或 <code>:N</code> 编辑上一个文件。</li>
<li>使用 <code>:wnext</code>，保存当前文件，并编辑下一个文件。</li>
<li>使用 <code>:wprevious</code>，保存当前文件，并编辑上一个文件。</li>
<li>使用 <code>:args</code> 显示文件列表。</li>
<li><code>:n filenames</code> 或 <code>:args filenames</code> 指定新的文件列表。</li>
<li><code>vi -o filenames</code> 在水平分割的多个窗口中编辑多个文件。</li>
<li><code>vi -O filenames</code> 在垂直分割的多个窗口中编辑多个文件。</li>
</ol>
<h2 id="92-多标签编辑">9.2 多标签编辑</h2>
<ol>
<li><code>vim -p files</code>: 打开多个文件，每个文件占用一个标签页。</li>
<li><code>:tabe, tabnew</code> -- 如果加文件名，就在新的标签中打开这个文件， 否则打开一个空缓冲区。</li>
<li><code>^w gf</code> -- 在新的标签页里打开光标下路径指定的文件。</li>
<li><code>:tabn</code> -- 切换到下一个标签。<code>Control + PageDown</code>，也可以。</li>
<li><code>:tabp</code> -- 切换到上一个标签。<code>Control + PageUp</code>，也可以。</li>
<li><code>[n] gt</code> -- 切换到下一个标签。如果前面加了 <code>n</code> ， 就切换到第 <code>n</code> 个标签。第一个标签的序号就是 1。</li>
<li><code>:tab split</code> -- 将当前缓冲区的内容在新页签中打开。</li>
<li><code>:tabc[lose]</code> -- 关闭当前的标签页。</li>
<li><code>:tabo[nly]</code> -- 关闭其它的标签页。</li>
<li><code>:tabs</code> -- 列出所有的标签页和它们包含的窗口。</li>
<li><code>:tabm[ove] [N]</code> -- 移动标签页，移动到第 <code>N</code> 个标签页之后。 如 <code>tabm 0</code> 当前标签页，就会变成第一个标签页。</li>
</ol>
<h2 id="93-缓冲区">9.3 缓冲区</h2>
<ol>
<li><code>:buffers</code> 或 <code>:ls</code> 或 <code>:files</code> 显示缓冲区列表。</li>
<li><code>ctrl+^</code>：在最近两个缓冲区间切换。</li>
<li><code>:bn</code> -- 下一个缓冲区。</li>
<li><code>:bp</code> -- 上一个缓冲区。</li>
<li><code>:bl</code> -- 最后一个缓冲区。</li>
<li><code>:b[n]</code> 或 <code>:[n]b</code> -- 切换到第 <code>n</code> 个缓冲区。</li>
<li><code>:nbw(ipeout)</code> -- 彻底删除第 <code>n</code> 个缓冲区。</li>
<li><code>:nbd(elete)</code> -- 删除第 <code>n</code> 个缓冲区，并未真正删除，还在 unlisted 列表中。</li>
<li><code>:ba[ll]</code> -- 把所有的缓冲区在当前页中打开，每个缓冲区占一个窗口。</li>
</ol>
<h1 id="10-分屏编辑">10 分屏编辑</h1>
<ol>
<li><code>vim -o file1 file2</code>: 水平分割窗口，同时打开 <code>file1</code> 和 <code>file2</code></li>
<li><code>vim -O file1 file2</code>: 垂直分割窗口，同时打开 <code>file1</code> 和 <code>file2</code></li>
</ol>
<h2 id="101-水平分割">10.1 水平分割</h2>
<ol>
<li><code>:split(:sp)</code> -- 把当前窗水平分割成两个窗口。(<code>CTRL-W s</code> 或 <code>CTRL-W CTRL-S</code>) 注意如果在终端下，<code>CTRL-S</code> 可能会冻结终端，请按 <code>CTRL-Q</code> 继续。</li>
<li><code>:split filename</code> -- 水平分割窗口，并在新窗口中显示另一个文件。</li>
<li><code>:nsplit(:nsp)</code> -- 水平分割出一个 <code>n</code> 行高的窗口</li>
<li><code>:[N]new</code> -- 水平分割出一个 <code>N</code> 行高的窗口，并编辑一个新文件。 (<code>CTRL-W n</code> 或 <code>CTRL-W CTRL-N</code>)</li>
<li><code>ctrl+w f</code> --水平分割出一个窗口，并在新窗口打开名称为光标所在词的文件 。</li>
<li><code>C-w C-^</code> -- 水平分割一个窗口，打开刚才编辑的文件。</li>
</ol>
<h2 id="102-垂直分割">10.2 垂直分割</h2>
<ol>
<li><code>:vsplit(:vsp)</code> -- 把当前窗口分割成水平分布的两个窗口。 (<code>CTRL-W v</code> 或 <code>CTRL CTRL-V</code>)</li>
<li><code>:[N]vne[w]</code> -- 垂直分割出一个新窗口。</li>
<li><code>:vertical</code> 水平分割的命令： 相应的垂直分割。</li>
</ol>
<h2 id="103-关闭子窗口">10.3 关闭子窗口</h2>
<ol>
<li><code>:qall</code> -- 关闭所有窗口，退出 VIM。</li>
<li><code>:wall</code> -- 保存所有修改过的窗口。</li>
<li><code>:only</code> -- 只保留当前窗口，关闭其它窗口。(<code>CTRL-W o</code>)</li>
<li><code>:close</code> -- 关闭当前窗口，<code>CTRL-W c</code> 能实现同样的功能。 (象 <code>:q :x</code> 同样工作 )</li>
</ol>
<h2 id="104-调整窗口大小">10.4 调整窗口大小</h2>
<ol>
<li><code>ctrl+w +</code> --当前窗口增高一行。也可以用 <code>n</code> 增高 <code>n</code> 行。</li>
<li><code>ctrl+w -</code> --当前窗口减小一行。也可以用 <code>n</code> 减小 <code>n</code> 行。</li>
<li><code>ctrl+w _</code> --当前窗口扩展到尽可能的大。也可以用 <code>n</code> 设定行数。</li>
<li><code>:resize n</code> -- 当前窗口 <code>n</code> 行高。</li>
<li><code>ctrl+w =</code> -- 所有窗口同样高度。</li>
<li><code>n ctrl+w _</code> -- 当前窗口的高度设定为 <code>n</code> 行。</li>
<li><code>ctrl+w &lt;</code> --当前窗口减少一列。也可以用 <code>n</code> 减少 <code>n</code> 列。</li>
<li><code>ctrl+w &gt;</code> --当前窗口增宽一列。也可以用 <code>n</code> 增宽 <code>n</code> 列。</li>
<li><code>ctrl+w |</code> --当前窗口尽可能的宽。也可以用 <code>n</code> 设定列数。</li>
</ol>
<h2 id="105-切换和移动窗口">10.5 切换和移动窗口</h2>
<p>如果支持鼠标，切换和调整子窗口的大小就简单了。</p>
<ol>
<li><code>ctrl+w ctrl+w</code>: 切换到下一个窗口。或者是 <code>ctrl+w w</code>。</li>
<li><code>ctrl+w p</code>: 切换到前一个窗口。</li>
<li><code>ctrl+w h(l,j,k)</code>:切换到左（右，下，上）的窗口。</li>
<li><code>ctrl+w t(b)</code>:切换到最上（下）面的窗口。</li>
<li><code>ctrl+w H(L,K,J)</code>: 将当前窗口移动到最左（右、上、下）面。</li>
<li><code>ctrl+w r</code>：旋转窗口的位置。</li>
<li><code>ctrl+w T</code>: 将当前的窗口移动到新的标签页上。</li>
</ol>
<h1 id="11-快速编辑">11 快速编辑</h1>
<h2 id="111-改变大小写">11.1 改变大小写</h2>
<ol>
<li><code>~</code>: 反转光标所在字符的大小写。</li>
<li>可视模式下的 <code>U</code> 或 <code>u</code>：把选中的文本变为大写或小写。</li>
<li><code>gu(U)</code> 接范围（如 <code>$</code>，或 <code>G</code>），可以把从光标当前位置到指定位置之间字母全部转换成小写或大写。如 <code>ggguG</code>，就是把开头到最后一行之间的字母全部变为小 写。再如 <code>gu5j</code>，把当前行和下面四行全部变成小写。</li>
</ol>
<h2 id="112-替换normal模式">11.2 替换（normal模式）</h2>
<ol>
<li><code>r</code>: 替换光标处的字符，同样支持汉字。</li>
<li><code>R</code>: 进入替换模式，按 <code>esc</code> 回到正常模式。</li>
</ol>
<h2 id="113-撤消与重做normal模式">11.3 撤消与重做（normal模式）</h2>
<ol>
<li><code>[n] u</code>: 取消一 (n) 个改动。</li>
<li><code>:undo 5</code> -- 撤销 5 个改变。</li>
<li><code>:undolist</code> -- 你的撤销历史。</li>
<li><code>ctrl + r</code>: 重做最后的改动。</li>
<li><code>U</code>: 取消当前行中所有的改动。</li>
<li><code>:earlier 4m</code> -- 回到 4 分钟前</li>
<li><code>:later 55s</code> -- 前进 55 秒</li>
</ol>
<h2 id="114-宏">11.4 宏</h2>
<ol>
<li><code>.</code> --重复上一个编辑动作</li>
<li><code>qa</code>：开始录制宏 <code>a</code>（键盘操作记录）</li>
<li><code>q</code>：停止录制</li>
<li><code>@a</code>：播放宏 <code>a</code></li>
</ol>
<h1 id="12-编辑特殊文件">12 编辑特殊文件</h1>
<h2 id="121-文件加解密">12.1 文件加解密</h2>
<ol>
<li><code>vim -x file</code>: 开始编辑一个加密的文件。</li>
<li><code>:X</code> -- 为当前文件设置密码。</li>
<li><code>:set key=</code> -- 去除文件的密码。</li>
</ol>
<h2 id="122-文件的编码">12.2 文件的编码</h2>
<ol>
<li><code>:e ++enc=utf8 filename</code>, 让 VIM 用 <code>utf-8</code> 的编码打开这个文件。</li>
<li><code>:w ++enc=gbk</code>，不管当前文件什么编码，把它转存成 <code>gbk</code> 编码。</li>
<li><code>:set fenc</code> 或 <code>:set fileencoding</code>，查看当前文件的编码。</li>
<li>在 <code>vimrc</code> 中添加 <code>set fileencoding=ucs-bom,utf-8,cp936</code>，VIM 会根据要打开的文件选择合适的编码。 注意：编码之间不要留空格。<code>cp936</code> 对应于 <code>gbk</code> 编码。<code>ucs-bom</code> 对应于 <code>Windows</code> 下的文件格式。</li>
</ol>
<p>让 VIM 正确处理文件格式和文件编码，有赖于 <code>~/.vimrc</code> 的正确配置</p>
<h2 id="123-文件格式">12.3 文件格式</h2>
<p>大致有三种文件格式：<code>unix</code>，<code>dos</code>，<code>mac</code>。 三种格式的区别主要在于回车键的编码：<code>dos</code> 下是回车加换行，<code>unix</code> 下只有换行符，<code>mac</code> 下只有回车符。</p>
<ol>
<li><code>:e ++ff=dos filename</code>, 让 VIM 用 <code>dos</code> 格式打开这个文件。</li>
<li><code>:w ++ff=mac filename</code>, 以 <code>mac</code> 格式存储这个文件。</li>
<li><code>:set ff</code>，显示当前文件的格式。</li>
<li>在 <code>vimrc</code> 中添加 <code>set fileformats=unix,dos,mac</code>，让 VIM 自动识别文件格式。</li>
</ol>
<h1 id="13-编程辅助">13 编程辅助</h1>
<h2 id="131-一些按键">13.1 一些按键</h2>
<ol>
<li><code>gd</code>: 跳转到局部变量的定义处；</li>
<li><code>gD</code>: 跳转到全局变量的定义处，从当前文件开头开始搜索；</li>
<li><code>g;</code>: 上一个修改过的地方；</li>
<li><code>g,</code>: 下一个修改过的地方；</li>
<li><code>[[</code>: 跳转到上一个函数块开始，需要有单独一行的 <code>{</code>。</li>
<li><code>]]</code>: 跳转到下一个函数块开始，需要有单独一行的 <code>{</code>。</li>
<li><code>[]</code>: 跳转到上一个函数块结束，需要有单独一行的 <code>}</code>。</li>
<li><code>][</code>: 跳转到下一个函数块结束，需要有单独一行的 <code>}</code>。</li>
<li><code>[{</code>: 跳转到当前块开始处；</li>
<li><code>]}</code>: 跳转到当前块结束处；</li>
<li><code>[/</code>: 跳转到当前注释块开始处；</li>
<li><code>]/</code>: 跳转到当前注释块结束处；</li>
<li><code>%</code>: 不仅能移动到匹配的 <code>()</code>,<code>{}</code> 或 <code>[]</code> 上，而且能在 <code>#if</code>，<code>#else</code>，<code>#endif</code> 之间跳跃。</li>
</ol>
<p>下面的括号匹配对编程很实用的。</p>
<ol>
<li><code>ci', di', yi'</code>：修改、剪切或复制 <code>'</code> 之间的内容。</li>
<li><code>ca', da', ya'</code>：修改、剪切或复制'之间的内容，包含 <code>'</code>。</li>
<li><code>ci&quot;, di&quot;, yi&quot;</code>：修改、剪切或复制 <code>&quot;</code> 之间的内容。</li>
<li><code>ca&quot;, da&quot;, ya&quot;</code>：修改、剪切或复制 <code>&quot;</code> 之间的内容，包含 <code>&quot;</code>。</li>
<li><code>ci(, di(, yi(</code>：修改、剪切或复制 <code>()</code> 之间的内容。</li>
<li><code>ca(, da(, ya(</code>：修改、剪切或复制 <code>()</code> 之间的内容，包含()。</li>
<li><code>ci[, di[, yi[</code>：修改、剪切或复制 <code>[]</code> 之间的内容。</li>
<li><code>ca[, da[, ya[</code>：修改、剪切或复制 <code>[]</code> 之间的内容，包含 <code>[]</code>。</li>
<li><code>ci{, di{, yi{</code>：修改、剪切或复制 <code>{}</code> 之间的内容。</li>
<li><code>ca{, da{, ya{</code>：修改、剪切或复制 <code>{}</code> 之间的内容，包含 <code>{}</code>。</li>
<li><code>ci&lt;, di&lt;, yi&lt;</code>：修改、剪切或复制 <code>&lt;&gt;</code> 之间的内容。</li>
<li><code>ca&lt;, da&lt;, ya&lt;</code>：修改、剪切或复制 <code>&lt;&gt;</code> 之间的内容，包含 <code>&lt;&gt;</code>。</li>
</ol>
<h2 id="132-ctags">13.2 ctags</h2>
<ol>
<li><code>ctags -R</code>: 生成 <code>tag</code> 文件，<code>-R</code> 表示也为子目录中的文件生成 <code>tags</code>。</li>
<li><code>:set tags=path/tags</code> -- 告诉 <code>ctags</code> 使用哪个 <code>tag</code> 文件。</li>
<li><code>:tag xyz</code> -- 跳到 <code>xyz</code> 的定义处，或者将光标放在 <code>xyz</code> 上按 <code>C-]</code>，返回用 <code>C-t</code></li>
<li><code>:stag xyz</code> -- 用分割的窗口显示 <code>xyz</code> 的定义，或者 <code>C-w ]</code>， 如果用 <code>C-w n ]</code>，就会打开一个 <code>n</code> 行高的窗口</li>
<li><code>:ptag xyz</code> -- 在预览窗口中打开 <code>xyz</code> 的定义，热键是 <code>C-w }</code>。</li>
<li><code>:pclose</code> -- 关闭预览窗口。热键是 <code>C-w z</code>。</li>
<li><code>:pedit abc.h</code> -- 在预览窗口中编辑 <code>abc.h</code></li>
<li><code>:psearch abc</code> -- 搜索当前文件和当前文件 include 的文件，显示包含 <code>abc</code> 的行。</li>
</ol>
<p>有时一个 <code>tag</code> 可能有多个匹配，如函数重载，一个函数名就会有多个匹配。 这种情况会先跳转到第一个匹配处。</p>
<ol>
<li><code>:[n]tnext</code> -- 下一 <code>[n]</code> 个匹配。</li>
<li><code>:[n]tprev</code> -- 上一 <code>[n]</code> 个匹配。</li>
<li><code>:tfirst</code> -- 第一个匹配</li>
<li><code>:tlast</code> -- 最后一个匹配</li>
<li><code>:tselect tagname</code> -- 打开选择列表</li>
</ol>
<p><code>tab</code> 键补齐</p>
<ol>
<li><code>:tag xyz</code>-- 补齐以 <code>xyz</code> 开头的 <code>tag</code> 名，继续按 <code>tab</code> 键，会显示其他的。</li>
<li><code>:tag /xyz</code>-- 会用名字中含有 <code>xyz</code> 的 <code>tag</code> 名补全。</li>
</ol>
<h2 id="133-cscope">13.3 cscope</h2>
<ol>
<li><code>cscope -Rbq</code>: 生成 <code>cscope.out</code> 文件</li>
<li><code>:cs add /path/to/cscope.out /your/work/dir</code></li>
<li><code>:cs find c func</code> -- 查找 <code>func</code> 在哪些地方被调用</li>
<li><code>:cw</code> -- 打开 <code>quickfix</code> 窗口查看结果</li>
</ol>
<h2 id="134-gtags">13.4 gtags</h2>
<p><code>Gtags</code> 综合了 <code>ctags</code> 和 <code>cscope</code> 的功能。 使用 <code>Gtags</code> 之前，你需要安装 <code>GNU Gtags</code>。 然后在工程目录运行 <code>gtags</code> 。</p>
<ol>
<li><code>:Gtags funcname</code> 定位到 <code>funcname</code> 的定义处。</li>
<li><code>:Gtags -r funcname</code> 查询 <code>funcname</code> 被引用的地方。</li>
<li><code>:Gtags -s symbol</code> 定位 <code>symbol</code> 出现的地方。</li>
<li><code>:Gtags -g string Goto string</code> 出现的地方。<code>:Gtags -gi string</code> 忽略大小写。</li>
<li><code>:Gtags -f filename</code> 显示 <code>filename</code> 中的函数列表。 你可以用 <code>:Gtags -f %</code> 显示当前文件。</li>
<li><code>:Gtags -P pattern</code> 显示路径中包含特定模式的文件。 如 <code>:Gtags -P .h$</code> 显示所有头文件，<code>:Gtags -P /vm/</code> 显示 <code>vm</code> 目录下的文件。</li>
</ol>
<h2 id="135-编译">13.5 编译</h2>
<p>VIM 提供了 <code>:make</code> 来编译程序，默认调用的是 <code>make</code>， 如果你当前目录下有 <code>makefile</code>，简单地 <code>:make</code> 即可。</p>
<p>如果你没有 <code>make</code> 程序，你可以通过配置 <code>makeprg</code> 选项来更改 <code>make</code> 调用的程序。 如果你只有一个<code>abc.java</code>文件，你可以这样设置：</p>
<pre><code class="language-bash">set makeprg=javac\ abc.java
</code></pre>
<p>然后 <code>:make</code> 即可。如果程序有错，可以通过 <code>quickfix</code> 窗口查看错误。 不过如果要正确定位错误，需要设置好 <code>errorformat</code>，让 VIM 识别错误信息。 如：</p>
<pre><code class="language-bash">:setl efm=%A%f:%l:\ %m,%-Z%p^,%-C%.%#
</code></pre>
<p><code>%f</code> 表示文件名，<code>%l</code> 表示行号，<code>%m</code> 表示错误信息，其它的还不能理解。 请参考 <code>:help errorformat</code>。</p>
<h2 id="136-快速修改窗口">13.6 快速修改窗口</h2>
<p>其实是 <code>quickfix</code> 插件提供的功能， 对编译调试程序非常有用 😃</p>
<ol>
<li><code>:copen</code> -- 打开快速修改窗口。</li>
<li><code>:cclose</code> -- 关闭快速修改窗口。</li>
</ol>
<p>快速修改窗口在 <code>make</code> 程序时非常有用，当 <code>make</code> 之后：</p>
<ol>
<li><code>:cl</code> -- 在快速修改窗口中列出错误。</li>
<li><code>:cn</code> -- 定位到下一个错误。</li>
<li><code>:cp</code> -- 定位到上一个错误。</li>
<li><code>:cr</code> -- 定位到第一个错误。</li>
</ol>
<h2 id="137-自动补全">13.7 自动补全</h2>
<ol>
<li><code>C-x C-s</code> -- 拼写建议。</li>
<li><code>C-x C-v</code> -- 补全 VIM 选项和命令。</li>
<li><code>C-x C-l</code> -- 整行补全。</li>
<li><code>C-x C-f</code> -- 自动补全文件路径。弹出菜单后，按 <code>C-f</code> 循环选择，当然也可以按 <code>C-n</code> 和 <code>C-p</code>。</li>
<li><code>C-x C-p</code> 和 <code>C-x C-n</code> -- 用文档中出现过的单词补全当前的词。 直接按 <code>C-p</code> 和 <code>C-n</code> 也可以。</li>
<li><code>C-x C-o</code> -- 编程时可以补全关键字和函数名啊。</li>
<li><code>C-x C-i</code> -- 根据头文件内关键字补全。</li>
<li><code>C-x C-d</code> -- 补全宏定义。</li>
<li><code>C-x C-n</code> -- 按缓冲区中出现过的关键字补全。 直接按 <code>C-n</code> 或 <code>C-p</code> 即可。</li>
</ol>
<p>当弹出补全菜单后：</p>
<ol>
<li><code>C-p</code> 向前切换成员；</li>
<li><code>C-n</code> 向后切换成员；</li>
<li><code>C-e</code> 退出下拉菜单，并退回到原来录入的文字；</li>
<li><code>C-y</code> 退出下拉菜单，并接受当前选项。</li>
</ol>
<h2 id="138-多行缩进缩出">13.8 多行缩进缩出</h2>
<ol>
<li>正常模式下，按两下 <code>&gt;;</code> 光标所在行会缩进。</li>
<li>如果先按了 <code>n</code>，再按两下 <code>&gt;;</code>，光标以下的 <code>n</code> 行会缩进。</li>
<li>对应的，按两下 <code>&lt;;</code>，光标所在行会缩出。</li>
<li>如果在编辑代码文件，可以用 <code>=</code> 进行调整。</li>
<li>在可视模式下，选择要调整的代码块，按 <code>=</code>，代码会按书写规则缩排好。</li>
<li>或者 <code>n =</code>，调整 <code>n</code> 行代码的缩排。</li>
</ol>
<h2 id="139-折叠">13.9 折叠</h2>
<ol>
<li><code>zf</code> -- 创建折叠的命令，可以在一个可视区域上使用该命令；</li>
<li><code>zd</code> -- 删除当前行的折叠；</li>
<li><code>zD</code> -- 删除当前行的折叠；</li>
<li><code>zfap</code> -- 折叠光标所在的段；</li>
<li><code>zo</code> -- 打开折叠的文本；</li>
<li><code>zc</code> -- 收起折叠；</li>
<li><code>za</code> -- 打开/关闭当前折叠；</li>
<li><code>zr</code> -- 打开嵌套的折行；</li>
<li><code>zm</code> -- 收起嵌套的折行；</li>
<li><code>zR (zO)</code> -- 打开所有折行；</li>
<li><code>zM (zC)</code> -- 收起所有折行；</li>
<li><code>zj</code> -- 跳到下一个折叠处；</li>
<li><code>zk</code> -- 跳到上一个折叠处；</li>
<li><code>zi</code> -- <code>enable/disable fold</code>;</li>
</ol>
<h1 id="14-命令行">14 命令行</h1>
<p><code>normal</code> 模式下按:进入命令行模式</p>
<h2 id="141-命令行模式下的快捷键">14.1 命令行模式下的快捷键：</h2>
<ol>
<li>上下方向键：上一条或者下一条命令。如果已经输入了部分命令，则找上一 条或者下一条匹配的命令。</li>
<li>左右方向键：左 / 右移一个字符。</li>
<li><code>C-w</code>： 向前删除一个单词。</li>
<li><code>C-h</code>： 向前删除一个字符，等同于 <code>Backspace</code>。</li>
<li><code>C-u</code>： 从当前位置移动到命令行开头。</li>
<li><code>C-b</code>： 移动到命令行开头。</li>
<li><code>C-e</code>： 移动到命令行末尾。</li>
<li><code>Shift-Left</code>：左移一个单词。</li>
<li><code>Shift-Right</code>：右移一个单词。</li>
<li><code>@</code>： 重复上一次的冒号命令。</li>
<li><code>q</code>： 正常模式下，<code>q</code> 然后按 <code>':'</code>，打开命令行历史缓冲区， 可以像编辑文件一样编辑命令。</li>
<li><code>q/</code> 和 <code>q?</code> 可以打开查找历史记录。</li>
</ol>
<h2 id="142-执行外部命令">14.2 执行外部命令</h2>
<ol>
<li><code>:! cmd</code> 执行外部命令。</li>
<li><code>:!!</code> 执行上一次的外部命令。</li>
<li><code>:sh</code> 调用 <code>shell</code>，用 <code>exit</code> 返回 VIM。</li>
<li><code>:r !cmd</code> 将命令的返回结果插入文件当前位置。</li>
<li><code>:m,nw !cmd</code> 将文件的 <code>m</code> 行到 <code>n</code> 行之间的内容做为命令输入执行命令。</li>
</ol>
<h1 id="15-其它">15 其它</h1>
<h2 id="151-工作目录">15.1 工作目录</h2>
<ol>
<li><code>:pwd</code> 显示 VIM 的工作目录。</li>
<li><code>:cd path</code> 改变 VIM 的工作目录。</li>
<li><code>:set autochdir</code> 可以让 VIM 根据编辑的文件自动切换工作目录。</li>
</ol>
<h2 id="152-一些快捷键收集中">15.2 一些快捷键（收集中）</h2>
<ol>
<li><code>K</code>: 打开光标所在词的 <code>manpage</code>。</li>
<li><code>*</code>: 向下搜索光标所在词。</li>
<li><code>g*</code>: 同上，但部分符合即可。</li>
<li><code>#</code>: 向上搜索光标所在词。</li>
<li><code>g#</code>: 同上，但部分符合即可。</li>
<li><code>g C-g</code>: 统计全文或统计部分的字数。</li>
</ol>
<h2 id="153-在线帮助">15.3 在线帮助</h2>
<ol>
<li><code>:h(elp)</code> 或 <code>F1</code> 打开总的帮助。</li>
<li><code>:help user-manual</code> 打开用户手册。</li>
<li>命令帮助的格式为：第一行指明怎么使用那个命令； 然后是缩进的一段解释这个命令的作用，然后是进一步的信息。</li>
<li><code>:helptags somepath</code> 为 <code>somepath</code> 中的文档生成索引。</li>
<li><code>:helpgrep</code> 可以搜索整个帮助文档，匹配的列表显示在 <code>quickfix</code> 窗口中。</li>
<li><code>Ctrl+]</code> 跳转到 <code>tag</code> 主题，<code>Ctrl+t</code> 跳回。</li>
<li><code>:ver</code> 显示版本信息。</li>
</ol>
<h2 id="154-一些小功能">15.4 一些小功能</h2>
<ul>
<li>简单计算器: 在插入模式下，输入 <code>C-r =</code>，然后输入表达式，就能在 光标处得到计算结果。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vim——配置入门]]></title>
        <id>https://tdmaker.github.io/faded/post/vim-configuration-introduction/</id>
        <link href="https://tdmaker.github.io/faded/post/vim-configuration-introduction/">
        </link>
        <updated>2020-04-09T07:34:01.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p><a href="http://www.ruanyifeng.com/blog/2018/09/vimrc.html">Vim 配置入门</a></p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p><a href="http://www.ruanyifeng.com/blog/2018/09/vimrc.html">Vim 配置入门</a></p>
</blockquote>
<!-- more -->
<p>Vim 的配置不太容易，它有自己的语法，许许多多的命令。我总是记不清楚，所以就整理了下面这篇文章，列出主要配置项的含义。</p>
<h1 id="1-基础知识">1 基础知识</h1>
<p>Vim 的全局配置一般在 <code>/etc/vim/vimrc</code> 或者 <code>/etc/vimrc</code>，对所有用户生效。用户个人的配置在 <code>~/.vimrc</code>。</p>
<p>如果只对单次编辑启用某个配置项，可以在命令模式下，先输入一个冒号，再输入配置。举例来说，<code>set number</code> 这个配置可以写在 <code>.vimrc</code> 里面，也可以在命令模式输入。</p>
<pre><code class="language-bash">:set number
</code></pre>
<p>配置项一般都有“打开”和“关闭”两个设置。“关闭”就是在“打开”前面加上前缀 &quot;no&quot;。</p>
<pre><code class="language-bash">&quot; 打开
set number

&quot; 关闭
set nonumber
</code></pre>
<p>上面代码中，双引号开始的行表示注释。</p>
<p>查询某个配置项是打开还是关闭，可以在命令模式下，输入该配置，并在后面加上问号。</p>
<pre><code class="language-vim">:set number?
</code></pre>
<p>上面的命令会返回 <code>number</code> 或者 <code>nonumber</code>。</p>
<p>如果想查看帮助，可以使用 <code>help</code> 命令。</p>
<pre><code class="language-vim">:help number
</code></pre>
<h1 id="2-基本配置">2 基本配置</h1>
<p>（1）</p>
<pre><code class="language-bash">set nocompatible
</code></pre>
<p>不与 Vi 兼容（采用 Vim 自己的操作命令）。</p>
<p>（2）</p>
<pre><code class="language-bash">syntax on
</code></pre>
<p>打开语法高亮。自动识别代码，使用多种颜色显示。</p>
<p>（3）</p>
<pre><code class="language-bash">set showmode
</code></pre>
<p>在底部显示，当前处于命令模式还是插入模式。</p>
<p>（4）</p>
<pre><code class="language-bash">set showcmd
</code></pre>
<p>命令模式下，在底部显示，当前键入的指令。比如，键入的指令是 <code>2y3d</code>，那么底部就会显示 <code>2y3</code>，当键入 <code>d</code> 的时候，操作完成，显示消失。</p>
<p>（5）</p>
<pre><code class="language-bash">set mouse=a
</code></pre>
<p>支持使用鼠标。<br>
（6）</p>
<pre><code class="language-bash">set encoding=utf-8  
</code></pre>
<p>使用 utf-8 编码。<br>
（7）</p>
<pre><code class="language-bash">set t_Co=256
</code></pre>
<p>启用256色。</p>
<p>（8）</p>
<pre><code class="language-bash">filetype indent on
</code></pre>
<p>开启文件类型检查，并且载入与该类型对应的缩进规则。比如，如果编辑的是 <code>.py</code> 文件，Vim 就是会找 Python 的缩进规则 <code>~/.vim/indent/python.vim</code>。</p>
<h1 id="3-缩进">3 缩进</h1>
<p>9）</p>
<pre><code class="language-bash">set autoindent
</code></pre>
<p>按下回车键后，下一行的缩进会自动跟上一行的缩进保持一致。</p>
<p>（10）</p>
<pre><code class="language-bash">set tabstop=2
</code></pre>
<p>按下 Tab 键时，Vim 显示的空格数。</p>
<p>（11）</p>
<pre><code class="language-bash">set shiftwidth=4
</code></pre>
<p>在文本上按下 <code>&gt;&gt;</code>（增加一级缩进）、<code>&lt;&lt;</code>（取消一级缩进）或者 <code>==</code>（取消全部缩进）时，每一级的字符数。</p>
<p>（12）</p>
<pre><code class="language-bash">set expandtab
</code></pre>
<p>由于 Tab 键在不同的编辑器缩进不一致，该设置自动将 Tab 转为空格。</p>
<p>（13）</p>
<pre><code class="language-bash">set softtabstop=2
</code></pre>
<p>Tab 转为多少个空格。</p>
<h1 id="4-外观">4 外观</h1>
<p>14）</p>
<pre><code class="language-bash">set number
</code></pre>
<p>显示行号</p>
<p>（15）</p>
<pre><code class="language-bash">set relativenumber
</code></pre>
<p>显示光标所在的当前行的行号，其他行都为相对于该行的相对行号。</p>
<p>（16）</p>
<pre><code class="language-bash">set cursorline
</code></pre>
<p>光标所在的当前行高亮。</p>
<p>（17）</p>
<pre><code class="language-bash">set textwidth=80
</code></pre>
<p>设置行宽，即一行显示多少个字符。</p>
<p>（18）</p>
<pre><code class="language-bash">set wrap
</code></pre>
<p>自动折行，即太长的行分成几行显示。</p>
<pre><code class="language-bash">set nowrap
</code></pre>
<p>关闭自动折行</p>
<p>（19）</p>
<pre><code class="language-bash">set linebreak
</code></pre>
<p>只有遇到指定的符号（比如空格、连词号和其他标点符号），才发生折行。也就是说，不会在单词内部折行。</p>
<p>（20）</p>
<pre><code class="language-bash">set wrapmargin=2
</code></pre>
<p>指定折行处与编辑窗口的右边缘之间空出的字符数。</p>
<p>（21）</p>
<pre><code class="language-bash">set scrolloff=5
</code></pre>
<p>垂直滚动时，光标距离顶部/底部的位置（单位：行）。</p>
<p>（22）</p>
<pre><code class="language-bash">set sidescrolloff=15
</code></pre>
<p>水平滚动时，光标距离行首或行尾的位置（单位：字符）。该配置在不折行时比较有用。</p>
<p>（23）</p>
<pre><code class="language-bash">set laststatus=2
</code></pre>
<p>是否显示状态栏。0 表示不显示，1 表示只在多窗口时显示，2 表示显示。</p>
<p>（24）</p>
<pre><code class="language-bash">set  ruler
</code></pre>
<p>在状态栏显示光标的当前位置（位于哪一行哪一列）。</p>
<h1 id="5-搜索">5 搜索</h1>
<p>25）</p>
<pre><code class="language-bash">set showmatch
</code></pre>
<p>光标遇到圆括号、方括号、大括号时，自动高亮对应的另一个圆括号、方括号和大括号。</p>
<p>（26）</p>
<pre><code class="language-bash">set hlsearch
</code></pre>
<p>搜索时，高亮显示匹配结果。</p>
<p>（27）</p>
<pre><code class="language-bash">set incsearch
</code></pre>
<p>输入搜索模式时，每输入一个字符，就自动跳到第一个匹配的结果。</p>
<p>（28）</p>
<pre><code class="language-bash">set ignorecase
</code></pre>
<p>搜索时忽略大小写。</p>
<p>（29）</p>
<pre><code class="language-bash">set smartcase
</code></pre>
<p>如果同时打开了 <code>ignorecase</code>，那么对于只有一个大写字母的搜索词，将大小写敏感；其他情况都是大小写不敏感。比如，搜索 <code>Test</code> 时，将不匹配 <code>test</code>；搜索 <code>test</code> 时，将匹配 <code>Test</code>。</p>
<h1 id="6-编辑">6 编辑</h1>
<p>30）</p>
<pre><code class="language-bash">set spell spelllang=en_us
</code></pre>
<p>打开英语单词的拼写检查。</p>
<p>（31）</p>
<pre><code class="language-bash">set nobackup
</code></pre>
<p>不创建备份文件。默认情况下，文件保存时，会额外创建一个备份文件，它的文件名是在原文件名的末尾，再添加一个波浪号（〜）。</p>
<p>（32）</p>
<pre><code class="language-bash">set noswapfile
</code></pre>
<p>不创建交换文件。交换文件主要用于系统崩溃时恢复文件，文件名的开头是 <code>.</code>、结尾是 <code>.swp</code>。</p>
<p>（33）</p>
<pre><code class="language-bash">set undofile
</code></pre>
<p>保留撤销历史。</p>
<p>Vim 会在编辑时保存操作历史，用来供用户撤消更改。默认情况下，操作记录只在本次编辑时有效，一旦编辑结束、文件关闭，操作历史就消失了。</p>
<p>打开这个设置，可以在文件关闭后，操作记录保留在一个文件里面，继续存在。这意味着，重新打开一个文件，可以撤销上一次编辑时的操作。撤消文件是跟原文件保存在一起的隐藏文件，文件名以 <code>.un~</code> 开头。</p>
<p>（34）</p>
<pre><code class="language-bash">set backupdir=~/.vim/.backup//  
set directory=~/.vim/.swp//
set undodir=~/.vim/.undo// 
</code></pre>
<p>设置备份文件、交换文件、操作历史文件的保存位置。</p>
<p>结尾的 <code>//</code>表示生成的文件名带有绝对路径，路径中用 <code>%</code> 替换目录分隔符，这样可以防止文件重名。</p>
<p>（35）</p>
<pre><code class="language-bash">set autochdir
</code></pre>
<p>自动切换工作目录。这主要用在一个 Vim 会话之中打开多个文件的情况，默认的工作目录是打开的第一个文件的目录。该配置可以将工作目录自动切换到，正在编辑的文件的目录。</p>
<p>（36）</p>
<pre><code class="language-bash">set noerrorbells
</code></pre>
<p>出错时，不要发出响声。</p>
<p>（37）</p>
<pre><code class="language-bash">set visualbell
</code></pre>
<p>出错时，发出视觉提示，通常是屏幕闪烁。</p>
<p>（38）</p>
<pre><code class="language-bash">set history=1000
</code></pre>
<p>Vim 需要记住多少次历史操作。</p>
<p>（39）</p>
<pre><code class="language-bash">set autoread
</code></pre>
<p>打开文件监视。如果在编辑过程中文件发生外部改变（比如被别的编辑器编辑了），就会发出提示。</p>
<p>（40）</p>
<pre><code class="language-bash">set listchars=tab:»■,trail:■
set list
</code></pre>
<p>如果行尾有多余的空格（包括 Tab 键），该配置将让这些空格显示成可见的小方块。</p>
<p>（41）</p>
<pre><code class="language-bash">set wildmenu
set wildmode=longest:list,full
</code></pre>
<p>命令模式下，底部操作指令按下 Tab 键自动补全。第一次按下 Tab，会显示所有匹配的操作指令的清单；第二次按下 Tab，会依次选择各个指令。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vim——重要的命令]]></title>
        <id>https://tdmaker.github.io/faded/post/vim-key-instruct/</id>
        <link href="https://tdmaker.github.io/faded/post/vim-key-instruct/">
        </link>
        <updated>2020-04-09T05:23:13.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p><a href="https://linux.cn/article-4669-1.html">一些不起眼但非常有用的 Vim 命令</a></p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p><a href="https://linux.cn/article-4669-1.html">一些不起眼但非常有用的 Vim 命令</a></p>
</blockquote>
<!-- more -->
<h1 id="1-保存文件并退出">1 保存文件并退出</h1>
<pre><code class="language-vim">:x
:wq
</code></pre>
<p>都是保存当前文件并退出。这两个命令实际上并不完全等价，当文件被修改时两个命令时相同的。但如果未被修改，使用 <code>:x</code> 不会更改文件的修改时间，而使用 <code>:wq</code> 会改变文件的修改时间。</p>
<h1 id="2-基本计算器">2 基本计算器</h1>
<p>在插入模式下，你可以使用 Ctrl+r 键然后输入 =，再输入一个简单的算式。按 Enter 键，计算结果就会插入到文件中。例如，尝试输入：</p>
<pre><code class="language-vim">Ctrl+r '=2+2' ENTER
</code></pre>
<p><img src="https://tdmaker.github.io/faded//post-images/1586410130425.png" alt="" loading="lazy"><br>
然后计算结果“4 ”会被插入到文件中。<br>
<img src="https://tdmaker.github.io/faded//post-images/1586410173096.png" alt="" loading="lazy"></p>
<h1 id="3-查找重复的连续的单词">3 查找重复的连续的单词</h1>
<p>当你很快地打字时，很有可能会连续输入同一个单词两次，就像 this this。这种错误可能骗过任何一个人，即使是你自己重新阅读一遍也不可避免。幸运的是，有一个简单的正则表达式可以用来预防这个错误。使用搜索命令（默认时 /）然后输入：</p>
<pre><code class="language-vim">\(\&lt;\w\+\&gt;\)\_s*\1
</code></pre>
<p>这会显示所有重复的单词。要达到最好的效果，不要忘记把下面的命令：</p>
<pre><code class="language-bash">set hlsearch
</code></pre>
<p>放到你的 .vimrc 文件中高亮所有的匹配。<br>
<img src="https://tdmaker.github.io/faded//post-images/1586410335520.png" alt="" loading="lazy"></p>
<h1 id="4-缩写">4 缩写</h1>
<p>一个很可能是最令人印象深刻的窍门是你可以在 Vim 中定义缩写，它可以实时地把你输入的东西替换为另外的东西。语法格式如下：</p>
<pre><code class="language-vim">:ab [缩写] [要替换的文字]
</code></pre>
<p>一个通用的例子是：</p>
<pre><code class="language-vim">:ab asap as soon as possible
</code></pre>
<p>会把你输入的 “asap” 替换为 “as soon as possible”。</p>
<h1 id="5-在你忘记用-root-方式打开文件时的文件保存">5 在你忘记用 root 方式打开文件时的文件保存</h1>
<p>这可能是一个在论坛中一直受欢迎的命令。每当你打开一个你没有写入权限的文件（比如系统配置文件）并做了一些修改，Vim 无法通过普通的 <code>:w</code> 命令来保存。</p>
<p>你不需要重新以 root 方式打开文件再进行修改，只需要运行：</p>
<pre><code class="language-vim">:w !sudo tee %
</code></pre>
<p>这会直接以 root 方式保存。</p>
<h1 id="6-实时加密文本">6 实时加密文本</h1>
<p>如果你不想让别人看懂你的屏幕上的内容，你可以使用一个内置的选项，通过下面的命令使用 <a href="https://en.wikipedia.org/wiki/ROT13">ROT13</a> 来对文本进行编码：</p>
<pre><code class="language-vim">ggVGg?
</code></pre>
<p><img src="https://tdmaker.github.io/faded//post-images/1586410711296.png" alt="" loading="lazy"><br>
<code>gg</code> 把光标移动到 Vim 缓冲区的第一行，<code>V</code> 进入可视模式，<code>G</code> 把光标移动到缓冲区的最后一行。因此，<code>ggVG</code> 使可视模式覆盖这个当前缓冲区。最后 <code>g?</code> 使用 ROT13 对整个区域进行编码。</p>
<p>注意它可以被映射到一个最常使用的键。它对字母符号也可以很好地工作。要对它进行撤销，最好的方法就是使用撤销命令：<code>u</code>。<br>
<img src="https://tdmaker.github.io/faded//post-images/1586410826069.png" alt="" loading="lazy"></p>
<h1 id="7-自动补全">7 自动补全</h1>
<p>这是另外一个令我感到惭愧的功能，但我发现周围很多人并不知道。Vim 默认有自动补全的功能。的确这个功能是很基本的，并且可以通过插件来增强，但它也很有帮助。方法很简单。Vim 尝试通过已经输入的单词来预测单词的结尾。比如当你在同一个文件中第二次输入 “compiler” 时，仅仅输入 “com” 然后保持在插入模式，按 Ctrl+n 键就可以看到 Vim 为你补全了单词。很简单，但也很有用。</p>
<h1 id="8-比较两个文件的不同">8 比较两个文件的不同</h1>
<p>你们中的大多数很可能都知道 vimdiff 命令，它可以使用分离模式打开 Vim 并比较两个文件的不同。语法如下：</p>
<pre><code class="language-bash">$ vimdiff [文件1] [文件2]
</code></pre>
<p>但同样的结果也可以通过下面的 Vim 命令来获得：</p>
<pre><code class="language-vim">:diffthis
</code></pre>
<p>首先在 Vim 中打开原始文件。然后使用分离模式带来第二个文件：</p>
<pre><code class="language-vim">:vsp [文件2]
</code></pre>
<p>最后在第一个缓冲区里输入：</p>
<pre><code class="language-vim">:diffthis
</code></pre>
<p>通过 Ctrl+w 来切换缓冲区并再次输入：</p>
<pre><code class="language-vim">:diffthis
</code></pre>
<p>这样两个文件中不同的部分就会被高亮。<br>
（译者注：可以直接在一个缓冲区里使用命令 :windo diffthis，而不用输入 :diffthis 两次）<br>
要停止比较，使用：</p>
<pre><code class="language-vim">:diffoff
</code></pre>
<h1 id="9-按时间回退文件">9 按时间回退文件</h1>
<p>Vim 会记录文件的更改，你很容易可以回退到之前某个时间。该命令是相当直观的。比如：</p>
<pre><code class="language-vim">:earlier 1m
</code></pre>
<p>会把文件回退到 1 分钟以前的状态。</p>
<p>注意，你可以使用下面的命令进行相反的转换：</p>
<pre><code class="language-vim">:later
</code></pre>
<h1 id="10-删除标记内部的文字">10 删除标记内部的文字</h1>
<p>当我开始使用 Vim 时，一件我总是想很方便做的事情是如何轻松的删除方括号或圆括号里的内容。转到开始的标记，然后使用下面的语法：</p>
<pre><code class="language-vim">di[标记]
</code></pre>
<p>比如，把光标放在开始的圆括号上，使用下面的命令来删除圆括号内的文字：</p>
<pre><code class="language-vim">di(
</code></pre>
<p>如果是方括号或者是引号，则使用：</p>
<pre><code class="language-vim">di{
</code></pre>
<p>和：</p>
<pre><code class="language-vim">di&quot;
</code></pre>
<h1 id="11-删除指定标记前的内容">11 删除指定标记前的内容</h1>
<p>和删除标记内部有些相似，但目的不同。命令如下：</p>
<pre><code class="language-vim">dt[标记]
</code></pre>
<p>会删除所有光标和标记之间的内容（保持标记不动），如果在同一行有这个标记的话。例如</p>
<pre><code class="language-vim">dt.
</code></pre>
<p>会删除至句子的末尾，但保持 <code>.</code> 不动。</p>
<h1 id="12-把-vim-变为十六进制编辑器">12 把 Vim 变为十六进制编辑器</h1>
<p>这不是我最喜欢的窍门，但有时会很有趣。你可以把 Vim 和 xxd 功能连起来来把文件转换为十六进制模式。命令如下：<code>:%!xxd</code><br>
<img src="https://tdmaker.github.io/faded//post-images/1586412158407.png" alt="" loading="lazy"><br>
类似的，你可以通过下面的命令恢复原来的状态：</p>
<pre><code class="language-vim">:%!xxd -r
</code></pre>
<h1 id="13-把光标下的文字置于屏幕中央">13 把光标下的文字置于屏幕中央</h1>
<p>我们所要做的事情如标题所示。如果你想强制滚动屏幕来把光标下的文字置于屏幕的中央，在可视模式中使用命令（译者注：在普通模式中也可以）：</p>
<pre><code class="language-vim">zz
</code></pre>
<h1 id="14-跳到上一个下一个位置">14 跳到上一个／下一个位置</h1>
<p>当你编辑一个很大的文件时，经常要做的事是在某处进行修改，然后跳到另外一处。如果你想跳回之前修改的地方，使用命令：</p>
<pre><code class="language-vim">Ctrl+o
</code></pre>
<p>来回到之前修改的地方；类似的：</p>
<pre><code class="language-vim">Ctrl+i
</code></pre>
<p>会回退上面的跳动。</p>
<h1 id="15-把当前文件转化为网页">15 把当前文件转化为网页</h1>
<p>这会生成一个 HTML 文件来显示文本，并在分开的窗口显示源代码：</p>
<pre><code class="language-vim">:%TOhtml
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://tdmaker.github.io/faded//post-images/1586413621493.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vim——光标移动篇]]></title>
        <id>https://tdmaker.github.io/faded/post/vim-cursor-movement/</id>
        <link href="https://tdmaker.github.io/faded/post/vim-cursor-movement/">
        </link>
        <updated>2020-04-09T04:37:23.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p><a href="https://www.jianshu.com/p/52b1b41de71f">Vim常用文档动作命令总结</a></p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p><a href="https://www.jianshu.com/p/52b1b41de71f">Vim常用文档动作命令总结</a></p>
</blockquote>
<!-- more -->
<h1 id="1-基本方向移动">1 基本方向移动</h1>
<pre><code class="language-shell">h  ：  向左移动一列
l  ：  向右移动一列
j  ：  向下移动一个实际行
k  ： 向上移动一个实际行
</code></pre>
<p>所谓列可能指一个字节，也可能是一个字符，根据文件内容决定。<br>
实际行指的是文本截止到一个换行符为止称为一个实际行。有时因为文本太长，一个实际行在窗口中会显示成好几行。可以通过 <code>:set number</code> 命令查看实际的行数。</p>
<h1 id="2-基于单词的移动">2 基于单词的移动</h1>
<p>Vim有一组基于单词的正向和反向移动的命令。</p>
<pre><code class="language-shell">w  ：  正向移动到下一单词的开头
e  ：  正向移动到当前/下一单词的结尾
b  ：  反向移动到当前/上一单词的开头
ge ：  反向移动到上一单词的结尾
</code></pre>
<p>基于单词的移动命令可以和其他命令结合使用。例如 <code>:ea</code> 可以跳转到单词的结尾并进入插入模式。</p>
<h1 id="3-基于查找的移动">3 基于查找的移动</h1>
<p><code>f</code> 命令是最常用的查找命令，用于当前行进行指定字符的查找。如果找到则光标移动到目标字符，否则不移动。<br>
Vim 会记录上一次执行的查找命令，再次查找时可以使用 <code>;</code> 命令来完成相同查找。如果查询跳过头了，可以使用 <code>,</code> 命令返回光标之前的位置。<br>
查询不止 <code>f</code> 命令，其他命令总结如下</p>
<pre><code class="language-shell">f{char}  :  正向移动到下一个{char}所在位置
F{char}  :  反向移动到上一个{char}所在位置
t{char}  :  正向移动到下一个{char}的前一个字符上
T{char}  :  反向移动到上一个{char}的后一个字符上
</code></pre>
<p>除了上述查询方式， <code>/</code> 也是一种常用的查询方式，基于字符串的查询，<code>/{str}</code> 可以高亮目标字符串。可以通过 <code>n</code> 命令跳到下一个匹配处， <code>N</code> 返回前一匹配处。<br>
同样的， <code>/</code> 也可以和其他命令结合使用，例如选择文本。点击 <code>v</code> 进入可视模式，然后输入 <code>/{str}</code><br>
也有例如 <code>d/{str}</code> 删除光标到目标字符串之间的所有内容的操作方式。</p>
<h1 id="4-精确的文本对象选择">4 精确的文本对象选择</h1>
<p>这个是一个很NB的功能，完全颠覆了对文本编辑器的认知。<br>
现在有一个 JS 文件，内容如图：<br>
<img src="https://tdmaker.github.io/faded//post-images/1586408369240.png" alt="" loading="lazy"><br>
这里认识 <code>a</code> 和 <code>i</code> 两个命令，不是普通的插入命令，需要和 <code>v</code> 命令配合使用，选中匹配的文本对象。例如在当前光标所在处输入 <code>vi}</code> 会达到以下效果。<br>
<img src="https://tdmaker.github.io/faded//post-images/1586408458485.png" alt="{}内的内容被选中" loading="lazy"><br>
如果光标的位置在 <code>href</code> 上呢？相同命令下：<br>
<img src="https://tdmaker.github.io/faded//post-images/1586408537529.png" alt="" loading="lazy"><br>
如果换做是 <code>a</code> 命令呢？<br>
<img src="https://tdmaker.github.io/faded//post-images/1586408587971.png" alt="" loading="lazy"><br>
<code>i</code> 命令可以理解为 inside，即选中匹配符号之间不包含匹配符号的内容。而 <code>a</code> 则选中包含匹配项的内容。<br>
常见分隔符总结：</p>
<pre><code class="language-shell">'a)' 或 'ab'  :  一对()
'a}' 或 'aB'  :  一对{}
a]  :  一对[]
a&gt;  :  一对&lt;&gt;
a'  :  一对''
a&quot;  :  一对&quot;&quot;
a`  :  一对``
at  :  一对xml标签
</code></pre>
<p><code>i</code> 与 <code>a</code> 对应，只不过是针对分隔符内部的内容而已。</p>
<h1 id="5-删除周边-修改内部">5 删除周边、修改内部</h1>
<p>Vim 除了可以根据分隔符操作，也可以操作文本块，如单词，句子，段落等。<br>
常见文本范围：</p>
<pre><code class="language-shell">iw  :  当前单词
aw  :  当前单词及一个空格
iW  :  当前字符串
aW  :  当前字符串及一个空格
is  :  当前句子
as  :  当前句子及一个空格
ip  :  当前段落
ap  :  当前段落及一个空行
</code></pre>
<p>上面的范围命令可以和 <code>v</code> 、 <code>c</code> 等操作一起使用。</p>
<h1 id="6-快速回跳">6 快速回跳</h1>
<p>这些命令用的相对少一些，常用一些的有</p>
<pre><code class="language-shell">``  :  当前文件上次跳转操作的位置
`.  :  上次修改操作的地方
`^  :  上次插入的地方
`[  :  上次修改或复制的起始位置
`]  :  上次修改或复制的结束位置
`&lt;  :  上次高亮选区的起始位置
`&gt;  :  上次高亮选区的结束位置
</code></pre>
<h1 id="7-匹配括号间跳转">7 匹配括号间跳转</h1>
<p>Vim的 <code>%</code> 命令允许光标在一对闭括号间跳转。例如当前光标在 <code>[</code> 上， <code>%</code> 命令可以跳转到对应的 <code>]</code> 上，反过来也一样ok。例如将一对 <code>{}</code> 修改为一对 <code>[]</code>。<br>
<img src="https://tdmaker.github.io/faded//post-images/1586409013523.png" alt="" loading="lazy"><br>
当前光标在 <code>{</code> 上，输入 <code>%</code> 命令<br>
<img src="https://tdmaker.github.io/faded//post-images/1586409054358.png" alt="" loading="lazy"><br>
替换当前光标下的字符，通过 <code>r]</code> 将 <code>}</code> 替换为 <code>]</code>。<br>
<img src="https://tdmaker.github.io/faded//post-images/1586409179661.png" alt="" loading="lazy"><br>
输入 <code>``</code> 命令，跳转回上次跳转的位置。<br>
<img src="https://tdmaker.github.io/faded//post-images/1586409233002.png" alt="" loading="lazy"><br>
之后再通过 'r[' 将 '{' 转为 '['。<br>
<img src="https://tdmaker.github.io/faded//post-images/1586409270289.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Bash 移动光标快捷键]]></title>
        <id>https://tdmaker.github.io/faded/post/bash-key-for-cursor-movement/</id>
        <link href="https://tdmaker.github.io/faded/post/bash-key-for-cursor-movement/">
        </link>
        <updated>2020-04-09T04:33:48.000Z</updated>
        <content type="html"><![CDATA[<table>
<thead>
<tr>
<th>快捷键</th>
<th>行为</th>
</tr>
</thead>
<tbody>
<tr>
<td>ctrl+a</td>
<td>移动到行首</td>
</tr>
<tr>
<td>ctrl+e</td>
<td>移动到行尾</td>
</tr>
<tr>
<td>ctrl+f</td>
<td>向右移动一个字符</td>
</tr>
<tr>
<td>ctrl+b</td>
<td>向左移动一个字符</td>
</tr>
<tr>
<td>alt+f</td>
<td>向右移动一个单词</td>
</tr>
<tr>
<td>alt+b</td>
<td>向左移动一个单词</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vim——CheatSheet]]></title>
        <id>https://tdmaker.github.io/faded/post/vim-cheatsheet/</id>
        <link href="https://tdmaker.github.io/faded/post/vim-cheatsheet/">
        </link>
        <updated>2020-04-09T03:57:29.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p><a href="https://www.jianshu.com/p/6aa2e0e39f99">Vim速查表-帮你提高N倍效率</a></p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p><a href="https://www.jianshu.com/p/6aa2e0e39f99">Vim速查表-帮你提高N倍效率</a></p>
</blockquote>
<!-- more -->
<h1 id="进入-vim">进入 vim</h1>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>vim filename</td>
<td>打开或新建文件,并将光标置于第一行首</td>
</tr>
<tr>
<td>vim +n filename</td>
<td>打开文件，并将光标置于第n行首</td>
</tr>
<tr>
<td>vim + filename</td>
<td>打开文件，并将光标置于最后一行首</td>
</tr>
<tr>
<td>vim +/pattern filename</td>
<td>打开文件，并将光标置于第一个与pattern匹配的串处</td>
</tr>
<tr>
<td>vim -r filename</td>
<td>在上次正用vim编辑时发生系统崩溃，恢复filename</td>
</tr>
<tr>
<td>vim filename….filename</td>
<td>打开多个文件，依次编辑</td>
</tr>
</tbody>
</table>
<h1 id="vim-配置">vim 配置</h1>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>all</td>
<td>列出所有选项设置情况</td>
</tr>
<tr>
<td>term</td>
<td>设置终端类型</td>
</tr>
<tr>
<td>ignorance</td>
<td>在搜索中忽略大小写</td>
</tr>
<tr>
<td>list</td>
<td>显示制表位(Ctrl+I)和行尾标志（$)</td>
</tr>
<tr>
<td>number</td>
<td>显示行号</td>
</tr>
<tr>
<td>report</td>
<td>显示由面向行的命令修改过的数目</td>
</tr>
<tr>
<td>terse</td>
<td>显示简短的警告信息</td>
</tr>
<tr>
<td>warn</td>
<td>在转到别的文件时若没保存当前文件则显示NO write信息</td>
</tr>
<tr>
<td>nomagic</td>
<td>允许在搜索模式中，使用前面不带“\”的特殊字符</td>
</tr>
<tr>
<td>nowrapscan</td>
<td>禁止vi在搜索到达文件两端时，又从另一端开始</td>
</tr>
<tr>
<td>mesg</td>
<td>允许vi显示其他用户用write写到自己终端上的信息</td>
</tr>
<tr>
<td>:set number / set nonumber</td>
<td>显示/不显示行号</td>
</tr>
<tr>
<td>:set ruler /set noruler</td>
<td>显示/不显示标尺</td>
</tr>
<tr>
<td>:set hlsearch</td>
<td>高亮显示查找到的单词</td>
</tr>
<tr>
<td>:set nohlsearch</td>
<td>关闭高亮显示</td>
</tr>
<tr>
<td>:syntax on</td>
<td>语法高亮</td>
</tr>
<tr>
<td>:set nu</td>
<td>显示行号</td>
</tr>
<tr>
<td>:set tabstop=8</td>
<td>设置tab大小,8为最常用最普遍的设置</td>
</tr>
<tr>
<td>:set softtabstop=8</td>
<td>4:4个空格,8:正常的制表符,12:一个制表符4个空格,16:两个制表符</td>
</tr>
<tr>
<td>:set autoindent</td>
<td>自动缩进</td>
</tr>
<tr>
<td>:set cindent</td>
<td>C语言格式里面的自动缩进</td>
</tr>
</tbody>
</table>
<h1 id="移动光标">移动光标</h1>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>k nk</td>
<td>上 向上移动n行</td>
</tr>
<tr>
<td>j nj</td>
<td>下 向下移动n行</td>
</tr>
<tr>
<td>h nh</td>
<td>左 向左移动n行</td>
</tr>
<tr>
<td>l nl</td>
<td>右 向右移动n行</td>
</tr>
<tr>
<td>Space</td>
<td>光标右移一个字符</td>
</tr>
<tr>
<td>Backspace</td>
<td>光标左移一个字符</td>
</tr>
<tr>
<td>Enter</td>
<td>光标下移一行</td>
</tr>
<tr>
<td>w/W</td>
<td>光标右移一个字至字首</td>
</tr>
<tr>
<td>b/B</td>
<td>光标左移一个字至字首</td>
</tr>
<tr>
<td>e或E</td>
<td>光标右移一个字至字尾</td>
</tr>
<tr>
<td>)</td>
<td>光标移至句尾</td>
</tr>
<tr>
<td>(</td>
<td>光标移至句首</td>
</tr>
<tr>
<td>}</td>
<td>光标移至段落开头</td>
</tr>
<tr>
<td>{</td>
<td>光标移至段落结尾</td>
</tr>
<tr>
<td>n$</td>
<td>光标移至第n行尾</td>
</tr>
<tr>
<td>H</td>
<td>光标移至屏幕顶行</td>
</tr>
<tr>
<td>M</td>
<td>光标移至屏幕中间行</td>
</tr>
<tr>
<td>L</td>
<td>光标移至屏幕最后行</td>
</tr>
<tr>
<td>0</td>
<td>（注意是数字零）光标移至当前行首</td>
</tr>
<tr>
<td>^</td>
<td>移动光标到行首第一个非空字符上去</td>
</tr>
<tr>
<td>$</td>
<td>光标移至当前行尾</td>
</tr>
<tr>
<td>gg</td>
<td>移到第一行</td>
</tr>
<tr>
<td>G</td>
<td>移到最后一行</td>
</tr>
<tr>
<td>f</td>
<td>移动光标到当前行的字符a上</td>
</tr>
<tr>
<td>F</td>
<td>相反</td>
</tr>
<tr>
<td>%</td>
<td>移动到与制匹配的括号上去（），{}，[]，&lt;&gt;等</td>
</tr>
<tr>
<td>nG</td>
<td>移动到第n行上</td>
</tr>
<tr>
<td>G</td>
<td>到最后一行</td>
</tr>
</tbody>
</table>
<h1 id="屏幕滚动">屏幕滚动</h1>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Ctrl+u</td>
<td>向文件首翻半屏</td>
</tr>
<tr>
<td>Ctrl+d</td>
<td>向文件尾翻半屏</td>
</tr>
<tr>
<td>Ctrl+f</td>
<td>向文件尾翻一屏</td>
</tr>
<tr>
<td>Ctrl＋b</td>
<td>向文件首翻一屏</td>
</tr>
<tr>
<td>nz</td>
<td>将第n行滚至屏幕顶部，不指定n时将当前行滚至屏幕顶部</td>
</tr>
</tbody>
</table>
<h1 id="插入文本类">插入文本类</h1>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>i</td>
<td>在光标前</td>
</tr>
<tr>
<td>I</td>
<td>在当前行首</td>
</tr>
<tr>
<td>a</td>
<td>光标后</td>
</tr>
<tr>
<td>A</td>
<td>在当前行尾</td>
</tr>
<tr>
<td>o</td>
<td>在当前行之下新开一行</td>
</tr>
<tr>
<td>O</td>
<td>在当前行之上新开一行</td>
</tr>
<tr>
<td>r</td>
<td>替换当前字符</td>
</tr>
<tr>
<td>R</td>
<td>替换当前字符及其后的字符，直至按ESC键</td>
</tr>
<tr>
<td>s</td>
<td>从当前光标位置处开始，以输入的文本替代指定数目的字符</td>
</tr>
<tr>
<td>S</td>
<td>删除指定数目的行，并以所输入文本代替之</td>
</tr>
<tr>
<td>ncw/nCW</td>
<td>修改指定数目的字</td>
</tr>
<tr>
<td>nCC</td>
<td>修改指定数目的行</td>
</tr>
</tbody>
</table>
<h1 id="删除命令">删除命令</h1>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>x/X</td>
<td>删除一个字符，x删除光标后的，而X删除光标前的</td>
</tr>
<tr>
<td>dw</td>
<td>删除一个单词(删除光标位置到下一个单词开始的位置)</td>
</tr>
<tr>
<td>dnw</td>
<td>删除n个单词</td>
</tr>
<tr>
<td>dne</td>
<td>也可，只是删除到单词尾</td>
</tr>
<tr>
<td>do</td>
<td>删至行首</td>
</tr>
<tr>
<td>d$</td>
<td>删至行尾</td>
</tr>
<tr>
<td>dd</td>
<td>删除一行</td>
</tr>
<tr>
<td>ndd</td>
<td>删除当前行及其后n-1行</td>
</tr>
<tr>
<td>dnl</td>
<td>向右删除n个字母</td>
</tr>
<tr>
<td>dnh</td>
<td>向左删除n个字母</td>
</tr>
<tr>
<td>dnj</td>
<td>向下删除n行,当前行+其上n行</td>
</tr>
<tr>
<td>dnk</td>
<td>向上删除n行,当期行+其下n行</td>
</tr>
<tr>
<td>cnw[word]</td>
<td>将n个word改变为word</td>
</tr>
<tr>
<td>C$</td>
<td>改变到行尾</td>
</tr>
<tr>
<td>cc</td>
<td>改变整行</td>
</tr>
<tr>
<td>shift+j</td>
<td>删除行尾的换行符，下一行接上来了</td>
</tr>
</tbody>
</table>
<h1 id="复制粘贴">复制粘贴</h1>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>p</td>
<td>粘贴用x或d删除的文本</td>
</tr>
<tr>
<td>ynw</td>
<td>复制n个单词</td>
</tr>
<tr>
<td>yy</td>
<td>复制一行</td>
</tr>
<tr>
<td>ynl</td>
<td>复制n个字符</td>
</tr>
<tr>
<td>y$</td>
<td>复制当前光标至行尾处</td>
</tr>
<tr>
<td>nyy</td>
<td>拷贝n行</td>
</tr>
</tbody>
</table>
<h1 id="撤销">撤销</h1>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>u</td>
<td>撤销前一次的操作</td>
</tr>
<tr>
<td>shif+u(U)</td>
<td>撤销对该行的所有操作</td>
</tr>
</tbody>
</table>
<h1 id="搜索及替换">搜索及替换</h1>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>/pattern</td>
<td>从光标开始处向文件尾搜索pattern</td>
</tr>
<tr>
<td>?pattern</td>
<td>从光标开始处向文件首搜索pattern</td>
</tr>
<tr>
<td>n</td>
<td>在同一方向重复上一次搜索命令</td>
</tr>
<tr>
<td>N</td>
<td>在反方向上重复上一次搜索命令</td>
</tr>
<tr>
<td>cw newword</td>
<td>替换为newword</td>
</tr>
<tr>
<td>n</td>
<td>继续查找</td>
</tr>
<tr>
<td>.</td>
<td>执行替换</td>
</tr>
<tr>
<td><code>:s</code>/p1/p2/g</td>
<td>将当前行中所有p1均用p2替代,g表示执行 用c表示需要确认</td>
</tr>
<tr>
<td>:n1,n2 s/p1/p2/g</td>
<td>将第n1至n2行中所有p1均用p2替代</td>
</tr>
<tr>
<td>:g/p1/s//p2/g</td>
<td>将文件中所有p1均用p2替换</td>
</tr>
<tr>
<td>:1,$ s/string1/string2/g</td>
<td>在全文中将string1替换为string2</td>
</tr>
</tbody>
</table>
<h1 id="书签">书签</h1>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>m[a-z]</td>
<td>在文中做标记，标记号可为a-z的26个字母</td>
</tr>
<tr>
<td>`a</td>
<td>移动到标记a处</td>
</tr>
</tbody>
</table>
<h1 id="visual-模式">visual 模式</h1>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>v</td>
<td>进入visual 模式</td>
</tr>
<tr>
<td>V</td>
<td>进入行的visual 模式</td>
</tr>
<tr>
<td>ctrl+v</td>
<td>进如块操作模式用o和O改变选择的边的大小</td>
</tr>
<tr>
<td>在所有行插入相同的内容如include&lt;</td>
<td>将光标移到开始插入的位置，按CTRL+V进入VISUAL模式，选择好模块后按I（shift+i)，后插入要插入的文本，按[ESC]完成</td>
</tr>
</tbody>
</table>
<h1 id="行方式命令">行方式命令</h1>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>:n1,n2 co n3</td>
<td>将n1行到n2行之间的内容拷贝到第n3行下</td>
</tr>
<tr>
<td>:n1,n2 m n3</td>
<td>将n1行到n2行之间的内容移至到第n3行下</td>
</tr>
<tr>
<td>:n1,n2 d</td>
<td>将n1行到n2行之间的内容删除</td>
</tr>
<tr>
<td>:n1,n2 w!command</td>
<td>将文件中n1行至n2行的内容作为command的输入并执行之</td>
</tr>
<tr>
<td></td>
<td>若不指定n1，n2，则表示将整个文件内容作为command的输入</td>
</tr>
</tbody>
</table>
<h1 id="宏">宏</h1>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>q[a-z]</td>
<td>开始记录但前开始的操作为宏，名称可为【a-z】，然后用q终止录制宏</td>
</tr>
<tr>
<td>reg</td>
<td>显示当前定义的所有的宏，用@[a-z]来在当前光标处执行宏[a-z]</td>
</tr>
</tbody>
</table>
<h1 id="窗口操作">窗口操作</h1>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>:split</td>
<td>分割一个窗口</td>
</tr>
<tr>
<td>:split file.c</td>
<td>为另一个文件file.c分隔窗口</td>
</tr>
<tr>
<td>:nsplit file.c</td>
<td>为另一个文件file.c分隔窗口，并指定其行数</td>
</tr>
<tr>
<td>ctrl＋w</td>
<td>在窗口中切换</td>
</tr>
<tr>
<td>:close</td>
<td>关闭当前窗口</td>
</tr>
</tbody>
</table>
<h1 id="文件及其他">文件及其他</h1>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>:q</td>
<td>退出vi</td>
</tr>
<tr>
<td>:q!</td>
<td>不保存文件并退出vi</td>
</tr>
<tr>
<td>:e filename</td>
<td>打开文件filename进行编辑</td>
</tr>
<tr>
<td>:e!</td>
<td>放弃修改文件内容，重新载入该文件编辑</td>
</tr>
<tr>
<td>:w</td>
<td>保存当前文件</td>
</tr>
<tr>
<td>:wq</td>
<td>存盘退出</td>
</tr>
<tr>
<td>:ZZ</td>
<td>保存当前文档并退出VIM</td>
</tr>
<tr>
<td>:!command</td>
<td>执行shell命令command</td>
</tr>
<tr>
<td>:r!command</td>
<td>将命令command的输出结果放到当前行</td>
</tr>
<tr>
<td>:n1,n2 write temp.c</td>
<td></td>
</tr>
<tr>
<td>:read file.c</td>
<td>将文件file.c的内容插入到当前光标所在的下面</td>
</tr>
</tbody>
</table>
<h1 id="几张图">几张图</h1>
<h2 id="vim-工作模式">vim 工作模式</h2>
<figure data-type="image" tabindex="1"><img src="https://tdmaker.github.io/faded//post-images/1586406218928.png" alt="" loading="lazy"></figure>
<h2 id="vim-快捷键盘图">vim 快捷键盘图</h2>
<figure data-type="image" tabindex="2"><img src="https://tdmaker.github.io/faded//post-images/1586406168852.png" alt="" loading="lazy"></figure>
<h2 id="vim-快捷键思维导图">vim 快捷键思维导图</h2>
<figure data-type="image" tabindex="3"><img src="https://tdmaker.github.io/faded//post-images/1586406194722.png" alt="" loading="lazy"></figure>
<h2 id="vimium-快捷键盘图">vimium 快捷键盘图</h2>
<figure data-type="image" tabindex="4"><img src="https://tdmaker.github.io/faded//post-images/1586406592455.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[区块链——商用调查]]></title>
        <id>https://tdmaker.github.io/faded/post/blockchain-commercial-survey/</id>
        <link href="https://tdmaker.github.io/faded/post/blockchain-commercial-survey/">
        </link>
        <updated>2020-04-08T07:36:36.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p><a href="https://cloud.tencent.com/developer/article/1082599">区块链商用调查</a></p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p><a href="https://cloud.tencent.com/developer/article/1082599">区块链商用调查</a></p>
</blockquote>
<!-- more -->
<h1 id="1-信息共享信息对齐-提高效率">1 信息共享——信息对齐、提高效率</h1>
<p>这应该是区块链最简单的应用场景，就是信息互通有无。</p>
<h2 id="11-传统的信息共享的痛点">1.1 传统的信息共享的痛点</h2>
<ol>
<li>要么是统一由一个中心进行信息发布和分发，要么是彼此之间定时批量对账（典型的每天一次），对于有时效性要求的信息共享，难以达到实时共享。</li>
<li>信息共享的双方缺少一种相互信任的通信方式，难以确定收到的信息是否是对方发送的。</li>
</ol>
<h2 id="12-区块链-信息共享">1.2 区块链 + 信息共享</h2>
<p>首先，区块链本身就是需要保持各个节点的数据一致性的，可以说是自带信息共享功能；其次，实时的问题通过区块链的 P2P 技术可以实现；最后，利用区块链的不可篡改和共识机制，可构建其一条安全可靠的信息共享通道。<br>
也行你会有这样的疑问：解决上面的问题，不用区块链技术，我自己建个加密通道也可以搞定啊！但我想说，既然区块链技术能够解决这些问题，并且增加节点非常方便，在你没有已经建好一套安全可靠的信息共享系统之前，为什么不用区块链技术呢？</p>
<h1 id="2-版权保护不可篡改-永久保存">2 版权保护——不可篡改、永久保存</h1>
<h2 id="21-传统鉴证证明的痛点">2.1 传统鉴证证明的痛点</h2>
<ol>
<li>流程复杂：以版权保护为例，现有鉴证证明方式，登记时间长，且费用高。</li>
<li>公信力不足：以法务存证为例，个人或中心化的机构存在篡改数据的可能，公信力难以得到保证。</li>
</ol>
<h2 id="22-区块链-鉴证证明">2.2 区块链 + 鉴证证明</h2>
<ol>
<li>流程简化：区块链应用到鉴证证明后，无论是登记还是查询都非常方便，无需再奔走于各个部门之间，</li>
<li>安全可靠：区块链的去中心化存储，保证没有一家机构可以任意篡改数据，</li>
</ol>
<h2 id="23-应用案例">2.3 应用案例</h2>
<p>区块链在鉴权证明领域的应用有版权保护、法务存证等，下面以版权保护为例，简单说下如何区块链如何实现版权登记和查询。</p>
<ol>
<li>电子身份证：将“申请人+发布时间+发布内容”等版权信息加密后上传，版权信息用于唯一区块链 ID，相当拥有了一张电子身份证。</li>
<li>时间戳保护：版权信息存储时，是加上时间戳信息的，如右雷同，可用于证明先后。</li>
<li>可靠性保证：区块链的去中心化存储、私钥签名、不可篡改的特性提升了鉴权信息的可靠性。</li>
</ol>
<p>2016 年 8 月，由 Onchain、微软（中国）、法大大等多个机构在北京成立了电子存证区块链联盟“法链”。</p>
<p>2017 年 12 月，微众银行、仲裁委（广州仲裁委）、杭州亦笔科技有限公司共同推出的仲裁联盟链，用于司法场景下的存证；2018 年 3 月，广州首个“仲裁链”判决书出炉。</p>
<h1 id="3-物流链溯源防伪">3 物流链——溯源防伪</h1>
<p><img src="https://tdmaker.github.io/faded//post-images/1586332032829.png" alt="" loading="lazy"><br>
商品从生产商到消费者手中，需要经历多个环节（流程可能如上图所示），跨境购物则更加复杂；中间环节经常出问题，消费者很容易购买的假货。而假货问题正是困扰着各大商家和平台，至今无解。</p>
<h2 id="31-传统是防伪溯源手段">3.1 传统是防伪溯源手段</h2>
<p>以一直受假冒伪劣产品困扰的茅台酒的防伪技术为例，2000 年起，其酒盖里有一个唯一的 RFID 标签，可通过手机等设备以 NFC 方式读出，然后通过茅台的 APP 进行校验，以此防止伪造产品。<br>
咋一看，这种防伪效果非常可靠。但 2016 年还是引爆了茅台酒防伪造假，虽然通过 NFC 方式验证 OK，但经茅台专业人士鉴定为假酒。后来，在“国酒茅台防伪溯源系统”数据库审计中发现 80 万条假的防伪标签记录，系防伪技术公司人员参与伪造；随后，茅台改用安全芯片防伪标签。</p>
<p>但这里暴露出来的痛点并没有解决，即防伪信息掌握在某个中心机构中，有权限的人可以任意修改。(备注：茅台的这种防伪方式，也衍生了旧瓶回收，旧瓶装假酒的产业，防伪道路任重而道远)。</p>
<p>2017 年 05 月贵阳数博会上，小马哥就建议茅台防伪使用区块链；那么区块链和物流链的结合有什么优势呢？</p>
<h2 id="32-区块链物流链">3.2 区块链+物流链</h2>
<ol>
<li>区块链没有中心化节点，各节点是平等的，掌握单个节点无法实现修改数据；需要掌控足够多的节点，才可能伪造数据，大大提高伪造数据的成本。</li>
<li>区块链天生的开放、透明，使得任何人都可以公开查询，伪造数据被发现的概率大增。</li>
<li>区块链的数据不可篡改性，也保证了已销售出去的产品信息已永久记录，无法通过简单复制防伪信息蒙混过关，实现二次销售。</li>
<li>物流链的所有节点上区块链后，商品从生产商到消费者手里都有迹可循，形成完整链条；商品缺失的环节越多，将暴露出其是伪劣产品概率更大。</li>
</ol>
<p>##3.3 应用案例<br>
目前，入局物流链的玩家较多，包括腾讯、阿里、京东、沃尔玛等。</p>
<p>据说，阿里的菜鸟在海淘进口应用区块链上，走在了前面，已经初步实现海外商品溯源，国际物流及进口申报溯源、境内物流溯源；下一步就是生产企业溯源了。下图是网上流传的关于阿里的菜鸟在海淘场景运用区块链的示意图。<br>
<img src="https://tdmaker.github.io/faded//post-images/1586332241430.jpg" alt="" loading="lazy"></p>
<h1 id="4-供应链金融解决中小微企业融资难">4 供应链金融——解决中小微企业融资难</h1>
<h2 id="41-传统的供应链单点融资">4.1 传统的供应链单点融资</h2>
<p>在一般供应链贸易中，从原材料的采购、加工、组装到销售的各企业间都涉及到资金的支出和收入，而企业的资金支出和收入是有时间差的，这就形成了资金缺口，多数需要进行融资生产。我们先来看个简单的供应链，如下图：<br>
<img src="https://tdmaker.github.io/faded//post-images/1586332350132.png" alt="" loading="lazy"><br>
我们再来看看图中各个角色的融资情况：</p>
<ol>
<li>核心企业或大企业：规模大、信用好，议价能力强，通过先拿货后付款，延长账期将资金压力传导给后续供应商；此外，其融资能力也是最强的。</li>
<li>一级供应商：通过核心企业的债权转让，可以获得银行的融资。</li>
<li>其他供应商（多数是中小微企业）：规模小、发展不稳定、信用低，风险高，难以获得银行的贷款；也无法想核心企业一样有很长的账期；一般越小的企业其账期越短，微小企业还需要现金拿货。这样一出一入对比就像是：中小微企业无息借钱给大企业做生意。</li>
</ol>
<h2 id="42-区块链-供应链金融">4.2 区块链 + 供应链金融</h2>
<p>面对，上述供应链里的中小微企业融资难问题，主要原因是银行和中小企业之间缺乏一个有效的信任机制。</p>
<p>假如供应链所有节点上链后，通过区块链的私钥签名技术，保证了核心企业等的数据可靠性；而合同、票据等上链，是对资产的数字化，便于流通，实现了价值传递。<br>
<img src="https://tdmaker.github.io/faded//post-images/1586332493469.png" alt="" loading="lazy"><br>
如上图所示，在区块链解决了数据可靠性和价值流通后，银行等金融机构面对中小企业的融资，不再是对这个企业进行单独评估；而是站在整个供应链的顶端，通过信任核心企业的付款意愿，对链条上的票据、合同等交易信息进行全方位分析和评估。即借助核心企业的信用实力以及可靠的交易链条，为中小微企业融资背书，实现从单环节融资到全链条融资的跨越，从而缓解中小微企业融资难问题。</p>
<h1 id="5-跨境支付提高效率-降低费用">5 跨境支付——提高效率、降低费用</h1>
<h2 id="51-传统跨境支付">5.1 传统跨境支付</h2>
<p><img src="https://tdmaker.github.io/faded//post-images/1586332579435.png" alt="" loading="lazy"><br>
跨境支付涉及多种币种，存在汇率问题，传统跨境支付非常依赖于第三方机构，大致的简化模型如上图所示，存在着两个问题；</p>
<ol>
<li>流程繁琐，结算周期长：传统跨境支付基本都是非实时的，银行日终进行交易的批量处理，通常一笔交易需要 24 小时以上才能完成；某些银行的跨境支付看起来是实时的，但实际上，是收款银行基于汇款银行的信用做了一定额度的垫付，在日终再进行资金清算和对账，业务处理速度慢。</li>
<li>手续费高：传统跨境支付模式存在大量人工对账操作，加之依赖第三方机构，导致手续费居高不下，麦肯锡《2016 全球支付》报告数据显示，通过代理行模式完成一笔跨境支付的平均成本在 25 美元到 35 美元之间。</li>
</ol>
<h2 id="52-区块链-跨境支付">5.2 区块链 + 跨境支付</h2>
<p>这些问题的存在，很大原因还是信息不对称，没有建立有效的信任机制。<br>
<img src="https://tdmaker.github.io/faded//post-images/1586332873742.png" alt="" loading="lazy"><br>
如上图所示，区块链的引入，解决了跨境支付信息不对称的问题，并建立起一定程度的信任机制；带来了两个好处。</p>
<ol>
<li>效率提高，费用降低：接入区块链技术后，通过公私钥技术，保证数据的可靠性，再通过加密技术和去中心，达到数据不可篡改的目的，最后，通过 P2P 技术，实现点对点的结算；去除了传统中心转发，提高了效率，降低了成本(也展望了普及跨境小额支付的可能性)。</li>
<li>可追溯，符合监管需求：传统的点对点结算不能不规模应用，除了信任问题，还有就是存在监管漏洞（点对点私下交易，存在洗黑钱的风险），而区块链的交易透明，信息公开，交易记录永久保存实现了可追溯，符合监管的需求。</li>
</ol>
<h1 id="6-资产数字化便于资产流通">6 资产数字化——便于资产流通</h1>
<h2 id="61-实体资产存在的问题">6.1 实体资产存在的问题</h2>
<ol>
<li>实体资产往往难以分割，不便于流通</li>
<li>实体资产的流通难以监控，存在洗黑钱等风险</li>
</ol>
<h2 id="62-区块链实现资产数字化">6.2 区块链实现资产数字化</h2>
<ol>
<li>资产数字化后，易于分割、流通方便，交易成本低</li>
<li>用区块链技术实现资产数字化后，所有资产交易记录公开、透明、永久存储、可追溯，完全符合监管需求</li>
</ol>
<h2 id="63-应用案例">6.3 应用案例</h2>
<p>还是以腾讯的微黄金应用为例，继续借用腾讯区块链官网（trustsql.qq.com）上的图片，可以看到，在资产数字化之后，流通更为方便了，不再依赖于发行机构；且购买 0.001g 黄金成为了可能，降低了参与门槛。<br>
<img src="https://tdmaker.github.io/faded//post-images/1586333034775.png" alt="" loading="lazy"></p>
<h1 id="7-代币去中介-去信任">7 代币——去中介、去信任</h1>
<p>本来不像把代币加进来的，但说到区块链，始终绕不开代币；因区块链脱胎于比特币，天生具有代币的属性，目前区块链最成功的应用也正是比特币。</p>
<h2 id="71-传统货币存在的问题">7.1 传统货币存在的问题</h2>
<ol>
<li>传统的货币发行权掌握在国家手中，存在着货币滥发的风险
<ul>
<li>货币滥发案例 1：元朝自 1271 年建立后，依然四处征战，消耗大量的钱财和粮食，为了财政问题，长期滥发货币，造成严重通货膨胀，多数百姓生活在水生火热中，导致流民四起，国家大乱，1368 年，不可一世的元朝成了只有 97 年短命鬼，走向了灭亡。</li>
<li>货币滥发案例 2：1980 年津巴布韦独立，后因土改失败，经济崩溃，政府入不敷出，开始印钞；2001 年时 100 津巴布韦币可兑换约 1 美元；2009 年 1 月，津央行发行 100 万亿面值新津元（如下图）加速货币崩溃，最终津元被废弃，改用“美元化”货币政策。2017 年津巴布韦发生政变，总统穆加贝被赶下台。</li>
</ul>
</li>
</ol>
<figure data-type="image" tabindex="1"><img src="https://tdmaker.github.io/faded//post-images/1586333225353.png" alt="" loading="lazy"></figure>
<ol start="2">
<li>传统的记账权掌握在一个中心化的中介机构手中，存在中介系统瘫痪、中介违约、中介欺瞒、甚至是中介耍赖等风险。<br>
2013 年 3 月，塞浦路斯为获得救助，对银行储户进行一次性征税约 58 亿欧元, 向不低于 10 万欧元的存款一次性征税 9.9%，向低于 10 万欧元的一次性征税 6.75%。<br>
2017 年 4 月，民生银行 30 亿假理财事件暴露，系一支行行长伪造保本保息理财产品所致，超过 150 名投资者被套。</li>
</ol>
<h2 id="72-区块链如何解决这些问题">7.2 区块链如何解决这些问题</h2>
<p><img src="https://tdmaker.github.io/faded//post-images/1586334038696.png" alt="" loading="lazy"><br>
比特币解决了货币在发行和记账环节的信任问题，我们来看下比特币是如何一一破解上面的两个问题。</p>
<h3 id="721-滥发问题">7.2.1 滥发问题</h3>
<p>比特币的获取只能通过挖矿获得，且比特币总量为 2100 万个，在发行环节解决了货币滥发的问题；</p>
<h3 id="722-账本修改问题">7.2.2 账本修改问题</h3>
<p>比特币的交易记录通过链式存储和去中心化的全球节点构成网络来解决账本修改问题。</p>
<h3 id="723-链式存储">7.2.3 链式存储</h3>
<p>可以简单理解为：存储记录的块是一块连着一块的，形成一个链条；除第一个块的所有区块都的记录包含了前一区块的校验信息，改变任一区块的信息，都将导致后续区块校验出错。因为这种关联性，中间也无法插入其他块，所以修改已有记录是困难的。</p>
<h3 id="724-去中心化节点">7.2.4 去中心化节点</h3>
<p>可以简单理解为：全球的中心节点都是平等的，都拥有一模一样的账本，所以，任一节点出问题都不影响账本记录。而要修改账本，必须修改超过全球一半的节点才能完成；而这在目前看来几乎不可能。</p>
<p>既然账本无法修改，那要是记账的时候作弊呢？</p>
<p>首先，比特币的每条交易记录是有私钥签名的，别人伪造不了这个记录。你能修改的仅仅自己发起的交易记录。</p>
<p>其次，是关于记账权问题：比特币的记账权，通过工作量证明获得，可以简单理解为：通过算法确定同一时刻，全球只有一个节点获得了记账权，基本规律是谁拥有的计算资源越多，谁获得记账权的概率越大，只有超过全网一半的算力，才可能实现双花。</p>
<h3 id="725-备注">7.2.5 备注</h3>
<p>比特币的模式是不可复制的，比特币已经吸引了全球绝大多数的算力，从而降低 51% 攻击发生等问题；其他的复制品基本无法获得相应的算力保证。</p>
<p>目前，比特币还存在着 51% 和效率低等问题有待解决，另外，关于交易本身的信任问题是个社会问题，比特币是没有解决的，也解决不了的。</p>
<h2 id="73-应用案例">7.3 应用案例</h2>
<p>最具代表性的当然是比特币，也不用多说了。</p>
<p>备注：代币这块真的不看好，比特币目前吸引了全球绝大部分的算力，有独一无二的算力资源作为支撑还稍好一点，其他的代币和传统的货币相比，其背后缺乏国家和武力为其做信用背书，且夺取了国家发币带来的各种好处（如宏观调控），仔细想想就知道有多不靠谱。</p>
<h1 id="8-小结">8 小结</h1>
<p>区块链应用的场景肯定还有很多，但很多都还不大明朗，暂时就先梳理以上7种场景，顺便归纳一下。<br>
<img src="https://tdmaker.github.io/faded//post-images/1586334430353.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[区块链——行业名词]]></title>
        <id>https://tdmaker.github.io/faded/post/blockchain-profession-words/</id>
        <link href="https://tdmaker.github.io/faded/post/blockchain-profession-words/">
        </link>
        <updated>2020-04-08T05:03:09.000Z</updated>
        <content type="html"><![CDATA[<table>
<thead>
<tr>
<th>名称</th>
<th>中文</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>2-Way Peg</td>
<td>双向锚定</td>
<td>一种跨链技术</td>
</tr>
<tr>
<td>ABI</td>
<td>智能合约的接口说明</td>
<td>Application Binary Interface，ABI 是以太坊的一种合约间调用的消息格式，类似于 WebService 的 SOAP 协议一样，也就是定义操作函数签名，参数编码，返回结果编码等的协议。</td>
</tr>
<tr>
<td>altcoin</td>
<td>山寨币</td>
<td></td>
</tr>
<tr>
<td>AML</td>
<td>反洗钱</td>
<td>Anti-Money Laundering</td>
</tr>
<tr>
<td>ASIC</td>
<td>专用集成电路</td>
<td>Application Specific Integrated Circuit，通常，与 GPU 相比，ASIC 专门用于挖矿，可能会节省大量能源。</td>
</tr>
<tr>
<td>autonomous</td>
<td>自治</td>
<td></td>
</tr>
<tr>
<td>BAAS</td>
<td>区块链服务</td>
<td>Blockchain As A Service，区块链即服务。</td>
</tr>
<tr>
<td>BIP</td>
<td>比特币改进建议</td>
<td>Bitcoin Improvement Proposals</td>
</tr>
<tr>
<td>Block</td>
<td>区块</td>
<td>用于记录区块链系统中数据的存储。</td>
</tr>
<tr>
<td>Block Explorer</td>
<td>区块资源管理器</td>
<td>区块资源管理器是一种用来来查看区块上的所有交易（过去和当前）在线工具。 它们提供有用的信息，如网络哈希率和交易增长率。</td>
</tr>
<tr>
<td>Block Height</td>
<td>区块高度</td>
<td>连接在区块链上的块数。</td>
</tr>
<tr>
<td>Block Reward</td>
<td>出块奖励</td>
<td>它是在采矿期间成功计算区块中的哈希的矿工的一种激励形式。 在区块链上的交易验证的过程中产生新的币，并且矿工被奖励其中的一部分。</td>
</tr>
<tr>
<td>Blockchain</td>
<td>区块链</td>
<td>分布式存储、加密算法、共识机制、P2P传输等计算机技术结合的新型应用模式。</td>
</tr>
<tr>
<td>Blockchain Wallet</td>
<td>区块链钱包</td>
<td>一个包含私钥的文件。 它通常包含一个软件客户端，允许访问查看和创建钱包所设计的特定块链的交易。</td>
</tr>
<tr>
<td>Bulletproofs</td>
<td>Bulletproofs</td>
<td>由斯坦福大学提出的，把膨胀系数减少到普通交易的三倍（原来是 60 倍），可以大幅降低隐私交易的数据量大小的算法</td>
</tr>
<tr>
<td>CAP</td>
<td>CAP</td>
<td>分布式异步网络模型中，不能同时保证**一致性**，**可用性**和**分区容错性**，只能三选二</td>
</tr>
<tr>
<td>Central Ledger</td>
<td>中央帐簿</td>
<td>由中央机构维持的分类帐。</td>
</tr>
<tr>
<td>Chain</td>
<td>链</td>
<td>区块头中通过引用哈希值链接。</td>
</tr>
<tr>
<td>Confirmation</td>
<td>确认</td>
<td>去中心化的一次交易，将其添加到 blockchain 的成功确认。</td>
</tr>
<tr>
<td>Consensus</td>
<td>共识机制</td>
<td>区块链中事务达成的分布式共识算法。</td>
</tr>
<tr>
<td>Consensus</td>
<td>共识</td>
<td>当所有网络参与者同意交易的有效性时，达成共识，确保分布式账本是彼此的精确副本。</td>
</tr>
<tr>
<td>Consortium Block Chains</td>
<td>联盟链</td>
<td>共识过程由预选节点控制，一般为各企业机构互联形成。</td>
</tr>
<tr>
<td>Corda</td>
<td>Corda</td>
<td>R3联盟推出的金融联盟“类区块链”技术架构，Corda 中同样是用交易组成账本，但并没有区块，交易仅在参与方和公证人间传播</td>
</tr>
<tr>
<td>Cryptocurrency</td>
<td>加密货币</td>
<td>也称为令牌，加密货币是数字资产的呈现方式。</td>
</tr>
<tr>
<td>Cryptographic Hash Function</td>
<td>加密哈希函数</td>
<td>密码哈希产生从可变大小交易输入固定大小和唯一哈希值。 SHA-256计算算法是加密散列的一个例子。</td>
</tr>
<tr>
<td>DAO</td>
<td>去中心化自治组织</td>
<td>Decentralized Autonomous Organizations，去中心化自治组织可以被认为是在没有任何人为干预的情况下运行的公司，并将一切形式的控制交给一套不可破坏的业务规则。</td>
</tr>
<tr>
<td>Dapp</td>
<td>去中心化应用</td>
<td>是一种开源的应用程序，自动运行，将其数据存储在区块链上，以密码令牌的形式激励，并以显示有价值证明的协议进行操作。</td>
</tr>
<tr>
<td>DD</td>
<td>尽职调查</td>
<td>Due Diligence</td>
</tr>
<tr>
<td>Decentralized</td>
<td>分布式</td>
<td>不依赖中心服务器，分布的计算机资源进行计算处理的模式。</td>
</tr>
<tr>
<td>Difficulty</td>
<td>挖矿难度</td>
<td>这是指成功挖掘交易信息的数据块的容易程度。</td>
</tr>
<tr>
<td>Distributed Ledger</td>
<td>分布式账本</td>
<td>分布式账本，数据通过分布式节点网络进行存储。 分布式账本不是必须具有自己的货币，它可能会被许可和私有。</td>
</tr>
<tr>
<td>Distributed Network</td>
<td>分布式网络</td>
<td>处理能力和数据分布在节点上而不是拥有集中式数据中心的一种网络。</td>
</tr>
<tr>
<td>Double Spending</td>
<td>双重支付</td>
<td>当花费一笔钱多于一次支付限额时，就会发生双重支付。</td>
</tr>
<tr>
<td>DPoS</td>
<td>委托权益证明</td>
<td>Delegated Proof Of Stake，一种共识算法</td>
</tr>
<tr>
<td>EIP</td>
<td>以太坊改进建议</td>
<td>Ethereum Improvement Proposals</td>
</tr>
<tr>
<td>EOA</td>
<td>外部账户</td>
<td>Externally Owned Accounts</td>
</tr>
<tr>
<td>ERC</td>
<td>以太坊意见征求</td>
<td>Ethereum Requests for Comment，讨论项目时，一开始会用EIP提出建议，在讨论过程中有一些要征求更多人意见时，就会把细节放在ERC中，而且他们会用同一个号码，比如ERC-20 对应 EIP-20</td>
</tr>
<tr>
<td>Ethash</td>
<td>Ethash</td>
<td>以前这个算法称为 Dagger Hashimoto，Ethash是最新版本的 Dagger-Hashimoto 改良算法，是 Hashimoto 算法结合 Dagger 算法产成的一个新变种。实现两个主要目的：抵抗 ASIC 矿机和轻客户端易验证</td>
</tr>
<tr>
<td>Ethereum</td>
<td>以太坊</td>
<td>Ethereum是一个基于blockchain的去中心化运行智能合约的平台，旨在解决与审查，欺诈和第三方干扰相关的问题。</td>
</tr>
<tr>
<td>EVM</td>
<td>以太坊虚拟机</td>
<td>Ethereum Virtual Machine，借助以太坊虚拟机将 Solidity 代码变成可以在区块链上执行的加密代码。以太坊虚拟机是设计运行在点对点网络中所有参与节点上的一个虚拟机，它可以读写一个区块链中可执行的代码和数据，校验数据签名，并以半图灵完备的方式来运行代码。每个Ethereum节点都运行在 EVM 上，以保持整个块链的一致性。</td>
</tr>
<tr>
<td>FLP</td>
<td>FLP</td>
<td>在网络可靠并且存在节点失效的异步模型中，不存在一个可以解决一致性问题的确定性算法</td>
</tr>
<tr>
<td>Fork</td>
<td>分叉</td>
<td>分叉可以创建区块链的交叉版本，在网络不同的地方兼容的运行两个区块链。</td>
</tr>
<tr>
<td>Frontier</td>
<td>前沿</td>
<td>以太坊开发第一阶段</td>
</tr>
<tr>
<td>gas</td>
<td>gas</td>
<td>gas是在以太坊网络中用于衡量执行交易或智能合约工作量的计算单位</td>
</tr>
<tr>
<td>gas limit</td>
<td>gas limit</td>
<td>某笔具体的交易能够消耗的 gas 最大值，一笔标准的以太坊交易需要 21,000 gas。当交易的 gas limit 不足时，会出现 out of gas 错误</td>
</tr>
<tr>
<td>gas price</td>
<td>gas price</td>
<td>以另一种货币或 token（例如 Ether）计量交易花费的价格。为了稳定消耗 gas 的价值，gas price 是浮动的，根据货币或 token 价格浮动而相应变动以保持总价格稳定。gas price 由市场供需决定（用户愿意支出的价格和矿工节点愿意接受的价格的博弈）</td>
</tr>
<tr>
<td>gas used</td>
<td>gas used</td>
<td>有效支付用于计算或智能合约运行的 gas 数量（在成功的交易中 gas fee 小于 gas limit)，一笔以太坊交易的实际矿工费(Tx Fees) = gas used * gas price</td>
</tr>
<tr>
<td>Genesis Block</td>
<td>创世区块</td>
<td>区块链的第一个区块。</td>
</tr>
<tr>
<td>Go Ethereum</td>
<td>geth</td>
<td>实现了以太坊协议的 JavaScript运行时环境，可以以交互式或非交互式模式运行</td>
</tr>
<tr>
<td>Hard Fork</td>
<td>硬分叉</td>
<td>区块链发生永久性分歧，在新共识规则发布后，部分没有升级的节点无法验证已经升级的节点生产的区块，产生硬分叉。</td>
</tr>
<tr>
<td>Hash</td>
<td>哈希</td>
<td>对输出数据执行散列函数的行为。 这是用于确认货币交易。</td>
</tr>
<tr>
<td>Hash Rate</td>
<td>哈希率</td>
<td>采矿钻机的性能测量值以秒为单位表示。</td>
</tr>
<tr>
<td>Homestead</td>
<td>家园</td>
<td>以太坊开发第二阶段</td>
</tr>
<tr>
<td>Hybrid PoS/PoW</td>
<td>混合PoS / PoW</td>
<td>混合 PoS / PoW 可以将网络上的共享分发算法作为共享证明和工作证明。 在这种方法中，可以实现矿工和选民（持有者）之间的平衡，由内部人（持有人）和外部人（矿工）创建一个基于社区的治理体系。</td>
</tr>
<tr>
<td>I2P</td>
<td>I2P</td>
<td>Invisible Internet Project，建立在互联网上的隐匿网络层，用于为网络通讯提供隐私保护</td>
</tr>
<tr>
<td>Infura</td>
<td>Infura</td>
<td>提供全球范围区块链集群和 API 端点等基础架构服务；可用于以太坊，IPFS 等其他新兴的分布式平台。致力于提供安全，稳定，高容错性金额可扩展的区块链访问接口</td>
</tr>
<tr>
<td>keccak</td>
<td>keccak</td>
<td>一种SHA-3加密算法</td>
</tr>
<tr>
<td>Kovri</td>
<td>Kovri</td>
<td>I2P 网络的 C++ 实现版本，目前还在开发中尚未集成到门罗币中，可以提高交易的安全等级（可以隐藏 IP 地址）</td>
</tr>
<tr>
<td>KYC</td>
<td>了解你的客户</td>
<td>Know Your Customer</td>
</tr>
<tr>
<td>Metropolis</td>
<td>大都会</td>
<td>以太坊开发第三阶段</td>
</tr>
<tr>
<td>Mining</td>
<td>挖矿</td>
<td>挖矿是验证区块链交易的行为。 验证的必要性通常以货币的形式奖励给矿工。 在这个密码安全的繁荣期间，当正确完成计算，采矿可以是一个有利可图的业务。 通过选择最有效和最适合的硬件和采矿目标，采矿可以产生稳定的被动收入形式。</td>
</tr>
<tr>
<td>Multi-Signature</td>
<td>多重签名</td>
<td>多重签名地址需要一个以上的密钥来授权交易，从而增加了一层安全性。</td>
</tr>
<tr>
<td>Node</td>
<td>节点</td>
<td>由区块链网络的参与者操作的分类帐的副本。</td>
</tr>
<tr>
<td>Oracles</td>
<td>预言机</td>
<td>Oracle 通过向智能合约提供数据，它现实世界和区块链之间的桥梁。注意此 Oracle不是指数据库。预言机连接虚拟与现实，核心功能是提供数据上链服务，是实现智能合约的必要条件。智能合约是在区块链提供的沙盒环境中运行，沙盒是个封闭环境，使合约代码不能读取链外数据，但很多时候智能合约又必须依赖外部数据，Oracle 在这里就承担了提供外部数据的功能。</td>
</tr>
<tr>
<td>P2P</td>
<td>Peer-to-Peer</td>
<td>对等互联网网络技术。</td>
</tr>
<tr>
<td>Paxos</td>
<td>Paxos</td>
<td>一种用于传统分布式系统的共识协议</td>
</tr>
<tr>
<td>Payment Codes</td>
<td>可重用支付码</td>
<td>BIP47，支付码是一种用于创建永久性比特币地址的技术，这些地址可以重复使用，与现实生活中的身份公开相关，同时无损于财务隐私。它们类似于隐形地址。即使他人知道你的支付码也无法追踪你的交易历史，可以用于想要私密的接收BTC的场景</td>
</tr>
<tr>
<td>PBFT</td>
<td>实用拜占庭容错</td>
<td>Practical Byzantine Fault Tolerance</td>
</tr>
<tr>
<td>pegged zone</td>
<td>锚定分区</td>
<td>一种锚定分区的桥接机制，出现于Cosmos项目</td>
</tr>
<tr>
<td>POA</td>
<td>权威证明</td>
<td>Proof Of Authority，一种共识算法</td>
</tr>
<tr>
<td>portfolio</td>
<td>投资组合</td>
<td></td>
</tr>
<tr>
<td>POS</td>
<td>权益证明</td>
<td>Proof of Stake，根据你持有货币的量和时间进行利息分配的制度，在 POS 模式下，你的“挖矿”收益正比于你的币龄，而与电脑的计算性能无关。</td>
</tr>
<tr>
<td>POW</td>
<td>工作量证明</td>
<td>Proof of Work，是指获得多少货币，取决于你挖矿贡献的工作量，电脑性能越好，分给你的矿就会越多。</td>
</tr>
<tr>
<td>Private Block Chains</td>
<td>私有链</td>
<td>私有区块链，数据记录在单一组织机构中，分权限对外开放，一般是单一企业机构构建。</td>
</tr>
<tr>
<td>Private Key</td>
<td>私钥</td>
<td>私钥是一串数据，它是允许您访问特定钱包中的令牌。 它们作为密码，除了地址的所有者之外，都被隐藏。</td>
</tr>
<tr>
<td>Public Address</td>
<td>公用地址</td>
<td>公共地址是公钥的密码哈希值。 它们作为可以在任何地方发布的电子邮件地址，与私钥不同。</td>
</tr>
<tr>
<td>Public Block Chains</td>
<td>公有链</td>
<td>公共网络中任何个人团体接入，任何节点均可参与共识过程。</td>
</tr>
<tr>
<td>Raft</td>
<td>Raft</td>
<td>Paxos协议的一种简单实现</td>
</tr>
<tr>
<td>Ring Signatures</td>
<td>环签名</td>
<td>用于隐匿发送发信息的技术，门罗币采用</td>
</tr>
<tr>
<td>RingCT</td>
<td>环加密交易</td>
<td>Ring Confidential Transactions，隐藏交易信息（包括交易双方信息和交易金额）的加密技术，门罗币采用</td>
</tr>
<tr>
<td>RLP</td>
<td>RLP 编码</td>
<td>Recursive Length Prefix（递归长度前缀）是一种适用于任意二进制数据数组的编码。是以太坊中对象进行序列化/反序列化的主要编码方式。区块，交易等数据结构在持久化时会先经过RLP编码后再存储到持久层中。</td>
</tr>
<tr>
<td>RPCA</td>
<td>瑞波共识算法</td>
<td>Ripple Protocol Consensus Algorithm，类似PBFT的共识机制</td>
</tr>
<tr>
<td>Scrypt</td>
<td>Scrypt</td>
<td>是一种由 Litecoin 使用加密算法。 与 SHA256 相比，它的速度更快，因为它不会占用很多处理时间。</td>
</tr>
<tr>
<td>Serenity</td>
<td>宁静</td>
<td>以太坊开发第四阶段（也是最后一个阶段）</td>
</tr>
<tr>
<td>SHA-256</td>
<td>SHA-256</td>
<td>是比特币一些列数字货币使用的加密算法。 然而，它使用了大量的计算能力和处理时间，迫使矿工组建采矿池以获取收益。</td>
</tr>
<tr>
<td>Smart Contracts</td>
<td>智能合约</td>
<td>智能合约将可编程语言的业务规则编码到区块上，并由网络的参与者实施。部署在区块链系统中，一段合约代码，或一套以数字形式定义的承诺，包括合约参与方可以在其上执行承诺的协议。</td>
</tr>
<tr>
<td>Soft Fork</td>
<td>软分叉</td>
<td>软分叉与硬分叉不同之处在于，只有先前有效的交易才能使其无效。 由于旧节点将新的块识别为有效，所以软分叉基本上是向后兼容的。 这种分叉需要大多数矿工升级才能执行，而硬分叉需要所有节点就新版本达成一致。</td>
</tr>
<tr>
<td>Solidity</td>
<td>Solidity</td>
<td>是 Ethereum 用于开发智能合约的编程语言。</td>
</tr>
<tr>
<td>SPV</td>
<td>简单支付验证</td>
<td>Simplified Payment Verification</td>
</tr>
<tr>
<td>Stealth Address</td>
<td>隐匿地址</td>
<td>能够隐藏接收方信息</td>
</tr>
<tr>
<td>Swarm</td>
<td>Swarm</td>
<td>去中心化的数据存储访问协议，以 ETH 作为激励。类似使用了 Filecoin 的 IPFS</td>
</tr>
<tr>
<td>Sybil Attack</td>
<td>女巫攻击</td>
<td>P2P网络中的一种攻击形式：攻击者利用单个节点来伪造多个身份存在于 P2P 网络中，从而达到削弱网络的冗余性，降低网络健壮性，监视或干扰网络正常活动等目的</td>
</tr>
<tr>
<td>Testnet</td>
<td>Testnet</td>
<td>开发商使用的测试区块链，它主要是用来防止改变在主链上的资产。</td>
</tr>
<tr>
<td>testrpc</td>
<td>testrpc</td>
<td>以太坊节点客户端</td>
</tr>
<tr>
<td>Transaction Block</td>
<td>交易区块</td>
<td>聚集到一个块中的交易的集合，然后可以将其散列并添加到区块链中。</td>
</tr>
<tr>
<td>Transaction Fee</td>
<td>交易费</td>
<td>所有的加密货币交易都会涉及到一笔很小的手续费。这些手续费用加起来给矿工在成功处理区块时收到的区块奖励。</td>
</tr>
<tr>
<td>Truffle</td>
<td>Truffle</td>
<td>一个基于以太坊技术的开发、测试和部署框架，旨在帮助以太坊开发者更容易开发去中心化应用（DApp）</td>
</tr>
<tr>
<td>Turing Complete</td>
<td>图灵完备</td>
<td>图灵完备是指计算机中一切计算的问题都可以计算，这样的虚拟机或者编程语言称为图灵完备。一个例子是 Ethereum 虚拟机（EVM）。</td>
</tr>
<tr>
<td>Unlinkability</td>
<td>无关联性</td>
<td></td>
</tr>
<tr>
<td>whisper</td>
<td>whisper</td>
<td>去中心化的通信协议</td>
</tr>
<tr>
<td>YC</td>
<td>YC</td>
<td>Y Combinator，成立于 2005 年是美国著名创业孵化器，扶持初创企业并为其提供创业指南（Airbnb，Dropbox，Stripe，Reddit, Docker, Coinbase 等），投资孵化过多个区块链项目</td>
</tr>
<tr>
<td>ZKRP</td>
<td>零知识范围证明</td>
<td>Zero Knownledge Range Proof，证明一个具体声明的真实性而不会泄露它试图证明的额外信息</td>
</tr>
<tr>
<td>ZK-SNARKs</td>
<td>零知识证明</td>
<td>ZK-Succint Non-interactive Arguments of Knownledge</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[区块链——行业名词]]></title>
        <id>https://tdmaker.github.io/faded/post/qu-kuai-lian-xing-ye-ming-ci/</id>
        <link href="https://tdmaker.github.io/faded/post/qu-kuai-lian-xing-ye-ming-ci/">
        </link>
        <updated>2020-04-08T05:03:09.000Z</updated>
        <content type="html"><![CDATA[<table>
<thead>
<tr>
<th>名称</th>
<th>中文</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>2-Way Peg</td>
<td>双向锚定</td>
<td>一种跨链技术</td>
</tr>
<tr>
<td>ABI</td>
<td>智能合约的接口说明</td>
<td>Application Binary Interface，ABI 是以太坊的一种合约间调用的消息格式，类似于 WebService 的 SOAP 协议一样，也就是定义操作函数签名，参数编码，返回结果编码等的协议。</td>
</tr>
<tr>
<td>altcoin</td>
<td>山寨币</td>
<td></td>
</tr>
<tr>
<td>AML</td>
<td>反洗钱</td>
<td>Anti-Money Laundering</td>
</tr>
<tr>
<td>ASIC</td>
<td>专用集成电路</td>
<td>Application Specific Integrated Circuit，通常，与 GPU 相比，ASIC 专门用于挖矿，可能会节省大量能源。</td>
</tr>
<tr>
<td>autonomous</td>
<td>自治</td>
<td></td>
</tr>
<tr>
<td>BAAS</td>
<td>区块链服务</td>
<td>Blockchain As A Service，区块链即服务。</td>
</tr>
<tr>
<td>BIP</td>
<td>比特币改进建议</td>
<td>Bitcoin Improvement Proposals</td>
</tr>
<tr>
<td>Block</td>
<td>区块</td>
<td>用于记录区块链系统中数据的存储。</td>
</tr>
<tr>
<td>Block Explorer</td>
<td>区块资源管理器</td>
<td>区块资源管理器是一种用来来查看区块上的所有交易（过去和当前）在线工具。 它们提供有用的信息，如网络哈希率和交易增长率。</td>
</tr>
<tr>
<td>Block Height</td>
<td>区块高度</td>
<td>连接在区块链上的块数。</td>
</tr>
<tr>
<td>Block Reward</td>
<td>出块奖励</td>
<td>它是在采矿期间成功计算区块中的哈希的矿工的一种激励形式。 在区块链上的交易验证的过程中产生新的币，并且矿工被奖励其中的一部分。</td>
</tr>
<tr>
<td>Blockchain</td>
<td>区块链</td>
<td>分布式存储、加密算法、共识机制、P2P传输等计算机技术结合的新型应用模式。</td>
</tr>
<tr>
<td>Blockchain Wallet</td>
<td>区块链钱包</td>
<td>一个包含私钥的文件。 它通常包含一个软件客户端，允许访问查看和创建钱包所设计的特定块链的交易。</td>
</tr>
<tr>
<td>Bulletproofs</td>
<td>Bulletproofs</td>
<td>由斯坦福大学提出的，把膨胀系数减少到普通交易的三倍（原来是 60 倍），可以大幅降低隐私交易的数据量大小的算法</td>
</tr>
<tr>
<td>CAP</td>
<td>CAP</td>
<td>分布式异步网络模型中，不能同时保证**一致性**，**可用性**和**分区容错性**，只能三选二</td>
</tr>
<tr>
<td>Central Ledger</td>
<td>中央帐簿</td>
<td>由中央机构维持的分类帐。</td>
</tr>
<tr>
<td>Chain</td>
<td>链</td>
<td>区块头中通过引用哈希值链接。</td>
</tr>
<tr>
<td>Confirmation</td>
<td>确认</td>
<td>去中心化的一次交易，将其添加到 blockchain 的成功确认。</td>
</tr>
<tr>
<td>Consensus</td>
<td>共识机制</td>
<td>区块链中事务达成的分布式共识算法。</td>
</tr>
<tr>
<td>Consensus</td>
<td>共识</td>
<td>当所有网络参与者同意交易的有效性时，达成共识，确保分布式账本是彼此的精确副本。</td>
</tr>
<tr>
<td>Consortium Block Chains</td>
<td>联盟链</td>
<td>共识过程由预选节点控制，一般为各企业机构互联形成。</td>
</tr>
<tr>
<td>Corda</td>
<td>Corda</td>
<td>R3联盟推出的金融联盟“类区块链”技术架构，Corda 中同样是用交易组成账本，但并没有区块，交易仅在参与方和公证人间传播</td>
</tr>
<tr>
<td>Cryptocurrency</td>
<td>加密货币</td>
<td>也称为令牌，加密货币是数字资产的呈现方式。</td>
</tr>
<tr>
<td>Cryptographic Hash Function</td>
<td>加密哈希函数</td>
<td>密码哈希产生从可变大小交易输入固定大小和唯一哈希值。 SHA-256计算算法是加密散列的一个例子。</td>
</tr>
<tr>
<td>DAO</td>
<td>去中心化自治组织</td>
<td>Decentralized Autonomous Organizations，去中心化自治组织可以被认为是在没有任何人为干预的情况下运行的公司，并将一切形式的控制交给一套不可破坏的业务规则。</td>
</tr>
<tr>
<td>Dapp</td>
<td>去中心化应用</td>
<td>是一种开源的应用程序，自动运行，将其数据存储在区块链上，以密码令牌的形式激励，并以显示有价值证明的协议进行操作。</td>
</tr>
<tr>
<td>DD</td>
<td>尽职调查</td>
<td>Due Diligence</td>
</tr>
<tr>
<td>Decentralized</td>
<td>分布式</td>
<td>不依赖中心服务器，分布的计算机资源进行计算处理的模式。</td>
</tr>
<tr>
<td>Difficulty</td>
<td>挖矿难度</td>
<td>这是指成功挖掘交易信息的数据块的容易程度。</td>
</tr>
<tr>
<td>Distributed Ledger</td>
<td>分布式账本</td>
<td>分布式账本，数据通过分布式节点网络进行存储。 分布式账本不是必须具有自己的货币，它可能会被许可和私有。</td>
</tr>
<tr>
<td>Distributed Network</td>
<td>分布式网络</td>
<td>处理能力和数据分布在节点上而不是拥有集中式数据中心的一种网络。</td>
</tr>
<tr>
<td>Double Spending</td>
<td>双重支付</td>
<td>当花费一笔钱多于一次支付限额时，就会发生双重支付。</td>
</tr>
<tr>
<td>DPoS</td>
<td>委托权益证明</td>
<td>Delegated Proof Of Stake，一种共识算法</td>
</tr>
<tr>
<td>EIP</td>
<td>以太坊改进建议</td>
<td>Ethereum Improvement Proposals</td>
</tr>
<tr>
<td>EOA</td>
<td>外部账户</td>
<td>Externally Owned Accounts</td>
</tr>
<tr>
<td>ERC</td>
<td>以太坊意见征求</td>
<td>Ethereum Requests for Comment，讨论项目时，一开始会用EIP提出建议，在讨论过程中有一些要征求更多人意见时，就会把细节放在ERC中，而且他们会用同一个号码，比如ERC-20 对应 EIP-20</td>
</tr>
<tr>
<td>Ethash</td>
<td>Ethash</td>
<td>以前这个算法称为 Dagger Hashimoto，Ethash是最新版本的 Dagger-Hashimoto 改良算法，是 Hashimoto 算法结合 Dagger 算法产成的一个新变种。实现两个主要目的：抵抗 ASIC 矿机和轻客户端易验证</td>
</tr>
<tr>
<td>Ethereum</td>
<td>以太坊</td>
<td>Ethereum是一个基于blockchain的去中心化运行智能合约的平台，旨在解决与审查，欺诈和第三方干扰相关的问题。</td>
</tr>
<tr>
<td>EVM</td>
<td>以太坊虚拟机</td>
<td>Ethereum Virtual Machine，借助以太坊虚拟机将 Solidity 代码变成可以在区块链上执行的加密代码。以太坊虚拟机是设计运行在点对点网络中所有参与节点上的一个虚拟机，它可以读写一个区块链中可执行的代码和数据，校验数据签名，并以半图灵完备的方式来运行代码。每个Ethereum节点都运行在 EVM 上，以保持整个块链的一致性。</td>
</tr>
<tr>
<td>FLP</td>
<td>FLP</td>
<td>在网络可靠并且存在节点失效的异步模型中，不存在一个可以解决一致性问题的确定性算法</td>
</tr>
<tr>
<td>Fork</td>
<td>分叉</td>
<td>分叉可以创建区块链的交叉版本，在网络不同的地方兼容的运行两个区块链。</td>
</tr>
<tr>
<td>Frontier</td>
<td>前沿</td>
<td>以太坊开发第一阶段</td>
</tr>
<tr>
<td>gas</td>
<td>gas</td>
<td>gas是在以太坊网络中用于衡量执行交易或智能合约工作量的计算单位</td>
</tr>
<tr>
<td>gas limit</td>
<td>gas limit</td>
<td>某笔具体的交易能够消耗的 gas 最大值，一笔标准的以太坊交易需要 21,000 gas。当交易的 gas limit 不足时，会出现 out of gas 错误</td>
</tr>
<tr>
<td>gas price</td>
<td>gas price</td>
<td>以另一种货币或 token（例如 Ether）计量交易花费的价格。为了稳定消耗 gas 的价值，gas price 是浮动的，根据货币或 token 价格浮动而相应变动以保持总价格稳定。gas price 由市场供需决定（用户愿意支出的价格和矿工节点愿意接受的价格的博弈）</td>
</tr>
<tr>
<td>gas used</td>
<td>gas used</td>
<td>有效支付用于计算或智能合约运行的 gas 数量（在成功的交易中 gas fee 小于 gas limit)，一笔以太坊交易的实际矿工费(Tx Fees) = gas used * gas price</td>
</tr>
<tr>
<td>Genesis Block</td>
<td>创世区块</td>
<td>区块链的第一个区块。</td>
</tr>
<tr>
<td>Go Ethereum</td>
<td>geth</td>
<td>实现了以太坊协议的 JavaScript运行时环境，可以以交互式或非交互式模式运行</td>
</tr>
<tr>
<td>Hard Fork</td>
<td>硬分叉</td>
<td>区块链发生永久性分歧，在新共识规则发布后，部分没有升级的节点无法验证已经升级的节点生产的区块，产生硬分叉。</td>
</tr>
<tr>
<td>Hash</td>
<td>哈希</td>
<td>对输出数据执行散列函数的行为。 这是用于确认货币交易。</td>
</tr>
<tr>
<td>Hash Rate</td>
<td>哈希率</td>
<td>采矿钻机的性能测量值以秒为单位表示。</td>
</tr>
<tr>
<td>Homestead</td>
<td>家园</td>
<td>以太坊开发第二阶段</td>
</tr>
<tr>
<td>Hybrid PoS/PoW</td>
<td>混合PoS / PoW</td>
<td>混合 PoS / PoW 可以将网络上的共享分发算法作为共享证明和工作证明。 在这种方法中，可以实现矿工和选民（持有者）之间的平衡，由内部人（持有人）和外部人（矿工）创建一个基于社区的治理体系。</td>
</tr>
<tr>
<td>I2P</td>
<td>I2P</td>
<td>Invisible Internet Project，建立在互联网上的隐匿网络层，用于为网络通讯提供隐私保护</td>
</tr>
<tr>
<td>Infura</td>
<td>Infura</td>
<td>提供全球范围区块链集群和 API 端点等基础架构服务；可用于以太坊，IPFS 等其他新兴的分布式平台。致力于提供安全，稳定，高容错性金额可扩展的区块链访问接口</td>
</tr>
<tr>
<td>keccak</td>
<td>keccak</td>
<td>一种SHA-3加密算法</td>
</tr>
<tr>
<td>Kovri</td>
<td>Kovri</td>
<td>I2P 网络的 C++ 实现版本，目前还在开发中尚未集成到门罗币中，可以提高交易的安全等级（可以隐藏 IP 地址）</td>
</tr>
<tr>
<td>KYC</td>
<td>了解你的客户</td>
<td>Know Your Customer</td>
</tr>
<tr>
<td>Metropolis</td>
<td>大都会</td>
<td>以太坊开发第三阶段</td>
</tr>
<tr>
<td>Mining</td>
<td>挖矿</td>
<td>挖矿是验证区块链交易的行为。 验证的必要性通常以货币的形式奖励给矿工。 在这个密码安全的繁荣期间，当正确完成计算，采矿可以是一个有利可图的业务。 通过选择最有效和最适合的硬件和采矿目标，采矿可以产生稳定的被动收入形式。</td>
</tr>
<tr>
<td>Multi-Signature</td>
<td>多重签名</td>
<td>多重签名地址需要一个以上的密钥来授权交易，从而增加了一层安全性。</td>
</tr>
<tr>
<td>Node</td>
<td>节点</td>
<td>由区块链网络的参与者操作的分类帐的副本。</td>
</tr>
<tr>
<td>Oracles</td>
<td>预言机</td>
<td>Oracle 通过向智能合约提供数据，它现实世界和区块链之间的桥梁。注意此 Oracle不是指数据库。预言机连接虚拟与现实，核心功能是提供数据上链服务，是实现智能合约的必要条件。智能合约是在区块链提供的沙盒环境中运行，沙盒是个封闭环境，使合约代码不能读取链外数据，但很多时候智能合约又必须依赖外部数据，Oracle 在这里就承担了提供外部数据的功能。</td>
</tr>
<tr>
<td>P2P</td>
<td>Peer-to-Peer</td>
<td>对等互联网网络技术。</td>
</tr>
<tr>
<td>Paxos</td>
<td>Paxos</td>
<td>一种用于传统分布式系统的共识协议</td>
</tr>
<tr>
<td>Payment Codes</td>
<td>可重用支付码</td>
<td>BIP47，支付码是一种用于创建永久性比特币地址的技术，这些地址可以重复使用，与现实生活中的身份公开相关，同时无损于财务隐私。它们类似于隐形地址。即使他人知道你的支付码也无法追踪你的交易历史，可以用于想要私密的接收BTC的场景</td>
</tr>
<tr>
<td>PBFT</td>
<td>实用拜占庭容错</td>
<td>Practical Byzantine Fault Tolerance</td>
</tr>
<tr>
<td>pegged zone</td>
<td>锚定分区</td>
<td>一种锚定分区的桥接机制，出现于Cosmos项目</td>
</tr>
<tr>
<td>POA</td>
<td>权威证明</td>
<td>Proof Of Authority，一种共识算法</td>
</tr>
<tr>
<td>portfolio</td>
<td>投资组合</td>
<td></td>
</tr>
<tr>
<td>POS</td>
<td>权益证明</td>
<td>Proof of Stake，根据你持有货币的量和时间进行利息分配的制度，在 POS 模式下，你的“挖矿”收益正比于你的币龄，而与电脑的计算性能无关。</td>
</tr>
<tr>
<td>POW</td>
<td>工作量证明</td>
<td>Proof of Work，是指获得多少货币，取决于你挖矿贡献的工作量，电脑性能越好，分给你的矿就会越多。</td>
</tr>
<tr>
<td>Private Block Chains</td>
<td>私有链</td>
<td>私有区块链，数据记录在单一组织机构中，分权限对外开放，一般是单一企业机构构建。</td>
</tr>
<tr>
<td>Private Key</td>
<td>私钥</td>
<td>私钥是一串数据，它是允许您访问特定钱包中的令牌。 它们作为密码，除了地址的所有者之外，都被隐藏。</td>
</tr>
<tr>
<td>Public Address</td>
<td>公用地址</td>
<td>公共地址是公钥的密码哈希值。 它们作为可以在任何地方发布的电子邮件地址，与私钥不同。</td>
</tr>
<tr>
<td>Public Block Chains</td>
<td>公有链</td>
<td>公共网络中任何个人团体接入，任何节点均可参与共识过程。</td>
</tr>
<tr>
<td>Raft</td>
<td>Raft</td>
<td>Paxos协议的一种简单实现</td>
</tr>
<tr>
<td>Ring Signatures</td>
<td>环签名</td>
<td>用于隐匿发送发信息的技术，门罗币采用</td>
</tr>
<tr>
<td>RingCT</td>
<td>环加密交易</td>
<td>Ring Confidential Transactions，隐藏交易信息（包括交易双方信息和交易金额）的加密技术，门罗币采用</td>
</tr>
<tr>
<td>RLP</td>
<td>RLP 编码</td>
<td>Recursive Length Prefix（递归长度前缀）是一种适用于任意二进制数据数组的编码。是以太坊中对象进行序列化/反序列化的主要编码方式。区块，交易等数据结构在持久化时会先经过RLP编码后再存储到持久层中。</td>
</tr>
<tr>
<td>RPCA</td>
<td>瑞波共识算法</td>
<td>Ripple Protocol Consensus Algorithm，类似PBFT的共识机制</td>
</tr>
<tr>
<td>Scrypt</td>
<td>Scrypt</td>
<td>是一种由 Litecoin 使用加密算法。 与 SHA256 相比，它的速度更快，因为它不会占用很多处理时间。</td>
</tr>
<tr>
<td>Serenity</td>
<td>宁静</td>
<td>以太坊开发第四阶段（也是最后一个阶段）</td>
</tr>
<tr>
<td>SHA-256</td>
<td>SHA-256</td>
<td>是比特币一些列数字货币使用的加密算法。 然而，它使用了大量的计算能力和处理时间，迫使矿工组建采矿池以获取收益。</td>
</tr>
<tr>
<td>Smart Contracts</td>
<td>智能合约</td>
<td>智能合约将可编程语言的业务规则编码到区块上，并由网络的参与者实施。部署在区块链系统中，一段合约代码，或一套以数字形式定义的承诺，包括合约参与方可以在其上执行承诺的协议。</td>
</tr>
<tr>
<td>Soft Fork</td>
<td>软分叉</td>
<td>软分叉与硬分叉不同之处在于，只有先前有效的交易才能使其无效。 由于旧节点将新的块识别为有效，所以软分叉基本上是向后兼容的。 这种分叉需要大多数矿工升级才能执行，而硬分叉需要所有节点就新版本达成一致。</td>
</tr>
<tr>
<td>Solidity</td>
<td>Solidity</td>
<td>是 Ethereum 用于开发智能合约的编程语言。</td>
</tr>
<tr>
<td>SPV</td>
<td>简单支付验证</td>
<td>Simplified Payment Verification</td>
</tr>
<tr>
<td>Stealth Address</td>
<td>隐匿地址</td>
<td>能够隐藏接收方信息</td>
</tr>
<tr>
<td>Swarm</td>
<td>Swarm</td>
<td>去中心化的数据存储访问协议，以 ETH 作为激励。类似使用了 Filecoin 的 IPFS</td>
</tr>
<tr>
<td>Sybil Attack</td>
<td>女巫攻击</td>
<td>P2P网络中的一种攻击形式：攻击者利用单个节点来伪造多个身份存在于 P2P 网络中，从而达到削弱网络的冗余性，降低网络健壮性，监视或干扰网络正常活动等目的</td>
</tr>
<tr>
<td>Testnet</td>
<td>Testnet</td>
<td>开发商使用的测试区块链，它主要是用来防止改变在主链上的资产。</td>
</tr>
<tr>
<td>testrpc</td>
<td>testrpc</td>
<td>以太坊节点客户端</td>
</tr>
<tr>
<td>Transaction Block</td>
<td>交易区块</td>
<td>聚集到一个块中的交易的集合，然后可以将其散列并添加到区块链中。</td>
</tr>
<tr>
<td>Transaction Fee</td>
<td>交易费</td>
<td>所有的加密货币交易都会涉及到一笔很小的手续费。这些手续费用加起来给矿工在成功处理区块时收到的区块奖励。</td>
</tr>
<tr>
<td>Truffle</td>
<td>Truffle</td>
<td>一个基于以太坊技术的开发、测试和部署框架，旨在帮助以太坊开发者更容易开发去中心化应用（DApp）</td>
</tr>
<tr>
<td>Turing Complete</td>
<td>图灵完备</td>
<td>图灵完备是指计算机中一切计算的问题都可以计算，这样的虚拟机或者编程语言称为图灵完备。一个例子是 Ethereum 虚拟机（EVM）。</td>
</tr>
<tr>
<td>Unlinkability</td>
<td>无关联性</td>
<td></td>
</tr>
<tr>
<td>whisper</td>
<td>whisper</td>
<td>去中心化的通信协议</td>
</tr>
<tr>
<td>YC</td>
<td>YC</td>
<td>Y Combinator，成立于 2005 年是美国著名创业孵化器，扶持初创企业并为其提供创业指南（Airbnb，Dropbox，Stripe，Reddit, Docker, Coinbase 等），投资孵化过多个区块链项目</td>
</tr>
<tr>
<td>ZKRP</td>
<td>零知识范围证明</td>
<td>Zero Knownledge Range Proof，证明一个具体声明的真实性而不会泄露它试图证明的额外信息</td>
</tr>
<tr>
<td>ZK-SNARKs</td>
<td>零知识证明</td>
<td>ZK-Succint Non-interactive Arguments of Knownledge</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[区块链——六大核心算法]]></title>
        <id>https://tdmaker.github.io/faded/post/blockchain-core-algorithms/</id>
        <link href="https://tdmaker.github.io/faded/post/blockchain-core-algorithms/">
        </link>
        <updated>2020-04-08T03:37:59.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p><a href="https://mp.weixin.qq.com/s?__biz=MjM5ODc2Mzk2MA==&amp;mid=2451745390&amp;idx=1&amp;sn=49cfe1109265da6cbc66e2a78e61857e&amp;chksm=b113c6b986644fafcc2a50cac866e0bc2348294218698769cb4bacc25121326efdeb1712e023&amp;mpshare=1&amp;scene=23&amp;srcid=0530alUeRaZnqCIi8dj1jEm5#rd">区块链技术六大核心算法</a></p>
</blockquote>
<h1 id="拜占庭协定">拜占庭协定</h1>
<p>拜占庭的故事大概是这么说的：拜占庭帝国拥有巨大的财富，周围 10 个邻邦垂诞已久，但拜占庭高墙耸立，固若金汤，没有一个单独的邻邦能够成功入侵。任何单个邻邦入侵的都会失败，同时也有可能自身被其他 9 个邻邦入侵。拜占庭帝国防御能力如此之强，至少要有十个邻邦中的一半以上同时进攻，才有可能攻破。然而，如果其中的一个或者几个邻邦本身答应好一起进攻，但实际过程出现背叛，那么入侵者可能都会被歼灭。于是每一方都小心行事，不敢轻易相信邻国。这就是拜占庭将军问题。</p>
<p>在这个分布式网络里：每个将军都有一份实时与其他将军同步的消息账本。账本里有每个将军的签名都是可以验证身份的。如果有哪些消息不一致，可以知道消息不一致的是哪些将军。尽管有消息不一致的，只要超过半数同意进攻，少数服从多数，共识达成。</p>
<p>由此，在一个分布式的系统中，尽管有坏人，坏人可以做任意事情（不受protocol限制），比如不响应、发送错误信息、对不同节点发送不同决定、不同错误节点联合起来干坏事等等。但是，只要大多数人是好人，就完全有可能去中心化地实现共识。</p>
<h1 id="非对称加密技术">非对称加密技术</h1>
<p>在上述拜占庭协定中，如果 10 个将军中的几个同时发起消息，势必会造成系统的混乱，造成各说各的攻击时间方案，行动难以一致。谁都可以发起进攻的信息，但由谁来发出呢？其实这只要加入一个成本就可以了，即：一段时间内只有一个节点可以传播信息。当某个节点发出统一进攻的消息后，各个节点收到发起者的消息必须签名盖章，确认各自的身份。</p>
<p>在如今看来，非对称加密技术完全可以解决这个签名问题。非对称加密算法的加密和解密使用不同的两个密钥.这两个密钥就是我们经常听到的“公钥”和“私钥”。公钥和私钥一般成对出现, 如果消息使用公钥加密,那么需要该公钥对应的私钥才能解密; 同样，如果消息使用私钥加密,那么需要该私钥对应的公钥才能解密。</p>
<h1 id="容错问题">容错问题</h1>
<p>我们假设在此网络中，消息可能会丢失、损坏、延迟、重复发送，并且接受的顺序与发送的顺序不一致。此外，节点的行为可以是任意的：可以随时加入、退出网络，可以丢弃消息、伪造消息、停止工作等，还可能发生各种人为或非人为的故障。我们的算法对由共识节点组成的共识系统，提供的容错能力，这种容错能力同时包含安全性和可用性，并适用于任何网络环境。</p>
<h1 id="paxos-算法一致性算法">Paxos 算法（一致性算法）</h1>
<p>Paxos算法解决的问题是一个分布式系统如何就某个值（决议）达成一致。一个典型的场景是，在一个分布式数据库系统中，如果各节点的初始状态一致，每个节点都执行相同的操作序列，那么他们最后能得到一个一致的状态。为保证每个节点执行相同的命令序列，需要在每一条指令上执行一个“一致性算法”以保证每个节点看到的指令一致。一个通用的一致性算法可以应用在许多场景中，是分布式计算中的重要问题。 节点通信存在两种模型：共享内存和消息传递。Paxos 算法就是一种基于消息传递模型的一致性算法。</p>
<h1 id="共识机制">共识机制</h1>
<p>区块链共识算法主要是工作量证明和权益证明。拿比特币来说，其实从技术角度来看可以把 PoW 看做重复使用的 Hashcash，生成工作量证明在概率上来说是一个随机的过程。开采新的机密货币，生成区块时，必须得到所有参与者的同意，那矿工必须得到区块中所有数据的 PoW 工作证明。与此同时矿工还要时时观察调整这项工作的难度，因为对网络要求是平均每 10 分钟生成一个区块。</p>
<h1 id="分布式存储">分布式存储</h1>
<p>分布式存储是一种数据存储技术，通过网络使用每台机器上的磁盘空间，并将这些分散的存储资源构成一个虚拟的存储设备，数据分散的存储在网络中的各个角落。所以，分布式存储技术并不是每台电脑都存放完整的数据，而是把数据切割后存放在不同的电脑里。就像存放 100 个鸡蛋，不是放在同一个篮子里，而是分开放在不同的地方，加起来的总和是 100 个。</p>
]]></content>
    </entry>
</feed>