<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://faded.auspicious.space</id>
    <title>Typhoeus</title>
    <updated>2020-04-19T14:33:55.642Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://faded.auspicious.space"/>
    <link rel="self" href="https://faded.auspicious.space/atom.xml"/>
    <logo>https://faded.auspicious.space/images/avatar.png</logo>
    <icon>https://faded.auspicious.space/favicon.ico</icon>
    <rights>All rights reserved 2020, Typhoeus</rights>
    <entry>
        <title type="html"><![CDATA[TCP——三次握手和四次挥手]]></title>
        <id>https://faded.auspicious.space/post/tcp-three-handshake-and-four-waves/</id>
        <link href="https://faded.auspicious.space/post/tcp-three-handshake-and-four-waves/">
        </link>
        <updated>2020-04-19T13:01:26.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p><a href="https://www.jianshu.com/p/f876f19112a2">TCP 三次握手 和 四次挥手</a></p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p><a href="https://www.jianshu.com/p/f876f19112a2">TCP 三次握手 和 四次挥手</a></p>
</blockquote>
<!-- more -->
<h1 id="概述">概述</h1>
<p>我们都知道 TCP 是 可靠的数据传输协议，UDP 是不可靠传输，那么 TCP 它是怎么保证可靠传输的呢？那我们就不得不提 TCP 的三次握手和四次挥手。</p>
<h1 id="三次握手">三次握手</h1>
<p>下图为三次握手的流程图：<br>
<img src="https://faded.auspicious.space/post-images/1587301423349.png" alt="" loading="lazy"></p>
<p>下面通过我们 Wireshark 抓包工具来分析三次握手：<br>
<img src="https://faded.auspicious.space/post-images/1587301710261.png" alt="" loading="lazy"></p>
<h2 id="第一次握手">第一次握手</h2>
<p>建立连接。客户端发送连接请求报文段，将 <code>SYN</code> 位置为 <code>1</code>，<code>Sequence Number</code> 为 <code>x</code>；（<code>x</code> 是随机生成的一个 <code>int</code> 数值）然后，客户端进入 <code>SYN_SEND</code> 状态，等待服务器的确认；<br>
<img src="https://faded.auspicious.space/post-images/1587301974117.png" alt="" loading="lazy"></p>
<h2 id="第二次握手">第二次握手</h2>
<p>服务器收到 <code>SYN</code> 报文段。服务器收到客户端的 <code>SYN</code> 报文段，需要对这个 <code>SYN</code> 报文段进行确认，设置 <code>Acknowledgment Number</code> 为 <code>x+1</code>(<code>Sequence Number+1</code>)；同时，自己自己还要发送 <code>SYN</code> 请求信息，将 <code>SYN</code> 位置为<code>1</code>，<code>Sequence Number</code> 为 <code>y</code> （<code>y</code> 是随机生存的一个 <code>int</code> 数值）；服务器端将上述所有信息放到一个报文段（即 <code>SYN + ACK</code> 报文段）中，一并发送给客户端，此时服务器进入 <code>SYN_RECV</code> 状态；<br>
<img src="https://faded.auspicious.space/post-images/1587302254938.png" alt="" loading="lazy"></p>
<h2 id="第三次握手">第三次握手</h2>
<p>客户端收到服务器的 <code>SYN + ACK</code> 报文段。然后将 <code>Acknowledgment Number</code> 设置为 <code>y + 1</code>，向服务器发送 <code>ACK</code> 报文段，这个报文段发送完毕以后，客户端和服务器端都进入 <code>ESTABLISHED</code> 状态，完成 TCP 三次握手。<br>
<img src="https://faded.auspicious.space/post-images/1587302315024.png" alt="" loading="lazy"></p>
<h1 id="四次挥手">四次挥手</h1>
<figure data-type="image" tabindex="1"><img src="https://faded.auspicious.space/post-images/1587302377110.png" alt="" loading="lazy"></figure>
<h2 id="第一次挥手">第一次挥手</h2>
<p><strong>Client</strong>（可以使客户端，也可以是服务器端），设置 <code>Sequence Number</code> 和 <code>Acknowledgment Number</code>，向 <strong>Server</strong> 发送一个 <code>FIN</code> 报文段；此时，<strong>Client</strong> 进入 <code>FIN_WAIT_1</code> 状态；这表示 <strong>Client</strong> 没有数据要发送给 <strong>Server</strong> 了；</p>
<p><strong>客户端发送第一次挥手后，就不能在向服务端发送数据了。</strong></p>
<h2 id="第二次挥手">第二次挥手</h2>
<p><strong>Server</strong> 收到了 <strong>Client</strong> 发送的 <code>FIN</code> 报文段，向 <strong>Client</strong> 回一个 <code>ACK</code> 报文段，<code>Acknowledgment Number</code> 为 <code>Sequence Number</code> 加 <code>1</code>；<strong>Client</strong> 进入 <code>FIN_WAIT_2</code> 状态；<strong>Server</strong> 告诉 <strong>Client</strong> ，我“同意”你的关闭请求；</p>
<p><strong>Server 第一次响应后，还可以继续向 Client 发送数据，这里只是告诉 Client ，我收到你发送的关闭请求。</strong></p>
<h2 id="第三次挥手">第三次挥手</h2>
<p><strong>Server</strong> 向 <strong>Client</strong> 发送 <code>FIN</code> 报文段，请求关闭连接，同时 <strong>Server</strong> 进入 <code>CLOSE_WAIT</code> 状态；</p>
<p><strong>当 Server 的数据响应完成后，再告诉 Client，我这边也可以关闭请求了， 这时<br>
Server 就不能再向 Client 发送数据了。</strong></p>
<h2 id="第四次挥手">第四次挥手</h2>
<p><strong>Client</strong> 收到 <strong>Server</strong> 发送的 <code>FIN</code> 报文段，向 <strong>Server</strong> 发送 <code>ACK</code> 报文段，然后 <strong>Client</strong> 进入 <code>TIME_WAIT</code> 状态；<strong>Server</strong> 收到 <strong>Client</strong> 的 <code>ACK</code> 报文段以后，就关闭连接；此时，<strong>Client</strong> 等待 2 MSL 后依然没有收到回复，则证明 <strong>Server</strong> 端已正常关闭，那好，<strong>Client</strong> 也可以关闭连接了。</p>
<h3 id="什么是-msl">什么是 MSL</h3>
<p><strong>MSL</strong> 是 Maximum Segment Lifetime 英文的缩写，中文可以译为“<strong>报文最大生存时间</strong>”，他是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。因为 TCP 报文（segment）是 IP 数据报（datagram）的数据部分，具体称谓请参见《数据在网络各层中的称呼》一文，而 IP 头中有一个 TTL 域，TTL 是 Time To Live 的缩写，中文可以译为“生存时间”，这个生存时间是由源主机设置初始值但不是存的具体时间，而是存储了一个 IP 数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减 1，当此值为 0 则数据报将被丢弃，同时发送 ICMP 报文通知源主机。<strong>RFC 793</strong> 中规定 MSL 为 2 分钟，实际应用中常用的是 30 秒，1 分钟和 2 分钟等。</p>
<p>2 MSL 即两倍的 MSL，TCP 的 <code>TIME_WAIT</code> 状态也称为 2 MSL 等待状态，当 TCP 的一端发起主动关闭，在发出最后一个 <code>ACK</code> 包后，即第 3 次握手完成后发送了第四次握手的 <code>ACK</code> 包后就进入了 <code>TIME_WAIT</code> 状态，必须在此状态上停留两倍的 MSL 时间，等待 2 MSL 时间主要目的是怕最后一个 <code>ACK</code> 包对方没收到，那么对方在超时后将重发第三次握手的 <code>FIN</code> 包，主动关闭端接到重发的 <code>FIN</code> 包后可以再发一个 <code>ACK</code> 应答包。在 <code>TIME_WAIT</code> 状态时两端的端口不能使用，要等到 2 MSL 时间结束才可继续使用。当连接处于 2 MSL 等待阶段时任何迟到的报文段都将被丢弃。不过在实际应用中可以通过设置 <code>SO_REUSEADDR</code> 选项达到不必等待 2 MSL 时间结束再使用此端口。</p>
<p>TTL 与 MSL 是有关系的但不是简单的相等的关系，MSL 要大于等于 TTL。</p>
<h1 id="为什么要三次握手">为什么要三次握手？</h1>
<p>TCP 建立连接，其实通过两次握手就可以建立连接了，为什么要三次呢？是不是多此一举呢？</p>
<h2 id="计算机网络中是这样说的">《计算机网络》中是这样说的</h2>
<p>为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。在书中同时举了一个例子，如下：“已失效的连接请求报文段”的产生在这样一种情况下： <strong>Client</strong> 发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达 <strong>Server</strong>。本来这是一个早已失效的报文段。但 <strong>Server</strong> 收到此失效的连接请求报文段后，就误认为是 <strong>Client</strong> 再次发出的一个新的连接请求。于是就向 <strong>Client</strong> 发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要 <strong>Server</strong> 发出确认，新的连接就建立了。由于现在 <strong>Client</strong> 并没有发出建立连接的请求，因此不会理睬 <strong>Server</strong> 的确认，也不会向 <strong>Server</strong> 发送数据。但 <strong>Server</strong> 却以为新的运输连接已经建立，并一直等待 <strong>Client</strong> 发来数据。这样， <strong>Server</strong> 的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况， <strong>Client</strong> 不会向 <strong>Server</strong> 的确认发出确认。 <strong>Server</strong> 由于收不到确认，就知道 <strong>Client</strong> 并没有要求建立连接。”</p>
<h2 id="网络故障">网络故障</h2>
<p>比如，现在网络出现了故障，只能发请求数据包，而接收不到响应数据包，那么只要发送一次请求，服务器就建立请求，这样肯定也是不对的，网络请求有来有回才能完成通讯。所以三次握手是必不可少的。</p>
<h1 id="为什么要四次挥手呢">为什么要四次挥手呢？</h1>
<p>TCP 协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP 是全双工模式，这就意味着，当 <strong>Client</strong> 发出 <code>FIN</code> 报文段时，只是表示 <strong>Client</strong> 已经没有数据要发送了，<strong>Client</strong> 告诉 <strong>Server</strong>，它的数据已经全部发送完毕了；但是，这个时候 <strong>Client</strong> 还是可以接受来自 <strong>Server</strong> 的数据；当 <strong>Server</strong> 返回 <code>ACK</code> 报文段时，表示它已经知道 <strong>Client</strong> 没有数据发送了，但是 <strong>Server</strong> 还是可以发送数据到 <strong>Client</strong> 的；当 <strong>Server</strong> 也发送了 <code>FIN</code> 报文段时，这个时候就表示 <strong>Server</strong> 也没有数据要发送了，就会告诉 <strong>Client</strong>，我也没有数据要发送了，之后彼此就会愉快的中断这次 TCP 连接。如果要正确的理解四次分手的原理，就需要了解四次分手过程中的状态变化。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[芙蓉女儿诔]]></title>
        <id>https://faded.auspicious.space/post/hibiscus-girl-dirge/</id>
        <link href="https://faded.auspicious.space/post/hibiscus-girl-dirge/">
        </link>
        <updated>2020-04-19T12:46:45.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p><a href="https://www.douban.com/note/24854910/">芙蓉女儿诔---注音版</a></p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p><a href="https://www.douban.com/note/24854910/">芙蓉女儿诔---注音版</a></p>
</blockquote>
<!-- more -->
<h1>芙蓉女儿诔（lěi）</h1>
<h2>贾宝玉（《红楼梦》第七十八回）</h2>
<p>维太平不易之元，蓉桂竞芳之月，无可奈何之日，怡红院浊玉，谨以群花之蕊，冰鲛之縠（hú），沁芳之泉，枫露之茗（míng），四者虽微，聊以达诚申信，乃致祭于白帝宫中抚司秋艳芙蓉女儿之前曰：<br>
　　窃思女儿自临浊世，迄今凡十有六载。其先之乡籍姓氏，湮（yān）沦（lún）而莫能考者久矣。而玉得于衾（qīn）枕栉（zhì）沐（mù）之间，栖息宴游之夕，亲昵（nì）狎（xiá）亵（xiè），相与共处者，仅五年八月有（yòu）奇（jī）。<br>
　　忆女儿曩（nǎng）生之昔，其为质则金玉不足喻其贵，其为性则冰雪不足喻其洁，其为神则星日不足喻其精，其为貌则花月不足喻其色。姊妹悉慕媖（yīng）娴（xián），妪（yù）媪（ǎo）咸仰惠德。<br>
　　孰料鸠（jiū）鸩（zhèn）恶（wù）其高，鹰鸷（zhì）翻遭罦（fú）罬（zhuó）；薋（cí）葹（shī）妒其臭（xiù），茝（chǎi）兰竟被芟（shān）鉏（chú）！花原自怯，岂奈狂飙（biāo）？柳本多愁，何禁骤雨？偶遭蛊（gǔ）虿（chài）之谗，遂抱膏肓（huāng）之疚（jiù）。故而樱唇红褪，韵吐呻吟；杏脸香枯，色陈顑（kǎn）颔（hàn）。诼（zhuó）谣謑（xī）诟（gòu），出自屏帏（wéi）；荆棘蓬榛（zhēn），蔓延户牖（yǒu）。岂招尤则替，实攘诟而终。既忳（tún）幽沉于不尽，复含罔屈于无穷。高标见嫉，闺（guī）帏（wéi）恨比长沙；直烈遭危，巾帼惨于羽野。自蓄辛酸，谁怜夭折？仙云既散，芳趾难寻。洲迷聚窟，何来却死之香？海失灵槎（chá），不获回生之药。<br>
　　眉黛烟青，昨犹我画；指环玉冷，今倩谁温？鼎炉之剩药犹存，襟泪之余痕尚渍（zì）。镜分鸾（luán）别，愁开麝月之奁（lián）；梳化龙飞，哀折檀（tán）云之齿。委金钿（diàn）于草莽，拾翠盒（è 盍代勺中之丶）于尘埃。楼空鳷（zhī）鹊，徒悬七夕之针；带断鸳鸯，谁续五丝之缕？<br>
　　况乃金天属节，白帝司时，孤衾（qīn）有梦，空室无人。桐阶月暗，芳魂与倩影同销；蓉帐香残，娇喘共细言皆绝。连天衰草，岂独蒹（jiān）葭（jiā）；匝（zā）地悲声，无非蟋蟀。露苔晚砌，穿帘不度寒砧（zhēn）；雨荔秋垣（yuán），隔院希闻怨笛。芳名未泯（mǐn），檐前鹦鹉犹呼；艳质将亡，槛外海棠预老。捉迷屏后，莲瓣无声；斗草庭前，兰芳枉（wǎng）待。抛残绣线，银笺（jiān）彩缕谁裁？摺（zhé）断冰丝，金斗御香未熨。<br>
　　昨承严命，既趋车而远涉芳园；今犯慈威，复拄杖而近抛孤柩（jiù）。及闻槥（huì）棺被燹（xiǎn），惭违共穴之盟；石椁（guǒ）成灾，愧迨（dài）同灰之诮（qiào）。<br>
　　尔乃西风古寺，淹滞青燐（lín），落日荒丘，零星白骨。楸（qiū）榆飒（sà）飒（sà），蓬艾萧萧。隔雾圹（kuàng）以啼猿，绕烟塍（chéng）而泣鬼。自为红绡（xiāo）帐里，公子情深；始信黄土陇（lǒng）中，女儿命薄！汝南泪血，斑斑洒向西风；梓（zǐ）泽馀（yú）衷，默默诉凭冷月。<br>
　　呜呼！固鬼蜮（yù）之为灾，岂神灵而亦妒。箝诐（bì）奴之口，讨岂从宽？剖（pōu）悍妇之心，忿犹未释！在君之尘缘虽浅，然玉之鄙意岂终。因蓄惓（quán）惓（quán）之思，不禁谆（zhūn）谆（zhūn）之问。<br>
　　始知上帝垂旌（jīng），花宫待诏（zhào），生侪（chái）兰蕙（huì），死辖芙蓉。听小婢（bì）之言，似涉无稽（jī）；据浊玉之思，则深为有据。何也？昔叶法善摄魂以撰碑，李长吉被诏而为记，事虽殊，其理则一也。故相物以配才，苟非其人，恶乃滥乎其位？始信上帝委托权衡，可谓至洽至协，庶不负其所秉赋也。因希其不昧之灵，或陟（zhì）降（jiàng）于兹（zī），特不揣（chuǎi）鄙俗之词，有污慧听。乃歌而招之曰：<br>
　　天何如是之苍苍兮，乘玉虬（qiú）以游乎穹（qióng）窿（lóng）耶？<br>
　　地何如是之茫茫兮，驾瑶（yáo）象以降乎泉壤耶？<br>
　　望伞盖之陆离兮，抑箕（jī）尾之光耶？<br>
　　列羽葆（bǎo）而为前导兮，卫危虚于傍耶？<br>
　　驱丰隆以为比从兮，望舒月以临耶？<br>
　　听车轨而伊轧兮，御鸾（luán）鹥（yī）以征耶？<br>
　　闻馥郁而薆（ài）然兮，纫（rèn）蘅杜以为纕（xiāng）耶？<br>
　　炫裙裾（jū）之烁（shuò）烁（shuò）兮，镂明月以为珰（dāng）耶？<br>
　　籍葳（wēi）蕤（ruí）而成坛畤（zhì）兮，檠（qíng）莲焰以烛兰膏耶？<br>
　　文瓟（bó）瓠（hú）以为觯（zhì）斝（jiǎ）兮，漉醽（líng）醁（lù）以浮桂醑（xǔ）耶？<br>
　　瞻云气而凝盼兮，仿佛有所觇（chān）耶？<br>
　　俯窈窕而属耳兮，恍惚有所闻耶？<br>
　　期汗漫而无夭阏（yān）兮，忍捐弃余于尘埃耶？<br>
　　倩风廉之为余驱车兮，冀联辔（pèi）而携归耶？<br>
　　余中心为之慨然兮，徒噭（jiào）噭（jiào）而何为耶？<br>
　　君偃（yǎn）然而长寝（qǐn）兮，岂天运之变于斯耶？<br>
　　既窀（zhūn）穸（xī）且安稳兮，反其真而复奚（xī）化耶？<br>
　　余犹桎（zhì）梏（gù）而悬附兮，灵格余以嗟（jiē）来耶？<br>
　　来兮止兮，君其来耶！<br>
　　若夫鸿蒙而居，寂静以处，虽临于兹，余亦莫睹。搴（qiān）烟萝而为步幛（zhàng），列枪蒲而森行伍。警柳眼之贪眠，释莲心之味苦。素女约于桂岩，宓（fú）妃迎于兰渚（zhǔ）。弄玉吹笙（shēng），寒簧击敔（yǔ）。征嵩（sōng）岳之妃，启骊（lí）山之姥（mǔ）。龟呈洛浦之灵，兽作咸池之舞。潜赤水兮龙吟，集珠林兮凤翥（zhù）。爰（yuán）格爰（yuán）诚，匪簠（fǔ）匪筥（jǔ）。发轫（rèn）乎霞城，返旌（jīng）乎玄圃。既显微而若通，复氤（yīn）氲（yūn）而倏阻。离合兮烟云，空蒙兮雾雨。尘霾（mái）敛兮星高，溪山丽兮月午。何心意之忡忡，若寤（wù）寐（mèi）之栩栩？余乃欷（xī）歔（xū）怅望，泣涕彷徨。人语兮寂历，天籁兮篔（yún）筜（dāng）。鸟惊散而飞，鱼唼（shà）喋（zhá）以响。志哀兮是祷（dǎo），成礼兮期祥。呜呼哀哉！尚飨（xiǎng）！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[在网页上使用 jpg、png、gif 和 svg]]></title>
        <id>https://faded.auspicious.space/post/jpg-png-gif-and-svg-on-the-web-a-beginner-guide/</id>
        <link href="https://faded.auspicious.space/post/jpg-png-gif-and-svg-on-the-web-a-beginner-guide/">
        </link>
        <updated>2020-04-19T11:20:41.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p><a href="https://zcfy.cc/article/jpg-png-and-svg-on-the-web-a-beginner-039-s-guide-cheesecake-labs-3211.html">在网页上使用JPG、PNG和SVG：新手指南 | Cheesecake Labs</a></p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p><a href="https://zcfy.cc/article/jpg-png-and-svg-on-the-web-a-beginner-039-s-guide-cheesecake-labs-3211.html">在网页上使用JPG、PNG和SVG：新手指南 | Cheesecake Labs</a></p>
</blockquote>
<!-- more -->
<p>如今，图像已经成为网络不可或缺的一部分。但情况并非一贯如此。直到 1993 年，Mosaic 浏览器才在网页内容中中加入图像。有些图像格式像 GIF 和 JPEG 当时已经存在，而 PNG 和 SVG 直到 90 年代才出现。图像用途多样，如：显示图片、品牌、插图、图表以及许多其他内容。</p>
<p>由于多样的使用情况和图片格式，有时选择正确的格式可能会令人困惑。标志应该是 SVG 还是 PNG？截图呢？JPEG 还是 PNG？在不生成过大文件的前提下，文件质量能有多高？了解每个图像格式如何工作还有它们各自的利弊可以帮助回答这些问题。</p>
<p>在过去几年中，通过数字设计和前端开发，研究和测试不同的工具帮助我澄清了这些问题。在本文中，我将展示一下每种格式如何工作、它们在哪个方面存在优势，以及在网页使用时的压缩与保存方法。</p>
<h1 id="jpeg">JPEG</h1>
<p>JEPG 由联合图像专家小组（Joint Photographic Experts Group）于 1992 年创建，并以创建者命名。JPEG 是一种有损光栅图像格式，这意味着每次保存被压缩的 JPEG 时，一些信息将被不可逆转地丢失。</p>
<p>JPEG 利用人眼感知的缺陷——对亮度比对颜色更敏感——使用了一种压缩算法来丢弃我们不太擅长获取的信息，因此被命名为“有损格式”。应用于给定图像的压缩量将直接与所得文件的质量和大小相关。 JPEG 压缩的技术方面远远不止这些，如果你想更深入，请查看<a href="http://www.ams.org/samplings/feature-column/fcarc-image-compression">这篇文章</a> 作者：大卫·奥斯丁（David Austin）。</p>
<h2 id="jpeg-的用途">JPEG 的用途</h2>
<p>因为 JPEG 适用于亮度和色彩压缩，所以在照片，以及其他写实或者带阴影的图像（如绘画和 3D 渲染）上使用效果良好。这就是为什么它是多年来最流行的存储图片的格式。出于同样的原因，JPEG 不适宜用在矢量图片，如徽标，几何图形，截图等方面。<br>
<img src="https://faded.auspicious.space/post-images/1587295533496.jpg" alt="" loading="lazy"><br>
照片，以及复杂的或带阴影的图像，如绘画，是使用 JPEG 的很好的例子。</p>
<h2 id="压缩-jpeg">压缩 JPEG</h2>
<p>作为有损格式，JPEG 文件的压缩级别与最终图像质量直接相反。在像 Photoshop 这样的工具中保存 JPEG 时，你会看到一个从 0 到 100 的质量设置。Photoshop 设置了一些图像质量范围：</p>
<ul>
<li>低 — 10%</li>
<li>中 — 30%</li>
<li>高 — 60%</li>
<li>非常高 — 80%</li>
<li>最佳 — 100%</li>
</ul>
<p><img src="https://faded.auspicious.space/post-images/1587295798797.png" alt="" loading="lazy"><br>
最佳 100% (61 KB)，非常高 80% (29 KB)。<br>
<img src="https://faded.auspicious.space/post-images/1587296057016.png" alt="" loading="lazy"><br>
高 60% (16 KB)，中 30% (7 KB)。<br>
<img src="https://faded.auspicious.space/post-images/1587296138925.png" alt="" loading="lazy"><br>
低 10% (6 KB)，最低 0% (3 KB)。</p>
<p>网络建议使用在 50％ 到 60％ 质量之间的 JPEG，因为它能保证不错的图像质量和较小的文件尺寸。从 JPEG 资源中删除元数据也可以减少文件大小。还有如 <a href="">TinyJPG</a> 的在线工具，以及桌面应用程序如 <a href="https://imageoptim.com/mac">ImageOptim</a> (Mac) 和 <a href="http://luci.criosweb.ro/riot/">RIOT</a> (Windows)都可以用来压缩图片。在 Photoshop 里，可以通过在“导出”中选择“元数据：无”或“存储为 Web 所用格式（旧版）”来完成压缩。模糊图像或图像部分区域也会产生较小的文件可在<a href="https://responsivedesign.is/articles/reducing-image-sizes">此处</a>查看。</p>
<p>请注意，由于 JPEG 的有损方式，即使以 100％ 的质量保存相同的文件，因为压缩算法会在同一图像上一次又一次地应用，多次之后也会导致图像质量的降低。但这一变化可能不会显示在文件大小的改变上。</p>
<h1 id="png">PNG</h1>
<p>可移植网络图形（Portable Network Graphics）也是一种自 1995 年以来就一直存在的光栅图像格式。它与 JPEG 不同，因为它是一种无损格式，并且是目前网络上最常见的无损格式。这意味着由于它的压缩算法，当文件被保存和压缩时，不会丢失任何信息。</p>
<p>PNG 有很多很酷的特性，如：</p>
<ul>
<li>Alpha 透明度——意味着每个像素可以具有不同的透明度；</li>
<li>8 位文件可以使用基于调色板的颜色模型（也称为索引颜色）——这意味着如果减少颜色数量，文件可能更小；</li>
<li>依据 <a href="http://www.libpng.org/pub/png/">libPNG</a> 的说法，PNG 压缩效率比 GIF 高 25％；</li>
<li><a href="https://nuwen.net/png.html">二维隔行扫描</a>——图像会在加载过程中逐步显现，而不是只有当图像完全加载时，才能显示图像。必须谨慎使用此选项，因为它会增加文件大小。</li>
</ul>
<p>有关 PNG 更多特性、历史和技术信息的完整列表，请查看 libpng 的<a href="http://www.libpng.org/pub/png/">页面</a>。</p>
<h2 id="png-的用途">PNG 的用途</h2>
<p>PNG 对于线条图，徽标，图标和只有几种颜色的图像非常好用。另一方面，用在大量颜色的照片和图像时，将生成巨大的文件。PNG 的另一个好用的地方是透明背景。在这种情况下，即使是复杂的图片仍然可以使用 PNG，因为 JPEG 中不存在透明度功能。<br>
<img src="https://faded.auspicious.space/post-images/1587297022626.png" alt="" loading="lazy"><br>
PNG 可以很好地用在线条作品，徽标和图标上。 (漫画作者：<a href="https://xkcd.com/327/">xkcd</a>)</p>
<h2 id="压缩-png">压缩 PNG</h2>
<p>因为 PNG 中的压缩算法是无损的，你可以选择性地减少它的颜色，从而通过外部工具减小图片尺寸。 <a href="http://pngquant/">Pngquant</a> 就是一个很好的工具，它可以在保持 Alpha 水平的同时减少文件大小。请注意，这一过程会创建一个 8 位文件，即该文件最多可以有 256 种颜色。可能看起来不多，但是用这么多颜色足以获得很好的效果。<br>
<img src="https://faded.auspicious.space/post-images/1587297406451.png" alt="" loading="lazy"><br>
左边的 24 位图像 (149 KB) 和右边 8 位，256 色图像 (54 KB)——缩小了 63.7%</p>
<p>对于大多数 PNG 使用场景（线图，图形，图标），256色是足够的。因此，可以通过减少调色板中的颜色数量来进一步减少文件大小。 使用 GUI 工具是个不错的选择，如 <a href="https://nukesaq88.github.io/Pngyu/">Pngyu</a> 或 <a href="https://pngmini.com/">ImageAlpha</a>，这些工具允许你预览生成的文件。 下面的例子显示了如何在不会显著影响质量的前提下，将调色板减少到 32 种颜色。在类似的例子中，图像很难被自动化地压缩——因为需要不断预览和测试来达到最佳效果——同时使用最少的颜色和产生最小的文件尺寸。就像 JPEG 一样，也有用于压缩 PNG 的在线工具，如：<a href="https://tinypng.com/">TinyPNG</a>。<br>
<img src="https://faded.auspicious.space/post-images/1587297636099.png" alt="" loading="lazy"><br>
在这个示例中，徽标可以从原始的 24 位 PNG（10 KB）减少到 8 位，32 色版本（2 KB，缩减 80％），并且没有丢失任何明显的细节。</p>
<h1 id="gif">GIF</h1>
<p>图形交换格式（Graphics Interchange Format）也是一种位图格式，并且比本文中提到的其它格式都出现地更早。它在 1989 年由 Steve Wilhite 创建, 它在 PNG 创建前都是最流行的 8 位图像格式。GIF 与 PNG 具有类似的特性，但有一些缺点：</p>
<ul>
<li>仅支持 256 种颜色；</li>
<li><a href="https://nuwen.net/png.html">一维交错</a>——图像边加载边现实，但不够平滑；</li>
<li>与 PNG 相比压缩性差；</li>
<li>“非此即彼”透明度——像素只能是 100％ 透明或 100％ 可见；</li>
<li>有歧义的发音？</li>
</ul>
<h1 id="svg">SVG</h1>
<p>可伸缩矢量图形（Scalable Vector Graphics）与前面的两个栅格格式不同，顾名思义，它是矢量格式。这意味着它不会存储基于像素的数据，而是协调生成图形的信息。 SVG 矢量使用带有标签的基于 XML 的结构，就像 HTML 一样。由于此标签结构，你可以通过 ID 识别 SVG 元素，并操纵它们。这带来了很多可能性，例如使用 <a href="http://snapsvg.io/demos/#coffee">JavaScript</a> 和 <a href="https://css-tricks.com/animating-svg-css/">CSS</a> 修改和动画化元素或<a href="http://tympanus.net/codrops/2014/08/19/making-svgs-responsive-with-css/">创建响应式图形</a>。</p>
<p>请看这个例子：<a href="https://codepen.io/jonathansilva/pen/rLABRz/">#1 – 咖啡机 – CSS3制作SVG动画</a> ，作者乔纳森·席尔瓦（Jonathan Silva）(<a href="https://codepen.io/jonathansilva">@jonathansilva</a>) 发表于 <a href="https://codepen.io/">CodePen</a>。</p>
<p>就像其它矢量格式，SVG 图片能不丢失任何细节或像素化地放大到任何大小。打个比方，同一个图标，可以以多种尺寸使用，并且在任何屏幕分辨率（比如 Retina 显示器）中都将看起来很清晰，而不需要存成多个文件。<br>
<img src="https://faded.auspicious.space/post-images/1587298874267.png" alt="" loading="lazy"><br>
矢量图片（右）能够在保持图片的质量的前提下任意放大。</p>
<h2 id="svg-的用途">SVG 的用途</h2>
<p>SVG 在线条艺术，标志，图标，插画和数据可视化方面发挥出色。但它不适用于写实图像和有许多细节的复杂图片。在一些情况下，SVG 和 PNG 都能很好地达到同一个目的。对于线条艺术，SVG 通常能生成较小的文件。但是这不是必然的，实际情况会根据矢量图像究竟有多少个锚点，它甚至可能会生成比 PNG 更大的文件。 SVG 真正出色的地方是数据可视化。由于可以使用 JavaScript 来操纵和创建矢量动画，诸如 <a href="https://d3js.org/">D3</a> 之类的库提供了<a href="https://github.com/d3/d3/wiki/Gallery">无限的可能性</a>。<br>
<img src="https://faded.auspicious.space/post-images/1587299024968.png" alt="" loading="lazy"><br>
徽标，图标和数据可视化是 SVG 使用的优秀范例。</p>
<h2 id="压缩-svg">压缩 SVG</h2>
<p>大多数情况下，在网页上使用工具如 SVGz（GZipped SVG）来压缩 SVG 文件是不必要的。你可以（并且应该）在服务器上应用此 Gzipping，但也是多此一举。能做的应该是通过清除 SVG 文件里矢量图形中不必要的锚点、元素和属性来减少文件大小。锚点绘制了矢量图像，因此，你需要确保已移除的锚点不会影响矢量图形的最终形状。如果您使用 Adobe Illustrator 编辑 SVG，请确保使用 <strong>导出&gt;导出为...</strong> 而不是 <strong>文件&gt;另存为...</strong> 进行保存，因为这样才能生成一个最小化的文件，<a href="https://helpx.adobe.com/illustrator/how-to/export-svg.html">其它优点</a>。在 Sketch 里, 注意不要使用不必要的文件夹，因为它们也会作为额外的标签被 SVG 保存。<br>
<img src="https://faded.auspicious.space/post-images/1587299183720.png" alt="" loading="lazy"><br>
清理不必要的节点是缩减 SVG 尺寸的一种途径。</p>
<p>元素是包含在 SVG 文件内的所有内容，包括开始和结束标签。矢量编辑软件，如 Adobe Illustrator 和 Sketch 可能会到处含有非必要元素和属性的 SVG。SVG 压缩器可用于删除这种多余的信息。<a href="https://compressor.io/">Compressor</a> 和 <a href="https://jakearchibald.github.io/svgomg/">SVGOMG</a> 等在线工具可以完成此工作。如果你是开发人员，而且不习惯清理和压缩 SVG，可以用自动执行工具 <a href="https://github.com/svg/svgo">SVGO</a>，如果你是设计师，请与该项目的开发人员谈谈 SVG 的最小化，以避免进行将这一项可以轻松自动化的工作手动完成。</p>
<p>在下面的例子里，这个从 Sketch 里导出的图标有 1,364 B。同一个图标在清理和压缩后，就只剩 460 B——缩小了 66%。</p>
<p>请看这个例子：<a href="https://codepen.io/brunomuler/pen/oBdMZL/">来自 Sketch 的 SVG 作者</a>布鲁诺·穆勒（Bruno Müller）(<a href="https://codepen.io/brunomuler">@brunomuler</a>) on <a href="https://codepen.io/">CodePen</a>。</p>
<p>对比：<a href="https://codepen.io/brunomuler/pen/BpxPWY/">优化后的 SVG</a>。</p>
<h1 id="文末思考">文末思考</h1>
<p>如同任何其他技术一般，图像格式也在不断发展。作为网页设计师和开发人员，我们的主要限制是浏览器支持。几年前，在 IE6 为主流浏览器的时代，PNG 还不能使用 Alpha 透明度。在不久的将来，也许我们会使用新的格式，如 <a href="https://developers.google.com/speed/webp/">Google's Webp</a> 或者其它仍未被创建出来的图片格式。</p>
<p>了解如何使用和优化每种图片格式将确保更好的用户体验。因为用户将能够更早地预览和接收内容，减少带宽的使用。它还将为设计人员提供了动画和响应式页面的新机会。</p>
<p>我希望这篇文章有助于澄清一些网络上关于图像格式的诸多不确定性的问题。如果你还有任何问题或建议，请在下方发表评论或与我联系。另外，如果觉得本文对你有帮助，不要忘了分享。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[进程间通信—IPC]]></title>
        <id>https://faded.auspicious.space/post/inter-process-communication/</id>
        <link href="https://faded.auspicious.space/post/inter-process-communication/">
        </link>
        <updated>2020-04-19T06:54:38.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p><a href="https://www.jianshu.com/p/5788fb2345ce">看图理解进程间通信IPC</a></p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p><a href="https://www.jianshu.com/p/5788fb2345ce">看图理解进程间通信IPC</a></p>
</blockquote>
<!-- more -->
<h1 id="什么是进程间通讯">什么是进程间通讯</h1>
<p>进程间通信（Inter-Process Communication 或 Interprocess Communication，简写 IPC）是指两个或两个以上进程（或线程）之间进行数据或信号交互的技术方案。</p>
<p>通常，IPC 一般包含客户端和服务器，客户端请求数据，服务器响应请求（比如分布式计算中就是这样）。</p>
<h1 id="有哪些-ipc-方法">有哪些 IPC 方法</h1>
<p><strong>IPC 方法适用的环境</strong></p>
<table>
<thead>
<tr>
<th>IPC 方法</th>
<th>操作系统或环境</th>
</tr>
</thead>
<tbody>
<tr>
<td>文件（File）</td>
<td>多数操作系统</td>
</tr>
<tr>
<td>信号（Singal）</td>
<td>多数操作系统</td>
</tr>
<tr>
<td>套接字（Socket）</td>
<td>多数操作系统</td>
</tr>
<tr>
<td>Unix 域套接字（Unix domain socket）</td>
<td>所有 POSIX 操作系统</td>
</tr>
<tr>
<td>消息队列（Message queue）</td>
<td>多数操作系统</td>
</tr>
<tr>
<td>管道（Pipe）</td>
<td>所有 POSIX 系统，Windows</td>
</tr>
<tr>
<td>命名管道（Named pipe 或 FIFO）</td>
<td>所有 POSIX 系统，Windows，Amiga OS 2.0+</td>
</tr>
<tr>
<td>共享内存（Shared memory）</td>
<td>所有 POSIX 系统，Windows</td>
</tr>
<tr>
<td>消息传递（Message passing）</td>
<td>用于 RPC、RMI、MPI 规范、Java RMI、CORBA、DDS、MSMQ、MailSlots、QNX 等</td>
</tr>
<tr>
<td>内存映射文件（Memory-mapped file）</td>
<td>所有 POSIX 系统，Windows</td>
</tr>
</tbody>
</table>
<h2 id="文件file">文件（File）</h2>
<p>存储在磁盘上的记录，或由文件服务器按需合成的记录，可以由多个进程访问。<br>
<img src="https://faded.auspicious.space/post-images/1587291327653.png" alt="" loading="lazy"></p>
<h2 id="信号signal">信号（Signal）</h2>
<p>系统消息从一个进程发送到另一个进程，一般不用于传输数据，而是用于远程传输命令。<br>
<img src="https://faded.auspicious.space/post-images/1587291380324.png" alt="" loading="lazy"></p>
<h2 id="套接字socket">套接字（Socket）</h2>
<p>通过网络接口将数据量发送到本机的不同进程或远程计算机。<br>
<img src="https://faded.auspicious.space/post-images/1587291456565.png" alt="" loading="lazy"></p>
<h2 id="unix域套接字unix-domain-socket">Unix域套接字（Unix domain socket）</h2>
<p>用于在同一台机器上运行的进程之间的通信。虽然因特网域套接字可用于同一目的，但 Unix 域套接字的效率更高。Unix 域套接字仅仅复制数据；它们并不执行协议处理，不需要添加或删除网络报头，无需计算检验和，不要产生顺序号，无需发送确认报文。<br>
<img src="https://faded.auspicious.space/post-images/1587291511768.png" alt="" loading="lazy"></p>
<h2 id="消息队列message-queue">消息队列（Message queue）</h2>
<p>类似于套接字的数据流，但消息有自己的结构，它允许多个进程只需要读写消息队列，而不需要直接相互连接。<br>
<img src="https://faded.auspicious.space/post-images/1587291552216.png" alt="" loading="lazy"></p>
<h2 id="管道pipe">管道（Pipe）</h2>
<p>管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。<br>
<img src="https://faded.auspicious.space/post-images/1587291588313.png" alt="" loading="lazy"></p>
<h2 id="命名管道named-pipe-或-fifo">命名管道（Named pipe 或 FIFO）</h2>
<p>命名管道可在同一台计算机的不同进程之间或在跨越一个网络的不同计算机的不同进程之间，支持可靠的、单向或双向的数据通信。<br>
<img src="https://faded.auspicious.space/post-images/1587291631500.png" alt="" loading="lazy"></p>
<h2 id="共享内存shared-memory">共享内存（Shared memory）</h2>
<p>允许多个进程访问同一个内存块，该内存块作为一个共享缓冲区，供进程间相互通信。<br>
<img src="https://faded.auspicious.space/post-images/1587291722486.png" alt="" loading="lazy"></p>
<h2 id="消息传递message-passing">消息传递（Message passing）</h2>
<p>一般在并发模型中，允许多个程序使用消息队列或者托管通道通信。<br>
<img src="https://faded.auspicious.space/post-images/1587291756578.png" alt="" loading="lazy"></p>
<h2 id="内存映射文件memory-mapped-file">内存映射文件（Memory-mapped file）</h2>
<p>类似于标准的文件，内存映射文件映射到 RAM，可以直接对内存地址进行更改，而不是更改输出流。<br>
<img src="https://faded.auspicious.space/post-images/1587291798527.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MBR、开机流程与主引导分区]]></title>
        <id>https://faded.auspicious.space/post/mbr-and-boot-loader/</id>
        <link href="https://faded.auspicious.space/post/mbr-and-boot-loader/">
        </link>
        <updated>2020-04-19T06:24:26.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p><a href="https://www.jianshu.com/p/808fa4d82798">MBR、开机流程与主引导分区</a></p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p><a href="https://www.jianshu.com/p/808fa4d82798">MBR、开机流程与主引导分区</a></p>
</blockquote>
<!-- more -->
<h1 id="预备知识">预备知识</h1>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/%E4%BA%92%E8%A3%9C%E5%BC%8F%E9%87%91%E5%B1%AC%E6%B0%A7%E5%8C%96%E7%89%A9%E5%8D%8A%E5%B0%8E%E9%AB%94">CMOS</a>：主板上记录了硬件参数的储存器。</li>
<li><a href="https://zh.wikipedia.org/wiki/BIOS#BIOS.E9.9F.8C.E9.AB.94">BIOS</a>：写入到主板 ROM 中的程序，开机时执行的第一个程序。</li>
<li><a href="https://zh.wikipedia.org/wiki/%E4%B8%BB%E5%BC%95%E5%AF%BC%E8%AE%B0%E5%BD%95%5D">MBR</a>：可引导设备的第一个扇区（一般情况下是硬盘中的第一扇区）中的主引导分区。</li>
<li><a href="https://zh.wikipedia.org/wiki/%E5%95%9F%E5%8B%95%E7%A8%8B%E5%BC%8F">Boot loader</a>：读取操作系统内核文件来执行的程序。</li>
</ul>
<h1 id="开始">开始</h1>
<p>学过计算机的肯定都知道操作系统是一个软件，我们平时用的软件都是基于操作系统提供的接口运行的。那么操作系统又是怎么运行的呢？</p>
<h2 id="step-1-bios">Step 1: BIOS</h2>
<p>在预备知识中我们就知道了，开机运行的第一个程序就是 BIOS，那么开机引导操作系统的切入点也肯定是它了。</p>
<p>BIOS 识别 CMOS 读取硬件信息，从中找出可开机设备，一般自然是硬盘了。</p>
<p>当然，可开机设备不一定是硬盘，或者说你有两个硬盘，这里就不做讨论了。</p>
<h2 id="step-2-mbr-boot-loader">Step 2: MBR &amp; Boot loader</h2>
<p>BIOS 找到第一个扇区之后就查找 MBR 的位置，这是最基本的引导程序（Boot loader），这个程序一旦启动，BIOS 的任务才算圆满。</p>
<p>MBR 中的引导程序运行，这个时候用户可以对开机选项进行操作，例如转交引导加载的任务给其他引导程序（之后还会提到）。</p>
<h2 id="step-3-operating-system">Step 3: Operating System</h2>
<p>什么都做完了，当然该操作系统登场，负责提供其基本功能。</p>
<h1 id="补充">补充</h1>
<h2 id="磁盘分区表">磁盘分区表</h2>
<p>Step 2 中提到了第一个扇区。实际上，这个扇区不止包含 MBR，它还包含了一个分区表，用来对硬盘进行分割，文件系统的最小单位是柱面，所以它是以记录柱面号来分割硬盘的。</p>
<p>例如第一分区是 1~100 柱面，那么分区记录项第一个的内容就是 1 和 100，其他以此类推。<br>
我们所谓的&quot;分区&quot;实际上就是对这个分区表的记录进行修改。</p>
<p>由于分区表只有 64 bytes，所以最多只能有 4 个分区，这四个分区被称为主（Primary）分区。<br>
那么你肯定要有疑问：分区可不一定只有 4 个啊。<br>
是的，这种情况下就有一个相对于主引导分区的概念——扩展（Extended）分区。</p>
<p>如果我们拿主分区的其中一个存放另外一个分区表储存更多的分区信息，那我们就可以拥有更多分区。不是么。有时间理解一下下图吧。</p>
<figure data-type="image" tabindex="1"><img src="https://faded.auspicious.space/post-images/1587277970316.png" alt="普遍的硬盘分区表" loading="lazy"></figure>
<p>这里需要注意的地方是，如果有 4 个主分区，我们就再也没有办法存放另外的分区信息，所以一般情况下会留下一个分区存放扩展分区信息，主分区因此最多只有 3 个。</p>
<p>扩展分区只能有一个（操作系统限制），扩展分区持续切割，形成新的分区，这就是逻辑分区（logical partition）。我们平时能作为数据访问的分区是主分区和逻辑分区，扩展分区不能格式化。</p>
<h2 id="多重引导">多重引导</h2>
<p>这里需要说明一下，每个分区都拥有自己的启动扇区，可以用来存放引导程序，并且该引导程序可以将管理权交给另一引导程序（其他分区的引导扇区）或者自己引导所在的分区，是的，可开机的内核文件不是在引导扇区内，而是在各分区内。</p>
<p>意思就是，你可以引导不止一种操作系统，根据你在 boot menu 的选择，可以引导任何在 MBR 指向中的系统。</p>
<ul>
<li>Linux 安装的时候可以选择安装在分区的启动扇区，或者 MBR，Linux 的 Loader 可以手动转换引导程序。</li>
<li>Windows 会覆盖掉 MBR 和自己所在的分区。你没有办法保留之前 MBR 中对 Linux 引导程序的指向。</li>
</ul>
<p>上述两个原因表明了为何需要先安装 Windows 操作系统，再安装 Linux，否则将不会在开机的时候看到 Linux 引导选项。</p>
<h2 id="guid-分区方案">GUID 分区方案</h2>
<p>相对于 MBR 分区方案，GUID有以下优点：</p>
<ol>
<li>支持 2TB 以上的大硬盘。</li>
<li>每个磁盘的分区个数几乎没有限制。为什么说“几乎”呢？是因为 Windows 系统最多只允许划分 128 个分区。不过也完全够用了。</li>
<li>分区大小几乎没有限制。又是一个“几乎”。因为它用 64 位的整数表示扇区号，即 0 ~18,446,744,073,709,551,616。夸张一点说，一个 64 位整数能代表的分区大小已经是个“天文数字”了，若干年内你都无法见到这样大小的硬盘，更不用说分区了。</li>
<li>分区表自带备份。在磁盘的首尾部分分别保存了一份相同的分区表。其中一份被破坏后，可以通过另一份恢复。</li>
<li>每个分区可以有一个名称（不同于卷标）。</li>
</ol>
<p>GUID 扩展了分区表头，并且兼容了 MBR（第一扇区还是留有 MBR 的空间，为了兼容不支持 GUID 的硬盘），分区信息存放于分区表中，由 GUID HEADER 中的信息标识引导程序 efi 所在的分区。</p>
<p>开机过程（以下是我个人的理解，欢迎指正）：</p>
<ol>
<li>BIOS 过程同 MBR 分区方案一致。</li>
<li>之后在 GUID HEADER 中查找 .efi 引导程序。</li>
<li>主引导程序扫描所有分区的引导扇区并运行其中的分区引导程序。</li>
<li>分区引导程序读取分区内容并引导操作系统。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何优雅地链式取值]]></title>
        <id>https://faded.auspicious.space/post/how-to-elegantly-optional-chaining/</id>
        <link href="https://faded.auspicious.space/post/how-to-elegantly-optional-chaining/">
        </link>
        <updated>2020-04-18T06:26:57.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p><a href="https://juejin.im/post/5ba08483e51d450e99430a7f">如何优雅地链式取值</a></p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p><a href="https://juejin.im/post/5ba08483e51d450e99430a7f">如何优雅地链式取值</a></p>
</blockquote>
<!-- more -->
<p>开发中，链式取值是非常正常的操作，如：</p>
<pre><code class="language-javascript">res.data.goods.list[0].price
</code></pre>
<p>但是对于这种操作报出类似于 <code>Uncaught TypeError: Cannot read property 'goods' of undefined</code> 这种错误也是再正常不过了，如果说是 <code>res</code> 数据是自己定义，那么可控性会大一些，但是如果这些数据来自于不同端（如前后端），那么这种数据对于我们来说我们都是不可控的，因此为了保证程序能够正常运行下去，我们需要对此校验：</p>
<pre><code class="language-javascript">if (res.data.goods.list[0] &amp;&amp; res.data.goods.list[0].price) {
// your code
}
</code></pre>
<p>如果再精细一点，对于所有都进行校验的话，就会像这样：</p>
<pre><code class="language-javascript">if (res &amp;&amp; res.data &amp;&amp; res.data.goods &amp;&amp; res.data.goods.list &amp;&amp; res.data.goods.list[0] &amp;&amp; res.data.goods.list[0].price){
// your code
}
</code></pre>
<p>不敢想象，如果数据的层级再深一点会怎样，这种实现实在是非常不优雅，那么如果优雅地来实现链式取值呢？</p>
<h1 id="optional-chaining">optional chaining</h1>
<p>这是一个出于 stage 2 的 ecma 新语法，目前已经有了 babel 的插件 <code>babel-plugin-transform-optional-chaining</code>，这种语法在 <code>swift</code> 中有，可以看下官方给的实例：</p>
<pre><code class="language-javascript">a?.b                          // undefined if `a` is null/undefined, `a.b` otherwise.
a == null ? undefined : a.b

a?.[x]                        // undefined if `a` is null/undefined, `a[x]` otherwise.
a == null ? undefined : a[x]

a?.b()                        // undefined if `a` is null/undefined
a == null ? undefined : a.b() // throws a TypeError if `a.b` is not a function
                              // otherwise, evaluates to `a.b()`

a?.()                        // undefined if `a` is null/undefined
a == null ? undefined : a()  // throws a TypeError if `a` is neither null/undefined, nor a function
                             // invokes the function `a` otherwise
</code></pre>
<h1 id="通过函数解析字符串">通过函数解析字符串</h1>
<p>我们可以通过函数解析字符串来解决这个问题，这种实现就是 <code>lodash</code> 的 <code>_.get</code> 方法。</p>
<pre><code class="language-javascript">var object = { a: [{ b: { c: 3 } }] };
var result = _.get(object, 'a[0].b.c', 1);
console.log(result);
// output: 3
</code></pre>
<p>实现起来也非常简单，只是简单的字符串解析而已：</p>
<pre><code class="language-javascript">function get (obj, props, def) {
    if((obj == null) || obj == null || typeof props !== 'string') return def;
    const temp = props.split('.');
    const fieldArr = [].concat(temp);
    temp.forEach((e, i) =&gt; {
        if(/^(\w+)\[(\w+)\]$/.test(e)) {
            const matchs = e.match(/^(\w+)\[(\w+)\]$/);
            const field1 = matchs[1];
            const field2 = matchs[2];
            const index = fieldArr.indexOf(e);
            fieldArr.splice(index, 1, field1, field2);
        }
    })
    return fieldArr.reduce((pre, cur) =&gt; {
        const target = pre[cur] || def;

        if(target instanceof Array) {
            return [].concat(target);
        }
        if(target instanceof Object) {
            return Object.assign({}, target)
        }
        return target;
    }, obj)
}
</code></pre>
<pre><code class="language-javascript">var c = {a: {b : [1,2,3] }}
get(c ,'a.b')     // [1,2,3]
get(c, 'a.b[1]')  // 2
get(c, 'a.d', 12)  // 12
</code></pre>
<h1 id="使用解构赋值">使用解构赋值</h1>
<p>这个思路是来自 github 上 <a href="https://github.com/you-dont-need/You-Dont-Need-Lodash-Underscore">You-Dont-Need-Lodash-Underscore</a> 这个仓库，看到这个的时候真的佩服。</p>
<pre><code class="language-javascript">const c = {a:{b: [1,2,3,4]}}

const { a: result } = c;
// result : {b: [1,2,3,4]}
const {a: { c: result = 12 }} = c
// result: 12
</code></pre>
<p>当然，这个时候为了保证不报 <code>uncaught Typeerror</code>，我们仍然需要定义默认值， 就像这样, 貌似如果不加 <code>lint</code> 可读性堪忧。</p>
<pre><code class="language-javascript">const {a: {c: {d: result2} = {}}} = c
</code></pre>
<h1 id="使用-proxy">使用 Proxy</h1>
<p>这个是组内同事提到的，一个简单实现如下：</p>
<pre><code class="language-javascript">function pointer(obj, path = []) {
    return new Proxy(() =&gt; {}, {
        get (target, property) {
            return pointer(obj, path.concat(property))
        },
        apply (target, self, args) {
            let val = obj;
            let parent;
            for(let i = 0; i &lt; path.length; i++) {
                if(val === null || val === undefined) break;
                parent = val;
                val = val[path[i]]    
            }
            if(val === null || val === undefined) {
                val = args[0]
            }
            return val;
        }
    })
}
</code></pre>
<p>我们可以这样使用：</p>
<pre><code class="language-javascript">let c = {a: {b: [1, ,2 ,3]}}

pointer(c).a();   // {b: [1,2,3]}

pointer(c).a.b(); // [1,2,3]

pointer(d).a.b.d('default value');  // default value
</code></pre>
<p>这差不多就是心中所谓的优雅了。</p>
<p>综上，在实际工作中，使用方法四会是最优雅，可读性也非常强，但考虑到浏览器的话，可能方法二会更加常用，当然，如果你所要取的值层级不是太深，你组内的同事要严格的 <code>lint</code>，方法三也不失为一种好的选择。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[& * # 这三个是什么符号？]]></title>
        <id>https://faded.auspicious.space/post/names-of-three-sign/</id>
        <link href="https://faded.auspicious.space/post/names-of-three-sign/">
        </link>
        <updated>2020-04-18T06:17:34.000Z</updated>
        <content type="html"><![CDATA[<p><code>&amp;</code> 这个符号的名字是 ampersand，含义就是“and”。听到这个词，要意识到老师在说啥。<br>
<code>*</code> 这个符号的名是 asterisk，一种符号，在文章中一般表示，底下有脚注。<br>
<code>#</code> 这个符号的名字是 hash，是不是很难受的感觉，在英文里的意思是表示数字，比如我家住 18 号 401，写地址可以写成 #18, 401，另外在美国还用于表示磅这个重量单位，比如 2# of sugar，大概两斤糖；<br>
<code>～</code> 这个符号的名字最难找，叫 tilde，从西班牙语或者葡萄牙语过来的名字，参看维基百科；<br>
<code>`</code> 这个符号，我一般念做 back tick，不过我也没查到，我看百科里叫 back quote；<br>
<code>^</code> 这个符号，叫 caret，在 ASCII 里面是一个Space Symbol。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[TCP——套接口编程]]></title>
        <id>https://faded.auspicious.space/post/tcp-suite-programming/</id>
        <link href="https://faded.auspicious.space/post/tcp-suite-programming/">
        </link>
        <updated>2020-04-18T04:29:36.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p><a href="https://juejin.im/post/5bc01a34f265da0ac446ce96">值得收藏的TCP套接口编程文章</a></p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p><a href="https://juejin.im/post/5bc01a34f265da0ac446ce96">值得收藏的TCP套接口编程文章</a></p>
</blockquote>
<!-- more -->
<h1 id="tcp-客户端-服务器典型事件">TCP 客户端-服务器典型事件</h1>
<p>下图是 TCP 客户端与服务器之间交互的一系列典型事件时间表：</p>
<ol>
<li>首先启动服务器，等待客户端连接。</li>
<li>启动客户端，连接到服务器。</li>
<li>客户端发送一个请求给服务器，服务器处理请求，响应客户端。</li>
<li>循环步骤3。</li>
<li>客户端给服务器发一个文件结束符，关闭客户端连接。</li>
<li>服务器也关闭连接。</li>
</ol>
<figure data-type="image" tabindex="1"><img src="https://faded.auspicious.space/post-images/1587184330372.png" alt="基本TCP客户-服务器程序的套接口函数" loading="lazy"></figure>
<h1 id="套接口编程基本函数">套接口编程基本函数</h1>
<h2 id="socket-函数">socket 函数</h2>
<p>为了执行网络 I/O，一个进程（无论是服务端还是客户端）必须做的第一件事情就是调用 <code>socket</code> 函数。</p>
<pre><code class="language-c">#include &lt;sys/socket.h&gt; /* basic socket definitions */
int socket(int family, int type, int protocol);/* 返回：非负描述字——成功，-1——出错 */
</code></pre>
<h3 id="family协议族">family——协议族</h3>
<table>
<thead>
<tr>
<th>族</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>AF_INET</td>
<td>IPv4 协议</td>
</tr>
<tr>
<td>AF_INET6</td>
<td>IPv6 协议</td>
</tr>
<tr>
<td>AF_LOCAL</td>
<td>Unix 域协议</td>
</tr>
<tr>
<td>AF_ROUTE</td>
<td>路由套接口</td>
</tr>
<tr>
<td>AF_KEY</td>
<td>密钥套接口</td>
</tr>
</tbody>
</table>
<h3 id="type套接口类型">type——套接口类型</h3>
<table>
<thead>
<tr>
<th>类型</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>SOCK_STREAM</td>
<td>字节流套接口</td>
</tr>
<tr>
<td>SOCK_DGRAM</td>
<td>数据报套接口</td>
</tr>
<tr>
<td>SOCK_RAW</td>
<td>原始套接口</td>
</tr>
</tbody>
</table>
<h3 id="有效的-family-和-type-组合简略版">有效的 family 和 type 组合（简略版）</h3>
<table>
<thead>
<tr>
<th></th>
<th>AF_INET</th>
<th>AF_INET6</th>
</tr>
</thead>
<tbody>
<tr>
<td>SOCK_STREAM</td>
<td>TCP</td>
<td>TCP</td>
</tr>
<tr>
<td>SOCK_DGRAM</td>
<td>UDP</td>
<td>UDP</td>
</tr>
<tr>
<td>SOCK_RAW</td>
<td>IPv4</td>
<td>IPv6</td>
</tr>
</tbody>
</table>
<p><code>socket</code> 函数返回一个套接口描述字，简称套接字（<code>sockfd</code>）。获取套接字无需指定地址，只需要指定协议族和套接口类型（如上表中的组合）。</p>
<h2 id="connect-函数">connect 函数</h2>
<p>TCP 客户用 <code>connect</code> 函数来建立一个与 TCP 服务器的连接。</p>
<pre><code class="language-c">#include &lt;sys/socket.h&gt; /* basic socket definitions */
int connect(int sockfd, const struct sockaddr * servaddr, socklen_t addrlen);/* 返回：0——成功，-1——出错 */
</code></pre>
<ul>
<li>参数 <code>sockfd</code> 便是 <code>socket</code> 函数返回的套接口描述字。</li>
<li>套接口地址结构 <code>servaddr</code> 必须包含服务器的 IP 地址和端口号。</li>
<li>客户端不必非要绑定一个端口（调用 <code>bind</code> 函数），内核会选择源 IP 和一个临时端口。</li>
<li><code>connect</code> 函数会触发 TCP 三次握手。有可能出现下面的错误情况：
<ol>
<li>
<p>客户端未收到 <code>SYN</code> 分节的响应：<br>
第一次发出未收到，间隔 6s 再发一次，再没收到，隔 24s 再发一次，总共等待 75s 还没收到则返回错误（<code>ETIMEDOUT</code>）。可以用时间日期程序验证一下：</p>
<p>查看本地网络信息：</p>
<pre><code class="language-bash">
JACKIELUO-MC0:intro jackieluo$ ifconfig
en0: flags=8863&lt;UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
ether f4:0f:24:2a:72:a6
inet6 fe80::1830:dbd:1b29:2989%en0 prefixlen 64 secured scopeid 0x6
inet 192.168.0.101 netmask 0xffffff00 broadcast 192.168.0.255
nd6 options=201&lt;PERFORMNUD,DAD&gt;
media: autoselect
status: active
</code></pre>
<p>将程序指向本地地址 <code>192.168.0.101</code>（确保时间日期服务器程序已运行），成功：</p>
<pre><code class="language-bash">
JACKIELUO-MC0:intro jackieluo$ ./daytimetcpcli 192.168.0.101
Sat Oct  6 17:06:55 2018
</code></pre>
<p>将程序指向本地子网地址 <code>192.168.0.102</code>，其主机ID（102）不存在，等待几分钟后超时返回：</p>
<pre><code class="language-bash">
JACKIELUO-MC0:intro jackieluo$ ./daytimetcpcli 192.168.0.102
connect error: Operation timed out
</code></pre>
</li>
<li>
<p>收到 <code>RST</code>：<br>
即服务器主机在指定端口上没有等待连接的进程，这称为“<code>hard error</code>”，客户端一接收到 <code>RST</code>，马上返回错误（<code>ECONNREFUSED</code>）。验证：</p>
<p>关闭之前本机运行的 <code>daytimetcpsrv</code> 进程</p>
<p>将程序指向本地地址<code>192.168.0.101</code>：</p>
<pre><code class="language-bash">
JACKIELUO-MC0:intro jackieluo$ ./daytimetcpcli 192.168.0.101
connect error: Connection refused
</code></pre>
</li>
<li>
<p>发出的 <code>SYN</code> 在路由器上引发了目的不可达 <code>ICMP</code> 错误：<br>
这个错误被称为“<code>soft error</code>”，最终返回 <code>EHOSTUNREACH</code> 或者 <code>ENETUNREACH</code>。</p>
</li>
</ol>
</li>
</ul>
<h2 id="bind-函数">bind 函数</h2>
<p>函数 <code>bind</code> 为套接口分配一个本地协议地址，包括 IP 地址和端口号。</p>
<pre><code class="language-c">#include &lt;sys/socket.h&gt; /* basic socket definitions */
int bind(int sockfd, const struct sockaddr * servaddr, socklen_t addrlen);/* 返回：0——成功，-1——出错 */
</code></pre>
<ul>
<li>客户端可以不调用这个函数，由内核选择一个本地 IP 的临时端口就好。</li>
<li>服务器一般都会调用 <code>bind</code> 函数绑定 IP 地址和端口，供客户端调用。一个例外是 RPC（远程过程调用）服务器，它由内核为其选择临时端口。然后通过 RPC 端口映射器进行注册，客户端与该服务器连接之前，先通过端口映射器获取服务器的端口。</li>
<li>进程可以把一个特定的 IP 地址捆绑到它的套接口上。对于客户端，它发送的请求，源IP地址就是这个地址；对于服务器，如果绑定了 IP 地址，则只接受目的地为此 IP 地址的客户连接。</li>
<li>如果服务器不把 IP 地址绑定到套接口上，那么内核把客户端发送 <code>SYN</code> 所在分组的目的 IP 地址作为服务器的源 IP 地址。（即服务器收到 <code>SYN</code> 的 IP）</li>
</ul>
<p>给函数 <code>bind</code> 指定用于捆绑的 IP 地址和 / 或端口号的结果：</p>
<table>
<thead>
<tr>
<th>IP地址</th>
<th>端口</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>0</td>
<td>内核选择 IP 地址和端口</td>
</tr>
<tr>
<td></td>
<td>非 0</td>
<td>内核选择 IP 地址，进程指定端口</td>
</tr>
<tr>
<td>本地 IP 地址</td>
<td>0</td>
<td>进程选择 IP 地址，内核指定端口</td>
</tr>
<tr>
<td>本地 IP 地址</td>
<td>非 0</td>
<td>进程选择 IP 地址和端口</td>
</tr>
</tbody>
</table>
<h2 id="listen-函数">listen 函数</h2>
<p>函数 <code>listen</code> 仅被 TCP 服务器调用。</p>
<pre><code class="language-c">#include &lt;sys/socket.h&gt; /* basic socket definitions */
int listen(int sockfd, int backlog);/* 返回：0——成功，-1——出错 */
</code></pre>
<p>调用函数 <code>socket</code> 函数创建的套接口，默认是主动方，下一步应是调用 <code>connect</code>，<code>CLOSED</code> 的下一个状态是 <code>SYN_SENT</code>（见 TCP 状态转换图）。而函数 <code>listen</code> 将套接口转换成被动方，告诉内核，应接受指向此套接口的连接请求，<code>CLOSED</code> 状态变成 <code>LISTEN</code>。</p>
<p>函数 <code>listen</code> 的第二个参数 <code>backlog</code> 表示内核为此套接口排队的最大连接数。对于给定的监听套接口，内核会维护两个队列：</p>
<ol>
<li>未完成连接队列（incomplete connection queue）<code>SYN</code> 分节已由客户发出，到达服务器，正在进行 TCP 的三路握手。此时这些套接口处于 <code>SYN_RCVD</code> 状态。</li>
<li>已完成连接队列（completed connection queue）<code>SYN</code> 分节已由客户发出，到达服务器，并且已完成三路握手。此时这些套接口处于 <code>ESTABLISHED</code> 状态。</li>
<li>当来自客户的 <code>SYN</code> 到达时，TCP 在未完成连接队列中创建一个新条目，直到三路握手中，第三个分节（客户对服务 <code>SYN</code> 的 <code>ACK</code>）到达，这个条目移到已完成连接队列的队尾。</li>
<li>当进程调用 <code>accept</code> 函数时，已完成连接队列的头部条目返回给进程。</li>
<li>两个队列之和不能超过 <code>backlog</code>。</li>
<li>当一个客户 <code>SYN</code> 到达时，若这两个队列都是满的，TCP 就忽略此分节，且不发送 <code>RST</code>。客户 TCP 将重发 <code>SYN</code>，期望不久就能在队列中找到空闲位置。<br>
<img src="https://faded.auspicious.space/post-images/1587185907119.png" alt="" loading="lazy"><br>
TCP 为监听套接口维护的两个队列。</li>
</ol>
<h2 id="accept-函数">accept 函数</h2>
<p>函数 <code>accept</code> 由 TCP 服务器调用，从已完成连接队列头部返回下一个已完成连接，若该队列为空，则进程睡眠（假定套接口为默认的阻塞方式）。</p>
<pre><code class="language-c">#include &lt;sys/socket.h&gt; /* basic socket definitions */
int accept(int sockfd, struct sockaddr *cliaddr, socklen_t *addrlen);/* 返回：非负描述字——成功，-1——出错 */
</code></pre>
<p>函数 <code>accept</code> 的第一个参数和返回值都是套接口描述字。其中，</p>
<ol>
<li>第一个参数，称为监听套接口描述字，即由函数 <code>socket</code> 返回，也用于 <code>bind</code>，<code>listen</code> 的第一个参数。</li>
<li>返回值，称为已连接套接口描述字。</li>
</ol>
<p>通常一个服务器，只生成一个监听套接口描述字，直到其关闭。而内核为每个被接受的客户连接，创建一个已连接套接口，当客户连接完成时，关闭该已连接套接口。</p>
<p>注意到 <code>intro/daytimetcpsrv.c</code> 中，后两个参数传的都是空指针，这是因为我们不关注客户的身份，无需知道客户的协议地址。</p>
<pre><code class="language-c">connfd = Accept(listenfd, (SA *) NULL, NULL);
</code></pre>
<p>稍作修改，不再传入空指针，见 <code>intro/daytimetcpsrv1.c</code>：</p>
<pre><code class="language-c">socklen_t len;
struct sockaddr_in servaddr, cliaddr;
...
connfd = Accept(listenfd, (SA *) &amp;cliaddr, &amp;len);
printf(&quot;connection from %s, port %d\n&quot;,
    Inet_ntop(AF_INET, &amp;cliaddr.sin_addr, buff, sizeof(buff)),
    ntohs(cliaddr.sin_port));
</code></pre>
<p>kill 掉之前的 <code>daytimetcpsrv</code> 进程：</p>
<pre><code class="language-bash">
$ sudo lsof -i -P | grep -i &quot;listen&quot;
daytimetc 80986           root    3u  IPv4 0xae12d925e4528793      0t0    TCP *:13 (LISTEN)
$ sudo kill -9 80986
</code></pre>
<p>编译运行新的服务端程序：</p>
<pre><code class="language-bash">
$ make daytimetcpsrv1.c daytimetcpsrv1
$ ./daytimetcpsrv1
</code></pre>
<p>重复执行客户端程序，发几个请求：</p>
<pre><code class="language-bash">
$ ./daytimetcpcli 127.0.0.1
Wed Sep 26 14:11:20 2018
$ ./daytimetcpcli 127.0.0.1
Wed Sep 26 14:17:06 2018
</code></pre>
<p>查看服务端打印：</p>
<pre><code class="language-bash">
connection from 127.0.0.1, port 58201
connection from 127.0.0.1, port 58342
</code></pre>
<p>注意到，由于客户端程序没有调用 <code>bind</code> 函数，内核为它的协议地址选择了源 <code>ip</code> 作为 IP 地址，临时端口号也发生了变化。</p>
<h2 id="fork-和-exec-函数">fork 和 exec 函数</h2>
<pre><code class="language-c">#include &lt;unistd.h&gt;
pid_t fork(void);/* 返回：在子进程中为0，在父进程中为子进程ID，-1——出错 */
</code></pre>
<p><code>fork</code> 函数调用一次，却返回两次。</p>
<ol>
<li>在调用它的进程（即父进程），它返回一次，返回值是派生出来的子进程的进程 ID。 父进程可能有很多子进程，必须通过返回值跟踪记录子进程 ID。</li>
<li>在子进程，它还返回一次，返回值为 0。 子进程只有一个父进程，总可以通过 <code>getppid</code> 来得到父进程的 ID。</li>
</ol>
<p>通过返回值可以判断当前进程是子进程还是父进程。</p>
<p>父进程在调用 <code>fork</code> 之前打开的所有描述字在函数 <code>fork</code> 返回后都是共享的。网络服务器会利用这一特性：</p>
<ol>
<li>父进程调用 <code>accept</code>。</li>
<li>父进程调用 <code>fork</code>，已连接套接口就在父进程与子进程间共享。（一般来说就是子进程读、写已连接套接口，而父进程关闭已连接套接口）。</li>
</ol>
<p><code>fork</code> 有两个典型应用：</p>
<ol>
<li>一个进程为自己派生一个拷贝，并发执行任务，这也是典型的并发网络服务器模型。</li>
<li>一个进程想执行其他的程序，于是调用 <code>fork</code> 生成一个拷贝，利用子进程调用 <code>exec</code> 来执行新的程序。典型应用是 <code>shell</code>。</li>
</ol>
<p>以文件形式存储在硬盘上的可执行程序若要被执行，需要由一个现有进程调用 <code>exec</code> 函数。我们将调用 <code>exec</code> 的进程称为调用进程，新程序的进程 ID 并不改变，仍处于当前进程。</p>
<h1 id="小结">小结</h1>
<p>客户和服务器，从调用 <code>socket</code> 开始，返回一个套接口描述字。客户调用 <code>connect</code>，服务器调用 <code>bind</code>、<code>listen</code>、<code>accept</code>。最后套接口由 <code>close</code> 关闭。</p>
<p>多数 TCP 服务器是调用 <code>fork</code> 来实现并发处理多客户请求的。多数 UDP 服务器则是迭代的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Git——超详实教程与命令大全]]></title>
        <id>https://faded.auspicious.space/post/git-super-detailed-tutorials-and-commands/</id>
        <link href="https://faded.auspicious.space/post/git-super-detailed-tutorials-and-commands/">
        </link>
        <updated>2020-04-17T04:05:39.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p><a href="https://juejin.im/post/5bd2a0d8e51d457a4e0d4fd5">超详实Git简明教程与命令大全</a></p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p><a href="https://juejin.im/post/5bd2a0d8e51d457a4e0d4fd5">超详实Git简明教程与命令大全</a></p>
</blockquote>
<!-- more -->
<p><a href="https://git-scm.com/">Git</a>（wiki: <a href="https://en.wikipedia.org/wiki/Git">en</a>  <a href="https://zh.wikipedia.org/wiki/Git">chs</a> ）是一个免费开源的分布式版本控制系统，由 <code>Linux</code> 内核作者 Linus Torvalds 开发，大型开源项目 Linux Kernel、Android、Chromium、Mono、DotNet、UE4 等都使用 Git 管理项目著名 github 网站使用 Git 托管所有项目代码，Git 的代码也托管在 github 上，链接为：<a href="github.com/git">github.com/git</a> 与集中式版本控制系统（开源软件：SVN；免费软件：CVS；商业软件：微软的 VSS、IBM 的 Rational ClearCase）相比。</p>
<p><strong>Git 优点</strong>：</p>
<ol>
<li>本地是版本库的完整镜像，因此支持离线工作；</li>
<li>绝大多数操作都只需要访问本地文件和资源，而且与每个提交都是所有文件的完整副本，因此速度非常快；</li>
<li>强大快捷的分支功能，非常适合非线性开发过程。</li>
</ol>
<p><strong>Git 缺点</strong>：</p>
<ol>
<li>只能全量整体，而不能以子目录和分支为单位进行更新、提交等操作；</li>
<li>子目录和分支不能单独进行权限控制；</li>
<li>由于每个提交都是所有文件的完整副本，因此更占磁盘空间。</li>
</ol>
<p><img src="https://faded.auspicious.space/post-images/1587098525528.png" alt="" loading="lazy"><br>
注：SVN 等集中式版本控制系统存储每个文件与初始化版本的差异。<br>
<img src="https://faded.auspicious.space/post-images/1587098560926.png" alt="" loading="lazy"><br>
注：Git 每个提交都是所有文件的完整副本，使得 Git 在回溯到某个提交时，不会对所有文件执行差异计算还原，因此速度会非常快。</p>
<p>这使得源代码、配置文件等更适合用 Git 来管理，而资源等较大的二进制文件则容易导致版本库体积膨胀。</p>
<p>在项目实践中，对于资源等较大的二进制文件可以采用 <a href="https://git-lfs.github.com/">Git-LFS</a> 来管理，UE4 则是使用自己开发的 GitDependencies 来管理。</p>
<h1 id="基本概念">基本概念</h1>
<ul>
<li><code>origin</code>：默认远程版本库名。</li>
<li><code>master</code>：默认分支名。</li>
<li><code>origin/master</code>：远程默认分支名。</li>
<li><code>HEAD</code>：当前分支顶端 <code>Commit</code> 的别名，即当前分支最近的一个提交的 <code>SHA-1</code> 哈希值。</li>
<li><code>ORIG_HEAD</code>：上次 <code>HEAD</code> 指针的位置。注：当执行 <code>git reset / git pull / git merge</code> 命令时，<code>git</code> 会把老的 <code>HEAD</code> 拷贝到文件 <code>.git/ORIG_HEAD</code> 中，在后续命令中可以使用 <code>ORIG_HEAD</code> 引用这个提交。</li>
<li><code>commit</code>（提交）：每个 <code>commit</code> 都是全部文件的完整快照，并用一个 <code>commitID</code>（基于文件的内容或目录结构计算出来的 40 位十六进制的 <code>SHA-1</code> 哈希值） 来唯一标志。从某个角度上来说，Git 维护的就是一个 <code>commitID</code> 有向无环图。</li>
<li><code>detached HEAD</code>：<code>HEAD</code> 没有指向任何分支的状态。一般有以下几种情况会出现这种情况：
<ol>
<li>使用 <code>checkout</code> 命令跳到某个没有分支指着的 <code>commit</code> 时；</li>
<li><code>rebase</code> 处理冲突时所处的状态；</li>
<li>切换到某个远程分支 <code>cache</code> 上时。</li>
</ol>
</li>
</ul>
<p>在 Git 中，在执行命令时，一定要清楚：你在哪？对谁执行这个命令？ 本文使用 git 版本为：<code>git version 2.13.0.windows</code></p>
<p>运行命令行建议使用：<code>git bash</code>（可通过右键菜单 <code>Git Bash here</code> 来启动），主要有3个原因：</p>
<ol>
<li>在 <code>Windows</code> 的 <code>cmd</code> 下执行 <code>git log</code> 等需要显示多页内容的命令时，会导致 <code>cmd</code> 卡死（有时按 <code>Q</code> 键也没法退出）；</li>
<li><code>git bash</code> 中可以使用 <code>MinGW</code> 中自带的 <code>Linux</code> 环境下常用的命令工具；</li>
<li><code>git bash</code> 着色做得更好，利于阅读。</li>
</ol>
<h1 id="图解常见操作">图解常见操作</h1>
<ul>
<li><code>Working Directory</code>：即工作区。操作系统层面的目录树结构，也可以理解为一个 <code>tree</code> 目录对象。</li>
<li><code>Stage(Index)</code>：即暂存区，为等待 <code>Commit</code> 的文件列表。是以扁平的文件清单实现的，不过从理解层面上也可以理解为 <code>tree</code> 目录对象。</li>
<li><code>Local Repository</code>(History)：本地版本库。有向无环图，其每一个节点都是一个 <code>tree</code> 目录对象。</li>
<li><code>Remote Repository</code>：远程版本库。有向无环图，其每一个节点都是一个 <code>tree</code>目录对象。</li>
</ul>
<p><img src="https://faded.auspicious.space/post-images/1587099496728.png" alt="" loading="lazy"><br>
注：图中 <code>git checkout -- &lt;file&gt;</code> 1、2 步骤的含义是当在暂存区中有修改时，优先使用暂存区中的修改覆盖工作区。</p>
<h1 id="svn-命令对比一览">SVN 命令对比一览</h1>
<table>
<thead>
<tr>
<th>svn</th>
<th>git</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>svn checkout</td>
<td>git clone</td>
<td>检出项目</td>
</tr>
<tr>
<td>svn update</td>
<td>git fetch<br>git pull</td>
<td>更新</td>
</tr>
<tr>
<td>svn commit</td>
<td>git commit<br>git push</td>
<td>提交</td>
</tr>
<tr>
<td>svn add</td>
<td>git add</td>
<td>添加</td>
</tr>
<tr>
<td>svn mv</td>
<td>git mv</td>
<td>移动</td>
</tr>
<tr>
<td>svn rm</td>
<td>git rm</td>
<td>删除</td>
</tr>
<tr>
<td>svn status</td>
<td>git status</td>
<td>查看状态</td>
</tr>
<tr>
<td>svn log</td>
<td>git log</td>
<td>查看 log</td>
</tr>
<tr>
<td>svn diff</td>
<td>git diff</td>
<td>查看差异</td>
</tr>
<tr>
<td>svn revert</td>
<td>git checkout<br>git reset<br>git revert</td>
<td>撤销、丢弃修改</td>
</tr>
<tr>
<td>svn copy</td>
<td>git checkout -b/-B<br>git branch</td>
<td>创建分支</td>
</tr>
<tr>
<td>svn switch</td>
<td>git checkout</td>
<td>切换分支</td>
</tr>
<tr>
<td>svn copy</td>
<td>git tag</td>
<td>创建tag</td>
</tr>
<tr>
<td>svn merge</td>
<td>git merge<br>git rebase</td>
<td>分支合并</td>
</tr>
</tbody>
</table>
<h1 id="文件存储机制">文件存储机制</h1>
<p>Git 存储使用的是一个内容寻址的文件系统，其核心部分是一个简单的键值对（<code>key-value</code>）数据库，当向数据库中插入任意类型的内容，它会返回一个 40 位十六进制的 <code>SHA-1</code> 哈希值用作索引。在版本库中，Git 维护的数据结构有：以下 4 种对象及索引，并通过保存 <code>commitID</code> 有向无环图的 <code>log</code> 日志来维护与管理项目的修订版本和历史信息。</p>
<ul>
<li><code>blob</code> — 1 个 <code>blob</code> 保存 1 个文件的 1 个版本的数据。</li>
<li><code>tree</code> — 表示 1 个目录，记录着目录里所有文件 <code>blob</code> 哈希值、文件名子目录名及其他元数据。通过递归引用其他目录树，从而建立一个包含文件和子目录的完整层次结构。</li>
<li><code>commit</code>  — 1 个提交对象保存版本库中每一次变化的元数据，每个提交对象指向一个版本的 <code>git</code> 目录树对象。</li>
<li><code>tag</code> — 分为轻量标签和附注标签。轻量标签实际上是一个特定提交的引用，附注标签是存储在 <code>git</code> 中的一个完整可被校验的对象（保存在 <code>.git/refs/tags</code> 中），还包含打标签者的名字、E-mail、日志、注释等信息。</li>
</ul>
<p><code>git</code> 使用 <code>zlib</code> 将头部信息（对象类型：<code>blob</code> 或 <code>tree</code> 或 <code>commit</code> + 1 个空格 + 数据内容长度 + 1 个空字节）和对象数据拼接一起的内容进行压缩存储成一个文件。</p>
<p>压缩的文件被十六进制的 <code>SHA-1</code> 哈希值命名，该文件可以用 <code>pigz.exe -dz &lt;文件路径&gt;</code> 来解压查看。注：Windows 版的 <code>pigz.exe</code> 可以从<a href="https://sourceforge.net/projects/pigzforwindows/">这儿</a>下载。</p>
<p>40 位十六进制的 <code>SHA-1</code> 哈希值 <code>= sha1(&quot;blob/tree/commit &quot; + filesize + &quot;\0&quot; + data)</code>， 如：<code>sha1(&quot;blob 7\0foobar\n&quot;) = &quot;323fae03f4606ea9991df8befbb2fca795e648fa&quot;</code>   注：<code>\n</code> 的二进制为 <code>0a</code>。<br>
<img src="https://faded.auspicious.space/post-images/1587100311371.png" alt="" loading="lazy"></p>
<h1 id="底层命令剖析-git-对象">底层命令—剖析 Git 对象</h1>
<ul>
<li>
<p><code>find .git/objects -type f</code> // 用 <code>find</code> 命令查看 <code>.git/objects</code> 目录（递归子目录）中的所有文件。</p>
</li>
<li>
<p><code>git rev-list --objects --all</code> // 查看所有 <code>git</code> 对象的 <code>SHA-1</code> 哈希值与文件名的对应关系。</p>
</li>
<li>
<p><code>git rev-list --objects --all | grep 83c4fbc43a6f187d4e8a247a1c9aced872b2315d</code> // 查看 <code>SHA-1</code> 哈希值为 <code>83c4fbc43a6f187d4e8a247a1c9aced872b2315d</code> 的文件名。</p>
</li>
<li>
<p><code>echo &quot;Hello World!&quot; | git hash-object --stdin</code> // 计算内容为 <code>Hello World!</code> 文件的 <code>SHA-1</code> 哈希值。</p>
</li>
<li>
<p><code>echo &quot;Hello World!&quot; | git hash-object -w --stdin</code> // 计算内容为 <code>Hello World!</code> 文件的 <code>SHA-1</code> 哈希值并写入到当前 <code>git</code> 本地版本库中。</p>
</li>
<li>
<p><code>git hash-object README.txt</code> // 查看 <code>README.txt</code> 的 <code>SHA-1</code> 哈希值。</p>
</li>
<li>
<p><code>git hash-object -w README.txt</code> // 查看 <code>README.txt</code> 的 <code>SHA-1</code> 哈希值并写入到当前 <code>git</code> 本地版本库中。</p>
</li>
<li>
<p><code>git cat-file -p master^^{tree}</code> // 查看 <code>master</code> 分支 <code>HEAD</code> 指针 <code>git</code> 目录（<code>tree</code> 对象）下的各子目录（<code>tree</code> 对象）和文件（<code>blob</code> 对象）的 <code>SHA-1</code> 哈希值。</p>
<pre><code class="language-bash">100644 blob 7abd3a56703ad4a7120571967f5d06607b5e5502 README.txt
040000 tree 9f448c40e684dc38109574007c661277c815fb7e ss
</code></pre>
<p>注：<code>040000</code>：表示目录；<code>100644</code>：表示一般文件；<code>100755</code>：表示可执行文件；<code>120000</code>：表示符号链接。</p>
</li>
<li>
<p><code>git cat-file -p 7abd3a56703ad4a7120571967f5d06607b5e5502</code> // 查看 <code>SHA-1</code> 哈希值为 <code>7abd3a56703ad4a7120571967f5d06607b5e5502</code> 文件的内容。</p>
</li>
<li>
<p><code>git show 7abd3a56703ad4a7120571967f5d06607b5e5502</code> // 查看 <code>SHA-1</code> 哈希值为 <code>7abd3a56703ad4a7120571967f5d06607b5e5502</code> 文件的内容。</p>
</li>
<li>
<p><code>git cat-file -t f3961f5</code> // 查看 <code>f3961f5</code> 提交对象的类型：显示为 <code>commit</code>。</p>
</li>
<li>
<p><code>git cat-file -p f3961f5</code> // 查看 <code>f3961f5</code> 提交对象的信息：包含 <code>git</code> 目录（<code>tree</code> 对象）、上次提交对象的 <code>SHA-1</code> 哈希值及提交时 <code>Author</code>、<code>Date</code> 和注释信息。</p>
<pre><code class="language-bash">tree ead34240822030a3f71df4fc351057d80d7d83f8
parent 33d5bbc5d61b024aab5078e40548c4e3da808e0e
author nicochen &lt;nicochen@tencent.com&gt; 1537258258 +0800
committer nicochen &lt;nicochen@tencent.com&gt; 1537258258 +0800
123 desc txt
</code></pre>
</li>
<li>
<p><code>git cat-file -p tag1.0</code> // 查看轻量标签或附注标签 <code>tag1.0</code> 信息。</p>
</li>
<li>
<p><code>git cat-file tag tag1.0</code> // 查看附注标签 <code>tag1.0</code> 信息。</p>
</li>
<li>
<p><code>git ls-tree ead34240822030a3f71df4fc351057d80d7d83f8</code> // 查看 <code>tree</code> 目录对象 <code>ead34240822030a3f71df4fc351057d80d7d83f8</code> 中包含的 <code>blob</code> 文件对象和 <code>tree</code> 目录对象。</p>
</li>
<li>
<p><code>git ls-tree HEAD</code> // 查看 <code>HEAD</code> 所指向 <code>tree</code> 目录对象中包含的 <code>blob</code> 文件对象和 <code>tree</code> 目录对象。</p>
</li>
<li>
<p><code>git verify-pack -v .git/objects/pack/pack-a9282552b62cbe3f255fbb20374695a17c1ba2a2.idx</code> // 查看<code>pack-a9282552b62cbe3f255fbb20374695a17c1ba2a2.pack</code> 压缩包中的内容。</p>
</li>
<li>
<p><code>git update-index n.txt</code> // 将修改状态的 <code>n.txt</code> 文件添加到暂存区。</p>
</li>
<li>
<p><code>git update-index --add n.txt</code> // 将未追踪状态或修改状态的 <code>n.txt</code> 文件添加到暂存区。</p>
</li>
<li>
<p><code>git update-index --add --cacheinfo 100644 5d11580eed65ffd34b6786274a60460b3582aa7d n.txt</code>  // 使用类型为 <code>100644</code>、<code>SHA-1</code> 哈希值为 <code>5d11580eed65ffd34b6786274a60460b3582aa7d</code> 的信息将追踪状态或修改状态的 <code>n.txt</code> 添加到暂存区。</p>
</li>
<li>
<p><code>git write-tree</code>  // 将整个暂存区内容生成一个 <code>tree</code> 对象，并输出其 <code>SHA-1</code> 哈希值。</p>
</li>
<li>
<p><code>echo &quot;add n.txt&quot; | git commit-tree 31b7ca405196ca9e8fb4d5404b315bef9f2c841f -p HEAD</code> // 用 <code>git write-tree</code> 得到的<code>31b7ca405196ca9e8fb4d5404b315bef9f2c841f</code> 树对象创建一个注释为 <code>add n.txt</code> 的提交对象，并将提交对象的父亲设置为当前 <code>HEAD</code>。</p>
</li>
<li>
<p><code>git update-ref refs/heads/master 372aa8e425b57ca30e2974b8e7737133caaa0b7f</code>  // 若当前分支为 <code>master</code>，更新 <code>HEAD</code> 指向上面 <code>git commit-tree</code> 命令得到的 <code>372aa8e425b57ca30e2974b8e7737133caaa0b7f</code> 提交对象，此时用 <code>git log</code> 就可以看到这条 <code>commit</code> 记录。</p>
</li>
<li>
<p><code>git write-tree --prefix=ss</code> // 将暂存区中 <code>ss</code> 目录下的内容生成一个 <code>tree</code> 对象，并输出其 <code>SHA-1</code> 哈希值。</p>
</li>
<li>
<p><code>git update-ref -d refs/remotes/origin/v1.0</code> // 删除 <code>v1.0</code> 远程分支 <code>cache</code>。</p>
</li>
<li>
<p><code>git update-index --chmod=+x engine_mac.sh</code> // 为 <code>engine_mac.sh</code> 增加可执行权限（Linux、Unix、Mac OS X 系统上需要）。</p>
</li>
</ul>
<h1 id="命令大全">命令大全</h1>
<h2 id="查看命令帮助">查看命令帮助</h2>
<ul>
<li><code>git config --help</code> // 查看 <code>git config</code> 命令详细用法</li>
<li><code>git help config</code> // 功能同上</li>
</ul>
<h2 id="配置">配置</h2>
<ul>
<li><code>git config --global user.name &quot;kekec&quot;</code> // 配置提交用户名。</li>
<li><code>git config --global user.email &quot;kekec@qq.com&quot;</code> // 配置 E-mail 信息。</li>
<li><code>git config --global core.editor vim</code> // 配置默认文本编辑器，当 Git 需要你输入信息时会调用它。</li>
<li><code>git config --global alias.st status</code> // 为 <code>status</code> 配置别名 <code>st</code>，这样 <code>git status</code> 就可以写成 <code>git st</code>。</li>
<li><code>git config --list</code> // 查看当前仓库的所有配置信息（包括分支相关的信息）</li>
<li><code>git config user.name</code> // 查看当前仓库的用户名信息</li>
<li><code>git config -e --global</code> // 编辑全局配置文件（用户名和 E-mail 信息就记录在其中）  所在目录：<code>c:/users/&lt;用户名&gt;/.gitconfig</code>。</li>
<li><code>git config -e</code> // 编辑当前仓库的配置文件  所在目录：<code>.git\config</code>。</li>
</ul>
<h2 id="创建版本库">创建版本库</h2>
<ul>
<li><code>git init</code> // 在当前目录创建一个空的 <code>git</code> 代码库。</li>
<li><code>git init MyGame</code> // 在当前目录创建一个名为 <code>MyGame</code> 的文件夹，然后在其中创建一个空的 <code>git</code> 代码库。</li>
</ul>
<p>.git目录结构如下：<br>
<img src="https://faded.auspicious.space/post-images/1587103199628.png" alt="" loading="lazy"></p>
<ul>
<li>
<p><code>hooks</code>：不同操作时执行的 <code>hook</code> 脚本。</p>
</li>
<li>
<p><code>info/exclude</code>：与 <code>.gitignore</code> 文件（该文件需放在 <code>.git</code> 文件夹的同级目录中，Windows 下可通过命令行 <code>type nul &gt; .gitignore</code> 来创建）一样，用作文件过滤。不同的是：该文件不会提交到版本库，因此过滤只对本地生效，不影响其他人。</p>
<pre><code class="language-bash"># 忽略所有.so 结尾的文件
*.so
# 但 game.so 除外
!game.so
# 仅仅忽略项目根目录下的 README.md 文件，不包括 subdir/README.md
/README.md
# 忽略 .svn/ 目录下的所有文件
.svn/
# 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt
doc/*.txt
# 忽略 doc/ 目录下所有扩展名为 txt 的文件
doc/**/*.txt
</code></pre>
</li>
<li>
<p><code>logs/refs/heads</code>：各个本地分支的版本 <code>log</code> 记录。</p>
</li>
<li>
<p><code>logs/refs/remotes</code>：各个远程分支 <code>cache</code> 的 <code>log</code> 记录。</p>
</li>
<li>
<p><code>logs/refs/stash</code>：储藏区数据。</p>
</li>
<li>
<p><code>logs/HEAD</code>：<code>git</code> 操作记录。</p>
</li>
<li>
<p><code>objects</code>：2 级文件索引（把 <code>SHA-1</code> 哈希值拆成了：<code>2位+38位</code>），存储 <code>commit</code> 数据、<code>blob</code> 文件数据和 <code>tree</code> 目录数据。</p>
</li>
<li>
<p><code>objects/pack</code>：<code>pack</code> 文件为存储 <code>commit</code>、<code>tree</code> 目录及 <code>blob</code> 文件的压缩数据；<code>idx</code> 文件为 <code>pack</code> 文件中各数据对象的索引。</p>
</li>
<li>
<p><code>objects/info/packs</code>：该文件记录所有 <code>git</code> 库的 <code>pack</code> 文件列表。</p>
</li>
<li>
<p><code>refs/heads</code>：各个本地分支 <code>HEAD</code>。</p>
</li>
<li>
<p><code>refs/remotes</code>：各个远程分支 <code>cache</code> 的 <code>HEAD</code>。</p>
</li>
<li>
<p><code>refs/tags</code>：各个附注标签的信息。</p>
</li>
<li>
<p><code>COMMIT_EDITMSG</code>：上一次提交的注释。</p>
</li>
<li>
<p><code>config</code>：版本库相关的配置信息。</p>
</li>
<li>
<p><code>description</code>：仓库描述信息，供 <code>gitweb</code> 程序使用。</p>
</li>
<li>
<p><code>index</code>：暂存区相关的信息。</p>
</li>
<li>
<p><code>HEAD</code>：指向当前分支的最近提交（如：<code>ref: refs/heads/master</code>）。</p>
</li>
<li>
<p><code>ORIG_HEAD</code>：执行 <code>git merge / git pull / git reset</code> 操作时，会把调整为新值之前的先前版本的 <code>HEAD</code> 记录到 <code>OERG_HEAD</code> 中，用于恢复或回滚之前的状态。</p>
</li>
<li>
<p><code>FETCH_HEAD</code>：<code>git fech</code> 将所有抓取分支的 <code>HEAD</code> 记录到 <code>.git/FETCH_HEAD</code> 中。</p>
</li>
<li>
<p><code>MERGEHEAD</code>：正在合并进 <code>HEAD</code> 的 <code>commit id</code>。</p>
</li>
<li>
<p><code>packed-refs</code>：远程版本库 <code>cache</code> 和远程标签 <code>cache</code>。</p>
</li>
</ul>
<h2 id="日志与文件状态">日志与文件状态</h2>
<ul>
<li><code>git reflog</code> // 查看操作记录。<br>
注：每条操作记录使用 <code>HEAD@{n}</code> 来标识。</li>
<li><code>git show HEAD@{5}</code> // 查看索引为 5 的操作记录的详细信息。</li>
<li><code>git status</code> // 查看当前所处的分支暂存区和工作区的文件（会显示当前所处分支）。
<ul>
<li>注1：处于暂存区的文件状态:：<code>staged</code>（已暂存）；处于工作区的文件状态:：<code>untrack</code>（未跟踪）、<code>modified</code>（已修改）；</li>
<li>注2：工作区中的空目录不会被 <code>git</code> 追踪。</li>
</ul>
</li>
<li><code>git status -s --ignored</code> // 以简洁模式查看暂存区和工作区的文件（全部显示，不执行文件过滤）。</li>
<li><code>git status -uno</code> // 查看暂存区和工作区的非 <code>untrack</code>（未跟踪）状态文件。</li>
<li><code>git status -uall</code> // 查看暂存区和工作区的状态文件（递归子目录显示出里面的文件）。</li>
<li><code>git log</code> // 查看本地版本库提交记录（会显示当前所处分支，<code>HEAD</code> 指针指向哪个分支的哪条提交）。</li>
<li><code>git log --stat</code> // 查看本地版本库提交记录（会显示当前所处分支，<code>HEAD</code> 指针指向哪个分支的哪条提交和每次提交的文件变更简略统计信息）。</li>
<li><code>git log -- README.md</code> // 查看 <code>README.md</code> 文件的本地版本库提交记录。</li>
<li><code>git log --graph -- README.md</code> // 以图形化方式查看 <code>README.md</code> 文件的本地版本库提交记录。</li>
<li><code>git log -p README.md</code> // 查看 <code>README.md</code> 文件的本地版本库提交记录（显示出每次的修改内容）。</li>
<li><code>git log --grep &quot;test&quot;</code> // 显示注释中含有 <code>test</code> 字符串的提交。</li>
<li><code>git log --author=kekec</code> // 查看本地版本库中作者为 <code>kekec</code> 的提交记录。</li>
<li><code>git log -S &quot;SplitPath(FString&amp; str)&quot;</code> // 查看 <code>SplitPath(FString&amp; str)</code> 内容是什么时候加到项目中那些文件中去的。</li>
<li><code>git log --since=2.weeks</code> // 查看最近 2 周的提交记录。</li>
<li><code>git log --since=&quot;2 weeks 3 days 2 hours 30 minutes 59 seconds ago&quot;</code> // 查看 2 周 3 天 2 小时 30 分 59 秒以前的提交记录。</li>
<li><code>git log --after=&quot;2018-10-7&quot; --before=&quot;2018-10-12&quot;</code> // 查看 <code>2018.10.7~2018.10.12</code> 之间的提交记录。</li>
<li><code>git log --since=&quot;2018-10-7&quot; --until=&quot;2018-10-12&quot;</code> // 功能同上：<code>git log --after=&quot;2018-10-7&quot; --before=&quot;2018-10-12&quot;</code>。<br>
注：<code>--since</code>、<code>--until</code> 标记和 <code>--after</code>、<code>--before</code> 标记分别是等价的。</li>
<li><code>git whatchanged README.md</code> // 查看 <code>README.md</code> 文件的本地版本库提交记录（包括文件改名）。</li>
<li><code>git log --follow README.md</code> // 功能同上：<code>git whatchanged README.md</code>。</li>
<li><code>git log -3</code> // 查看最近 3 条本地版本库提交记录。</li>
<li><code>git log -3 --pretty --oneline</code> // 查看最近 3 条本地版本库提交记录（简洁模式，一行显示一个提交）。</li>
<li><code>git log --graph --oneline</code> // 以图形化简洁模式查看当前分支的本地版本库提交记录。</li>
<li><code>git log release --graph --oneline</code> // 以图形化简洁模式查看 <code>release</code> 分支的本地版本库提交记录。</li>
<li><code>git log --graph --oneline --no-merges</code> // 以图形化简洁模式查看当前分支的本地版本库提交记录（过滤 <code>merge</code> 过来的提交）。</li>
<li><code>git log --graph --oneline --merges</code> // 以图形化简洁模式查看当前分支的本地版本库提交记录（只显示有 2 个及以上父亲节点的提交）。</li>
<li><code>git log --graph --oneline --name-only</code> // 以图形化简洁模式查看当前分支的本地版本库提交记录（并显示每次提交的文件名称清单）。</li>
<li><code>git log --graph --oneline --name-status</code> // 以图形化简洁模式查看当前分支的本地版本库提交记录（并显示每次提交的文件状态、名称清单）。</li>
<li><code>git log --graph --oneline --stat</code> // 以图形化简洁模式查看当前分支的本地版本库提交记录（并显示每次提交的文件变化统计、各文件名及增删记录）。</li>
<li><code>git log --graph --oneline --shortstat</code> // 以图形化简洁模式查看当前分支的本地版本库提交记录（并显示每次提交的文件变化统计及增删记录）。</li>
<li><code>git log --graph --oneline --decorate --all</code> // 以图形化简洁模式查看所有分支的本地版本库提交记录树。</li>
<li><code>git log --graph --pretty=format:&quot;%H - %an, %ad : %s&quot;</code> // 自定义格式图形化查看所有分支的本地版本库提交记录树。
<ul>
<li><code>%H</code> 提交对象（<code>commit</code>）的完整哈希字串；</li>
<li><code>%h</code> 提交对象的简短哈希字串；</li>
<li><code>%T</code> 树对象（<code>tree</code>）的完整哈希字串；</li>
<li><code>%t</code> 树对象的简短哈希字串；</li>
<li><code>%P</code> 父对象（<code>parent</code>）的完整哈希字串；</li>
<li><code>%p</code> 父对象的简短哈希字串；</li>
<li><code>%an</code> 作者（<code>author</code>）的名字；</li>
<li><code>%ae</code> 作者的电子邮件地址；</li>
<li><code>%ad</code> 作者修订日期（可以用 <code>--date=</code> 选项定制格式）；</li>
<li><code>%ar</code> 作者修订日期，按多久以前的方式显示；</li>
<li><code>%cn</code> 提交者（<code>committer</code>）的名字；</li>
<li><code>%ce</code> 提交者的电子邮件地址；</li>
<li><code>%cd</code> 提交日期；</li>
<li><code>%cr</code> 提交日期，按多久以前的方式显示；</li>
<li><code>%s</code> 提交说明；</li>
</ul>
</li>
<li><code>git log master..v5.0</code> // 查看 <code>v5.0</code> 分支还未合并到 <code>master</code> 分支上的提交记录列表。</li>
<li><code>git log v5.0..master</code> // 查看 <code>master</code> 分支还未合并到 <code>v5.0</code> 分支上的提交记录列表。</li>
<li><code>git log master...v5.0</code> // <code>git log master..v5.0 + git log v5.0..master</code>。</li>
<li><code>git shortlog -sn</code> // 统计各个提交者的次数。</li>
<li><code>git blame README.md</code> // 显示 <code>README.md</code> 最近一次的修改信息。</li>
<li><code>git show 3a6c702376168aa15a2f3d7bc98000d07a70d023 README.md</code> // 查看 <code>README.md</code> 文件的 <code>3a6c702376168aa15a2f3d7bc98000d07a70d023</code> 提交的修改内容。</li>
<li><code>git show HEAD</code> // 查看最近一次提交的修改内容。</li>
<li><code>git show --name-only HEAD</code> // 查看最近一次提交的文件列表（不显示具体的修改内容）。</li>
</ul>
<h2 id="标签查看新建切换删除">标签（查看/新建/切换/删除）</h2>
<ul>
<li><code>git tag</code> // 列出所有的标签。</li>
<li><code>git tag -l 'tag1*'</code> // 列出所有 <code>tag1</code> 开头的标签。</li>
<li><code>git tag tag1.0</code> // 创建名为 <code>tag1.0</code> 的轻量标签。</li>
<li><code>git tag -a tag1.0 -m &quot;tag1.0 desc&quot;</code> // 添加 <code>tag1.0 desc</code> 注释并创建名为 <code>tag1.0</code> 的附注标签。</li>
<li><code>git tag tag2.0 abffefc5d82078cbaea7fcbb5106ab0c21cbeba9</code> // 在 <code>abffefc5d82078cbaea7fcbb5106ab0c21cbeba9</code> 提交处创建名为 <code>tag2.0</code> 的轻量标签。</li>
<li><code>git tag -a tag2.0 -m &quot;tag2.0 desc&quot; abffefc</code> // 在 <code>abffefc</code> 提交处创建名为 <code>tag2.0</code> 的附注标签。</li>
<li><code>git tag -d tag2.0</code> // 删除名为 <code>tag2.0</code> 的标签。</li>
<li><code>git show tag1.0</code> // 查看名为 <code>tag1.0</code> 相关的信息。</li>
<li><code>git ls-remote --tags</code> // 查看所有远端的标签。</li>
</ul>
<h2 id="分支查看新建切换删除">分支（查看/新建/切换/删除）</h2>
<ul>
<li><code>git branch</code> // 列出所有本地分支。</li>
<li><code>git branch -r</code> // 列出所有远程分支 <code>cache</code>。</li>
<li><code>git branch -a</code> // 列出所有本地分支和远程分支 <code>cache</code>。</li>
<li><code>git branch -av</code> // 列出所有本地分支和远程分支 <code>cache</code>（含简单说明）。</li>
<li><code>git branch -vv</code> // 查看所有本地分支和远程分支 <code>cache</code> 之间的追踪关系。</li>
<li><code>git branch v1.0</code> // 在当前分支的 <code>HAED</code> 指针下创建名为 <code>v1.0</code> 的分支（创建完不会切到 <code>v1.0</code> 分支上）。</li>
<li><code>git branch --track v1.0 origin/v1.0</code> // 若 <code>v1.0</code> 分支不存在则先新建，然后将其与远程分支 <code>origin/v1.0</code> 建立追踪关系。
<ul>
<li>远程分支 <code>origin/v1.0</code> 要存在，否则命令执行失败。</li>
<li>执行完不会切到 <code>v1.0</code> 分支上。</li>
</ul>
</li>
<li><code>git branch v2.0 372aa8e425b57ca30e2974b8e7737133caaa0b7f</code> // 在 <code>372aa8e425b57ca30e2974b8e7737133caaa0b7f</code> 提交处创建名为 <code>v2.0</code> 的分支（创建完不会切到 <code>v2.0</code> 分支上）。</li>
<li><code>git branch -m v1.0 x1.0</code> // 将分支 <code>v1.0</code> 重命名为 <code>x1.0</code>。</li>
<li><code>git checkout v1.0</code> // 切换到 <code>v1.0</code> 分支上（<code>v1.0</code> 分支不存在则命令执行失败）。</li>
<li><code>git checkout -b v1.0</code> // 创建并切换到 <code>v1.0</code> 分支上（<code>v1.0</code> 分支存在则命令执行失败）。</li>
<li><code>git checkout -B v1.0</code> // 不存在则创建，并切换到 <code>v1.0</code> 分支上。</li>
<li><code>git checkout -b v1.0 5a95f2d</code> // 在 <code>5a95f2d</code> 提交处创建并切换到 <code>v1.0</code> 的分支上。</li>
<li><code>git checkout -b v1.0 tag1.0</code> // 在标签 <code>tag1.0</code> 处创建并切换到 <code>v1.0</code> 的分支上。</li>
<li><code>git checkout -t origin/v1.0</code> // 创建并切换到 <code>origin/v1.0</code> 远程分支 <code>cache</code> 的名为 <code>v1.0</code> 本地分支上，并建立两者追踪关系（本地分支 <code>v1.0</code> 存在则命令执行失败）。</li>
<li><code>git checkout -b x1.0 -t origin/v1.0</code> // 创建并切换到 <code>origin/v1.0</code> 远程分支 <code>cache</code> 的名为 <code>x1.0</code> 本地分支上，并建立两者追踪关系（本地分支 <code>x1.0</code> 存在则命令执行失败）
<ul>
<li>注1：切换分支前，必须处理工作区（未追踪的文件不用处理）和暂存区的修改才能切换成功</li>
<li>注2：切换成功后，工作区会被设置成分支的内容</li>
<li>注3：不允许在远程分支 <code>cache</code> 上提交，需要创建对应关联的本地分支，然后在本地分支上进行提交。</li>
</ul>
</li>
<li><code>git checkout -f v1.0</code> // 强制切换到 <code>v1.0</code> 分支上，丢弃暂存区和工作区中的所有文件的修改（工作区中未追踪的文件不受影响）。</li>
<li><code>git checkout -f -B v1.0 origin/v1.0</code> // 不存在则创建，强制切换到 <code>v1.0</code> 分支上，丢弃暂存区和工作区中的所有文件的修改，并将 <code>HEAD</code> 指向 <code>origin/v1.0</code> 处（工作区中未追踪的文件不受影响）。</li>
<li><code>git checkout -</code> // 切换到上一次分支。</li>
<li><code>git branch -d v2.0</code> // 删除名为 <code>v2.0</code> 的分支（必须先切到其他分支上才能执行删除操作）。</li>
<li><code>git branch -D v2.0</code> // 强制删除名为 <code>v2.0</code> 的分支（必须先切到其他分支上才能执行删除操作）。</li>
<li><code>git branch -dr origin/v2.0</code> // 删除远程分支 <code>origin/v2.0 cache</code>。</li>
</ul>
<h2 id="文件增加删除提交撤销">文件（增加/删除/提交/撤销）</h2>
<ul>
<li>
<p><code>git add README.md</code> // 将当前目录下的 <code>README.md</code> 文件加入到暂存区。</p>
</li>
<li>
<p><code>git add .</code> // 将当前目录下（递归子目录）所有文件加入到暂存区。</p>
</li>
<li>
<p><code>git add -u .</code> // 将当前目录下（递归子目录）所有追踪状态的文件加入到暂存区。</p>
</li>
<li>
<p><code>git add Doc/\*.txt</code> // 将当前目录的 <code>Doc</code> 文件夹下（递归子目录）所有 <code>txt</code> 后缀的文件加入到暂存区。</p>
</li>
<li>
<p><code>git rm README.md</code> // 删除工作区文件，并且将这次删除放入暂存区（若 <code>README.md</code> 在工作区或暂存区中有修改，命令会执行失败）。</p>
</li>
<li>
<p><code>git rm -f README.md</code> // 强制删除工作区文件，并且将这次删除放入暂存区（即使 <code>README.md</code> 在工作区或暂存区中有修改，也会执行删除操作）。</p>
</li>
<li>
<p><code>git rm --cached README.md</code> // 不删除工作区对应的文件，只将 <code>README.md</code> 删除放入暂存区以供提交。</p>
</li>
<li>
<p><code>git mv README.md test.md</code> // 将 <code>README.md</code> 改名为 <code>test.md</code>，并且将这个改名放入暂存区。</p>
</li>
<li>
<p><code>git commit -m &quot;desc&quot;</code> // 添加 <code>desc</code> 注释并将暂存区中的所有修改提交到本地仓库。</p>
</li>
<li>
<p><code>git commit README.md -m &quot;desc&quot;</code> // 添加 <code>desc</code> 注释并将暂存区中的 <code>README.md</code> 的修改提交到本地仓库。</p>
</li>
<li>
<p><code>git commit --amend -m &quot;desc&quot;</code> // 添加 <code>desc</code> 注释使用当前提交覆盖上一次的提交（若上一次提交包含 <code>1.txt</code> 和 <code>2.txt</code> 的修改，当前提交只包含 <code>1.txt</code> 的修改；执行命令后，本地版本库中为本次的 <code>1.txt</code> 和上一次 <code>2.txt</code>）。若没有提交内容，则用来改写上一次提交的日志信息。</p>
</li>
<li>
<p><code>git commit -m &quot;desc&quot; --amend README.txt</code> // 添加 <code>desc</code> 注释使用 <code>README.txt</code> 的当前提交覆盖上一次的提交。</p>
</li>
<li>
<p><code>git commit -a -m &quot;desc&quot;</code> // 添加 <code>desc</code> 注释并将工作区和暂存区中的所有修改提交到本地仓库。</p>
</li>
<li>
<p><code>git commit -am &quot;desc&quot;</code> // 功能同上。</p>
</li>
<li>
<p><code>git commit -c b5cad94d229e72bd7aff5fe2c6f022b29c30e7a8</code> // 拿 <code>372aa8e425b57ca30e2974b8e7737133caaa0b7f</code> 提交的信息（作者、提交者、注释、时间戳等）来提交当前修改。</p>
</li>
<li>
<p><code>git reset -- README.md</code> // 丢弃暂存区中的 <code>README.md</code> 文件的修改。</p>
</li>
<li>
<p><code>git reset README.md</code> // 功能如上，丢弃暂存区中的 <code>README.md</code> 文件的修改。</p>
</li>
<li>
<p><code>git reset b5cad94 README.md</code> // 使用本地版本库 <code>b5cad94</code> 提交处的 <code>README.md</code> 版本覆盖暂存区中的 <code>README.md</code>。</p>
</li>
<li>
<p><code>git reset</code> // 丢弃暂存区中的所有文件的修改（工作区不受影响）。</p>
</li>
<li>
<p><code>git reset --mixed</code> // <code>--mixed</code> 为缺省参数，命令与上面 <code>git reset</code> 一样。</p>
</li>
<li>
<p><code>git reset --hard</code> // 丢弃暂存区和工作区中的所有文件的修改（工作区中未追踪的文件不受影响）。</p>
</li>
<li>
<p><code>git reset --soft b5cad94d229e72bd7aff5fe2c6f022b29c30e7a8</code> // 仅将当前分支的。<code>HEAD</code> 指向 <code>372aa8e425b57ca30e2974b8e7737133caaa0b7f</code> 提交（暂存区和工作区中的所有文件的修改都不丢弃）。</p>
</li>
<li>
<p><code>git reset --soft HEAD~</code> // 仅将当前分支的 <code>HEAD</code> 指向上一次提交（暂存区和工作区中的所有文件的修改都不丢弃）。</p>
</li>
<li>
<p><code>git reset --soft HEAD~2</code> // 仅将当前分支的 <code>HEAD</code> 指向上两次提交（暂存区和工作区中的所有文件的修改都不丢弃）。</p>
</li>
<li>
<p><code>git reset --merge &lt;commit&gt;</code> // 在被污染的工作区中回滚 <code>merge</code> 或者 <code>pull</code>。</p>
<pre><code class="language-bash">$ git pull                         (1) 
Auto-merging nitfol 
Merge made by recursive. 
nitfol                |   20 +++++---- 
... 
$ git reset --merge ORIG_HEAD      (2)
</code></pre>
<ol>
<li>即便你已经在本地更改了一些你的工作区，你也可安全的 <code>git pull</code>，前提是你知道将要 <code>pull</code> 的内容不会覆盖你的工作区中的内容。</li>
<li><code>git pull</code> 完后，你发现这次 <code>pull</code> 下来的修改不满意，想要回滚到 <code>pull</code> 之前的状态，我们可以执行 <code>git reset --hard ORIG_HEAD</code>，但是这个命令有个副作用就是清空你的工作区，即丢弃你的本地未 <code>add</code> 的那些改变。</li>
</ol>
<p>为了避免丢弃工作区中的内容，可以使用 <code>git reset --merge ORIG_HEAD</code>，注意其中的<code>--hard</code> 换成了 <code>--merge</code>，这样就可以避免在回滚时清除工作区。</p>
</li>
<li>
<p><code>git reset --keep &lt;commit&gt;</code> // 保留工作区并丢弃一些之前的提交。<br>
假设你正在编辑一些文件，并且已经提交，接着继续工作，但是现在你发现当前在工作区中的内容应该属于另一个分支，与之前的提交没有什么关系。此时，可以开启一个新的分支，并且保留着工作区中的内容。</p>
<pre><code class="language-bash">$ git tag start 
$ git checkout -b branch1 
$ edit 
$ git commit ...                            (1) 
$ edit 
$ git checkout -b branch2                   (2) 
$ git reset --keep start                    (3)
</code></pre>
<ol>
<li>这次是把在 <code>branch1</code> 中的改变提交了。</li>
<li>此时发现，之前的提交不属于这个分支，此时新建了 <code>branch2</code> 分支，并切换到了 <code>branch2</code> 上。</li>
<li>此时可以用 <code>reset --keep</code> 把在 <code>start</code> 之后的提交清除掉，但是保持工作区不变。</li>
</ol>
</li>
<li>
<p><code>git checkout -- README.md</code> // <code>--</code> 符号非常重要，否则就变成了切换到 <code>README.md</code> 分支了。<br>
// 当 <code>README.md</code> 在暂存区中有修改时，使用暂存区中的修改覆盖工作区中的 <code>README.md</code>。<br>
// 当 <code>README.md</code> 不在暂存区中时，使用本地版本库中的 <code>HEAD</code> 指针处的修改覆盖工作区中的 <code>README.md</code>。</p>
</li>
<li>
<p><code>git checkout -- .</code> // 使用暂存区和本地版本库来恢复当前目录（递归子目录）下的所有文件。<br>
注：若暂存区中有修改，优先使用暂存区。</p>
</li>
<li>
<p><code>git checkout HEAD README.md</code> // 使用本地版本库中的 <code>HEAD</code> 处提交覆盖暂存区和工作区中的 <code>README.md</code>。</p>
</li>
<li>
<p><code>git checkout 9a387f22ff949fa16336508adc2284384bd6a890 README.md</code> // 使用本地版本库中的 <code>9a387f22ff949fa16336508adc2284384bd6a890</code> 修改覆盖暂存区和工作区中的 <code>README.md</code>。</p>
</li>
<li>
<p><code>git checkout -b v2.0 tag2.0</code> // 在名为 <code>tag2.0</code> 的提交处创建并切换到 <code>v2.0</code> 分支上（<code>v2.0</code> 分支存在则命令执行失败）。</p>
</li>
<li>
<p><code>git revert --no-edit 3a6c702376168aa15a2f3d7bc98000d07a70d023</code> // 回滚 <code>3a6c702376168aa15a2f3d7bc98000d07a70d023</code> 提交，然后提交到本地仓库。</p>
</li>
<li>
<p><code>git revert HEAD~</code> // 回滚 <code>HEAD</code> 的上一次提交，然后会弹出 <code>vim</code> 环境编辑注释（输入 <code>:q</code> 直接使用默认注释内容、输入 <code>:q!</code> 放弃修改使用默认注释内容、输入 <code>:x</code> 或 <code>:wq</code> 保存当前修改的注释内容），然后提交到本地仓库。</p>
</li>
<li>
<p><code>git revert -n HEAD~3</code> // 回滚掉 <code>HEAD~3</code> 处的提交，不自动提交到本地仓库。</p>
</li>
<li>
<p><code>git revert -n HEAD~2..HEAD</code> // 回滚掉 <code>(HEAD~2, HEAD]</code> 之间的 2 次提交，不自动提交到本地仓库。<br>
注：<code>git reset</code> 是把 <code>HEAD</code> 向后移动来删除提交，而 <code>git revert</code> 是用一次新的提交来回滚之前的提交（<code>HEAD</code> 会继续前进）。</p>
</li>
</ul>
<h2 id="查看差异">查看差异</h2>
<ul>
<li><code>git diff README.md</code> // 查看当前目录下的 <code>README.md</code> 在工作区和暂存区之间的差异。</li>
<li><code>git diff --cached README.md</code> // 查看当前目录下的 <code>README.md</code> 在暂存区和本地仓库最后一次提交之间的差异。</li>
<li><code>git diff --cached 372aa8e425b57ca30e2974b8e7737133caaa0b7f README.md</code> // 查看当前目录下的 <code>README.md</code> 在暂存区和本地仓库的 <code>372aa8e425b57ca30e2974b8e7737133caaa0b7f</code> 提交之间的差异。</li>
<li><code>git diff HEAD README.md</code> // 查看当前目录下的 <code>README.md</code> 在工作区和本地仓库 <code>HEAD</code> 指针处提交之间的差异。</li>
<li><code>git diff 372aa8e425b57ca30e2974b8e7737133caaa0b7f README.md</code> // 查看当前目录下的 <code>README.md</code> 在工作区和本地仓库的 <code>372aa8e425b57ca30e2974b8e7737133caaa0b7f</code> 提交之间的差异。</li>
<li><code>git diff 372aa8e425b57ca30e2974b8e7737133caaa0b7f HEAD README.md</code> // 查看当前目录下的 <code>README.md</code> 在本地仓库的 <code>372aa8e425b57ca30e2974b8e7737133caaa0b7f</code> 提交和最后一次提交之间的差异。</li>
<li><code>git diff 372aa8e425b57ca30e2974b8e7737133caaa0b7f HEAD</code> // 查看本地仓库的 <code>372aa8e425b57ca30e2974b8e7737133caaa0b7f</code> 提交和最后一次提交之间的差异。</li>
<li><code>git diff 372aa8e b5cad94 README.md</code> // 查看当前目录下的 <code>README.md</code> 在本地仓库的 <code>372aa8e</code> 提交和 <code>b5cad94</code> 提交之间的差异<br>
注：可以将 <code>git diff</code> 换成 <code>git difftool</code> 来使用外部 <code>diff</code> 工具（可以在 <code>c:/users/&lt;用户名&gt;/.gitconfig</code> 文件配置 <code>beyond compare</code> 作为默认的 <code>difftool</code> 和 <code>mergetool</code>）来查看差异。<pre><code class="language-bash">[diff]
    tool = bc3
[difftool]
    prompt = false
[difftool &quot;bc3&quot;]
    cmd = &quot;\&quot;e:/program files (x86)/beyond compare 3/bcomp.exe\&quot; \&quot;$LOCAL\&quot; \&quot;$REMOTE\&quot;&quot;
</code></pre>
</li>
</ul>
<h2 id="分支合并">分支合并</h2>
<ul>
<li>
<p><code>git merge-base Master Feature</code> // 查看 <code>Master</code> 和 <code>Feature</code> 分支的最优共同 <code>commit</code> 父节点。</p>
</li>
<li>
<p><code>git merge Feature</code> // 将 <code>Feature</code> 分支 <code>merge</code> 合并到当前分支 <code>Master</code>（无冲突时会直接提交）。</p>
</li>
<li>
<p><code>git merge -m &quot;merge test&quot; Feature</code> // 将 <code>Feature</code> 分支 <code>merge</code> 合并到当前分支 <code>Master</code>（无冲突时使用 <code>merge test</code> 注释直接提交）。</p>
</li>
<li>
<p><code>git merge --no-commit Feature</code> // 将 <code>Feature</code> 分支 <code>merge</code> 合并到当前分支 <code>Master</code>（不自动提交）。</p>
</li>
<li>
<p><code>git rebase Feature</code> // 将 <code>Feature</code> 分支 <code>rebase</code> 合并到当前分支 <code>Master</code>。<br>
<img src="https://faded.auspicious.space/post-images/1587126526914.png" alt="" loading="lazy"></p>
<ul>
<li>注1：<code>git rebase</code> 会先找出共同的祖先节点，从祖先节点把 <code>Feature</code> 分支的提交记录全都剪切下来，然后合到 <code>Master</code> 分支（合并前后 <code>commitID</code> 会不一样）。</li>
<li>注2：相对来说，<code>git merge</code> 处理冲突更直接，但会增加一些冗余的提交记录；而 <code>git rebase</code> 能够保证清晰线性的提交记录，但这也将合并的操作没有被记录下来。</li>
<li>注3：最好是用 <code>git rebase</code> 合并远程分支到本地，<code>git merge</code> 合并 <code>Feature</code> 分支到 <code>Master</code> 分支。</li>
<li>注4：在合并 <code>Feature</code> 分支到 <code>Master</code> 分支前，务必先执行 <code>git pull -r origin Feature</code> 来进行远程分支与本地分支的 <code>rebase</code> 合并。</li>
<li>注5：处于冲突状态（<code>conflict</code>）的文件为 <code>UU</code>（可通过 <code>git status -s --ignored</code> 来查找），手动处理完冲突后，然后使用 <code>git add</code> 该文件，最后继续执行 <code>git merge/rebase --continue</code> 来完成合并的提交工作。</li>
<li>注6：<code>README.md</code> 文件冲突内容如下<pre><code class="language-bash">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
123 456 789 000 111 222 333 444 555 ss  // 当前分支的内容
=======
123 456 789 000 ss tt  // Feature 分支的内容
&gt;&gt;&gt;&gt;&gt;&gt;&gt; Feature
</code></pre>
</li>
<li>注7：可以使用 <code>git mergetool</code> 来使用外部 <code>merge</code> 工具（可以在 <code>c:/users/&lt;用户名&gt;/.gitconfig</code> 文件配置 <code>beyond compare</code> 作为默认的 <code>mergetool</code>）来处理冲突。<br>
修改完当前文件后，可再次调用 <code>git mergetool</code> 来处理下一个冲突，直至全部处理完毕，然后使用 <code>git add</code> 该文件，最后继续执行 <code>git merge/rebase --continue</code> 来完成合并的提交工作。<pre><code class="language-bash">[merge]
    tool = bc3
[mergetool]
    prompt = false
[mergetool &quot;bc3&quot;]
    cmd = &quot;\&quot;e:/program files (x86)/beyond compare 3/bcomp.exe\&quot; \&quot;$LOCAL\&quot; \&quot;$REMOTE\&quot; \&quot;$BASE\&quot; \&quot;$MERGED\&quot;&quot;
</code></pre>
<img src="https://faded.auspicious.space/post-images/1587127706910.png" alt="" loading="lazy"></li>
</ul>
</li>
<li>
<p><code>git rebase /i Feature</code> // 将 <code>Feature</code> 分支采用手动交互方式 <code>rebase</code> 合并到当前分支 <code>Master</code>。</p>
<pre><code class="language-bash">pick 07c5abd Introduce OpenPGP and teach basic usage

pick de9b1eb Fix PostChecker::Post#urls
pick 3e7ee36 Hey kids, stop all the highlighting
pick fa20af3 git interactive rebase, squash, amend

# Rebase 8db7e8b..fa20af3 onto 8db7e8b
#
# Commands:
# p, pick = use commit
# r, reword = use commit, but edit the commit message
# e, edit = use commit, but stop for amending
# s, squash = use commit, but meld into previous commit
# f, fixup = like &quot;squash&quot;, but discard this commit's log message
# x, exec = run command (the rest of the line) using shell
#
# These lines can be re-ordered; they are executed from top to bottom.
#
# If you remove a line here THAT COMMIT WILL BE LOST.
#
# However, if you remove everything, the rebase will be aborted.
#
# Note that empty commits are commented out
</code></pre>
</li>
<li>
<p><code>git merge/rebase --abort</code> // 撤销当前 <code>merge</code> 或 <code>rebase</code> 操作。</p>
</li>
<li>
<p><code>git merge/rebase --skip</code> // 强制使用 <code>Feature</code> 分支的内容。</p>
</li>
<li>
<p><code>git merge/rebase --continue</code> // 手动处理完冲突后使用 <code>git add</code> 该文件，最后继续执行 <code>git merge/rebase --continue</code> 来完成合并的提交工作。</p>
</li>
<li>
<p><code>git merge origin/master</code> // <code>fetch</code> 完之后，可以将远程分支 <code>cache master</code> 分支 <code>merge</code> 合并到当前分支上。</p>
</li>
<li>
<p><code>git rebase origin/master</code> // <code>fetch</code> 完之后，可以将远程分支 <code>cache master</code> 分支 <code>rebase</code> 合并到当前分支上。</p>
</li>
<li>
<p><code>git rebase --onto master 76cada~</code> // 将当前分支从 <code>[76cada, HEAD]</code> 区间段的提交 <code>rebase</code> 合并到 <code>master</code> 上。</p>
</li>
<li>
<p><code>git cherry-pick 9a341e</code> // 将 <code>9a341e</code> 提交合入当前分支。若不冲突，则直接使用 <code>9a341e</code> 的提交信息进行 <code>commit</code>，否则要先进行冲突处理，然后继续执行 <code>git cherry-pick --continue</code> 来完成合并的提交工作。</p>
</li>
<li>
<p><code>git cherry-pick 371c2…971209</code> // 将 <code>(371c2, 971209]</code> 提交合入当前分支（每个提交都会在当前分支上创建一个 <code>commit</code>）。</p>
</li>
<li>
<p><code>git cherry-pick 371c2~…971209</code> // 将 <code>[371c2, 971209]</code> 提交合入当前分支（每个提交都会在当前分支上创建一个 <code>commit</code>）。</p>
</li>
<li>
<p><code>git cherry-pick -n 9a341e d2f99e</code> // 将 <code>9a341e</code> 和 <code>d2f99e</code> 提交合入当前分支（不提交），后续需要手动 <code>commit</code>。</p>
</li>
<li>
<p><code>git cherry-pick --abort</code> // 撤销当前 <code>cherry-pick</code> 操作。</p>
</li>
<li>
<p><code>git cherry-pick --quit</code> // 清理当前操作状态，不撤销修改强制退出 <code>cherry-pick</code> 操作过程。</p>
</li>
<li>
<p><code>git cherry-pick --continue</code> // 手动处理完冲突后，最后继续执行 <code>git cherry-pick --continue</code> 来完成合并的提交工作。</p>
</li>
</ul>
<h2 id="查看远程版本库">查看远程版本库</h2>
<ul>
<li><code>git remote -v</code> // 显示远程仓库的 <code>URL</code>。<br>
注：由于 <code>git</code> 是分布式的，所有远程仓库可能有很多个<pre><code class="language-bash">origin https://github.com/kekec/Test.git (fetch)
origin https://github.com/kekec/Test.git (push)
</code></pre>
</li>
<li><code>git remote -ls</code> // 查看远程仓库 <code>URL</code> 和分支信息<pre><code class="language-bash">From https://github.com/kekec/Test.git
fae0fc82d711425daa897a63137d7e1af09512ba HEAD
fae0fc82d711425daa897a63137d7e1af09512ba refs/heads/master
</code></pre>
</li>
<li><code>git remote</code> // 查看远程仓库名称，一般为 <code>origin</code>。</li>
<li><code>git remote rename origin test</code> // 将远程仓库名称从 <code>origin</code> 修改为 <code>test</code>。</li>
<li><code>git remote show origin</code> // 显示远程仓库的信息。<pre><code class="language-bash">* remote origin  
Fetch URL: https://github.com/kekec/Test.git  
Push URL: https://github.com/kekec/Test.git  
HEAD branch: master  
Remote branches:    
master tracked    
v3.1 tracked
Local branch configured for 'git pull':    
master merges with remote master
Local refs configured for 'git push':    
master pushes to master (fast-forwardable)    
v3.1 pushes to v3.1 (up to date)
</code></pre>
</li>
<li><code>git remote rm origin</code> // 删除 <code>.git/config</code> 文件中添加 <code>remote origin</code> 相关的信息。</li>
<li><code>git remote add origin https://github.com/kekec/Test.git</code> // 在 <code>.git/config</code> 文件中添加 <code>remote origin</code> 指向的远程仓库 <code>URL</code>（若已存在，则命令执行失败）。<pre><code class="language-bash">[remote &quot;origin&quot;]
    url = https://github.com/kekec/Test.git
    fetch = +refs/heads/*:refs/remotes/origin/*
</code></pre>
</li>
<li><code>git remote set-url origin https://github.com/kekec/Test.git</code> // 修改 <code>.git/config</code> 文件中添加 <code>remote origin</code> 指向的远程仓库 <code>URL</code>。</li>
<li><code>git remote prune origin</code> // 对于远程仓库不存在的分支，清除对应的远程分支 <code>cache</code>。</li>
</ul>
<h2 id="远程操作">远程操作</h2>
<ul>
<li><code>git clone https://github.com/kekec/Test.git</code> // 将 https://github.com/kekec/Test.git 上的当前分支克隆到本地（会创建一个名为 <code>Test</code> 目录，远程仓库名称使用默认名 <code>origin</code>）。</li>
<li><code>git clone https://github.com/kekec/Test.git MyProject</code> // 将 https://github.com/kekec/Test.git 上的当前分支克隆到本地（会创建一个名为 <code>MyProject</code> 目录，远程仓库名称使用默认名 <code>origin</code>）。</li>
<li><code>git clone -b v1.0 https://github.com/kekec/Test.git</code> // 将 https://github.com/kekec/Test.git 上的 <code>v1.0</code> 分支克隆到本地（会创建一个名为 <code>Test</code> 目录，远程仓库名称使用默认名 <code>origin</code>）。</li>
<li><code>git clone -b v1.0 https://github.com/kekec/Test.git d:\MyGame</code> // 将 https://github.com/kekec/Test.git 上的 <code>v1.0</code> 分支克隆到 <code>d:\MyGame</code> 目录（会在 <code>d:\MyGame</code> 中创建一个名为 <code>Test</code> 目录，远程仓库名称使用默认名 <code>origin</code>）。</li>
<li><code>git clone -o TestPrj https://github.com/kekec/Test.git</code> // 将 https://github.com/kekec/Test.git 上的当前分支克隆到本地（会创建一个名为 <code>Test</code> 目录，并将远程仓库名称设置为 <code>TestPrj</code>）。</li>
<li><code>git fetch origin master</code> // 从远程仓库拉取 <code>master</code> 分支状态的变化信息（工作区文件不会更新）。</li>
<li><code>git fetch</code> // 从远程仓库拉取所有分支和 <code>tag</code> 状态的变化信息（工作区文件不会更新）。</li>
<li><code>git fetch -p</code> // 从远程仓库拉取所有分支和 <code>tag</code> 状态的变化信息，并清除已被删除的远程分支和 <code>tag</code> 在本地的缓存（工作区文件不会更新）。</li>
<li><code>git fetch origin --tags</code> // 从远程仓库拉取所有 <code>tag</code> 到本地（工作区文件不会更新）。</li>
<li><code>git pull &lt;远程仓库名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</code>。</li>
<li><code>git pull origin master</code> // 先执行 <code>fetch</code>，然后将远程 <code>origin/master</code> 分支 <code>merge</code> 合并到当前分支（最后会更新 <code>origin/master</code>，<code>origin/HEAD</code> 指针到最新提交）。</li>
<li><code>git pull https://github.com/kekec/Test.git master</code> // 先执行 <code>fetch</code>，将远程 <code>origin/master</code> 分支 <code>merge</code> 合并到当前分支（最后不会更新 <code>origin/master</code>，<code>origin/HEAD</code> 指针到最新提交）。</li>
<li><code>git pull origin v1.0:master</code> // 先执行 <code>fetch</code>，然后将远程 <code>origin/v1.0</code> 分支 <code>merge</code> 合并到本地 <code>master</code> 分支。</li>
<li><code>git pull origin</code> // 先执行 <code>fetch</code>，然后将对应的远程分支 <code>merge</code> 合并到当前分支（当前分支需要预存远程分支的追踪关系）。</li>
<li><code>git pull</code> // 先执行 <code>fetch</code>，然后将对应的远程分支 <code>merge</code> 合并到当前分支（当前分支需要预存远程分支的追踪关系，而且当前分支只有一个远程仓库）。</li>
<li><code>git pull -p</code> // 先执行 <code>fetch</code>，然后将对应的远程分支 <code>merge</code> 合并到当前分支，并清除已被删除的远程分支和 <code>tag</code> 在本地的缓存。</li>
<li><code>git pull -r origin master</code> // 先执行 <code>fetch</code>，然后将远程 <code>origin/master</code> 分支 <code>rebase</code> 合并到 <code>master</code> 分支。</li>
<li><code>git push &lt;远程仓库名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</code>。</li>
<li><code>git push -u origin master</code> // 将本地仓库的修改 <code>push</code> 到 <code>origin</code> 所指向的远程仓库 <code>URL</code> 的 <code>master</code> 分支上，并在 <code>.git/config</code> 文件中记录当前分支与远程分支 <code>master</code> 的对应关系。</li>
<li><code>git push origin</code> // 将当前分支更新推送给对应的远端分支。</li>
<li><code>git push</code> // 将当前分支更新推送给对应的远端分支（当前分支只有一个远程仓库，可以省略仓库名 <code>origin</code>）。</li>
<li><code>git push origin -f</code> // 使用当前分支更新强行覆盖对应的远端分支（合入远端分支有冲突时，也使用当前分支更新）。</li>
<li><code>git push origin v1.0</code> // 将本地分支 <code>v1.0</code> 更新推送给对应的远端分支 <code>remotes/origin/v1.0</code>。</li>
<li><code>git push origin --all</code> // 将本地所有分支更新推送给各自对应的远端分支。</li>
<li><code>git push origin tag1.0</code> // 将本地标签 <code>tag1.0</code> 更新到远端标签 <code>tag1.0</code>。</li>
<li><code>git push origin --tags</code> // 将本地所有标签更新到对应的远端标签。</li>
<li><code>git push origin :v1.0</code> // 删除远端分支 <code>v1.0</code>。</li>
<li><code>git push origin :refs/tags/tag1.0</code> // 删除远程标签 <code>tag1.0</code>。</li>
<li><code>git push origin -d v1.0</code> // 删除远端分支 <code>v1.0</code> 功能同上。</li>
</ul>
<h2 id="储藏区">储藏区</h2>
<ul>
<li><code>git stash</code> // 将工作区中所有文件的修改备份压栈到储藏区，然后丢弃工作区与暂存区的所有文件的修改。</li>
<li><code>git stash pop</code> // 使用储藏区的栈顶处备份（<code>stash@{0}</code>）来恢复当前分支的工作区，并将栈顶备份移除。</li>
<li><code>git stash apply stash@{1}</code> // 使用储藏区的栈顶下面一个备份（<code>stash@{1}</code>）来恢复当前分支的工作区，但不移除储藏区中任何备份。</li>
<li><code>git stash list</code> // 查看储藏区栈列表。</li>
<li><code>git stash show -p stash@{0}</code> // 查看储藏区的栈顶处备份中各个文件的内容。</li>
<li><code>git stash drop</code> // 直接移除储藏区的栈顶处备份（不用于恢复当前分支的工作区）。</li>
<li><code>git stash clear</code> // 清除储藏区栈列表。</li>
</ul>
<h2 id="工作区">工作区</h2>
<ul>
<li><code>git clean -nd</code> // 探测工作区中哪些文件和目录（未追踪状态）会被删除。</li>
<li><code>git clean -fd</code> // 删除工作区中未追踪状态的文件和目录。</li>
</ul>
<h2 id="暂存区">暂存区</h2>
<ul>
<li><code>git ls-files</code> // 查询暂存区中的文件列表（递归子目录）。</li>
<li><code>git ls-files -s</code> // 查看暂存区中所有文件的 <code>blob</code> 数据块信息。</li>
<li><code>git ls-files -s -- README.md</code> // 查看暂存区中的 <code>README.md</code> 文件的 <code>blob</code> 数据块信息。</li>
</ul>
<h2 id="其他命令">其他命令</h2>
<ul>
<li><code>git fsck --full</code> // 列出所有未引用的 <code>blob</code>、<code>tree</code>、<code>commit</code> 对象。</li>
<li><code>git archive --format zip --output d:/file.zip master</code> // 将当前 <code>master</code> 分支所有文件使用 <code>zip</code> 压缩方式打包到 <code>d:/file.zip</code>。</li>
</ul>
<h1 id="git-瘦身">Git 瘦身</h1>
<ul>
<li><code>git count-objects -v</code> // 查看 <code>git</code> 对象的统计信息。</li>
<li><code>find .git/objects -type f -print0 | xargs -0 du -hk | sort -nr | head -5</code> // 查找 <code>git</code> 库中最大的 <code>5</code> 个文件（<code>du -hk</code> 中的 <code>k</code> 代表单位为 KB）。</li>
<li><code>find .git/objects -type f -size +1M -print0 | xargs -0 du -hm | sort -nr | head -5</code> // 查找 <code>git</code> 库中 <code>size</code> 超过 <code>1M</code> 的最大的 <code>5</code> 个文件（<code>du -hm</code> 中的 <code>m</code> 代表单位为 MB）。</li>
<li><code>git verify-pack -v .git/objects/pack/pack-b340eea7566df839294b71ec91a327ca2ece0b94.idx | sort -k 3 -nr | head -5</code> // 对压缩存储的 <code>git</code> 库查找最大的 <code>5</code> 个文件。</li>
<li><code>git filter-branch --force --index-filter 'git rm --cached --ignore-unmatch FramePro.cpp' --prune-empty --tag-name-filter cat -- --all</code> // 从 <code>git</code> 库的历史记录中彻底清理 <code>FramePro.cpp</code>。</li>
<li><code>git for-each-ref --format='delete %(refname)' refs/original | git update-ref --stdin</code> // 清理所有废弃的 <code>ref</code> 引用。</li>
<li><code>git gc --prune=now</code>
<ol>
<li>将所有的对象压缩存储到 <code>pack</code> 二进制文件中，以节省空间和提高效率。</li>
<li>移除与任何提交都不相关的陈旧对象。</li>
</ol>
</li>
<li><code>git reflog expire --expire=now --all</code> // 清除所有操作记录日志。<br>
除了使用 <code>git</code> 原生命令外，可以使用专门的工具 <code>BFG</code>（<code>Java</code> 实现）来对 <code>Git</code> 库瘦身。</li>
</ul>
<h1 id="经典-gitflow">经典 Gitflow</h1>
<figure data-type="image" tabindex="2"><img src="https://faded.auspicious.space/post-images/1587134458229.png" alt="" loading="lazy"></figure>
<ol>
<li><code>master</code> 分支存储了正式发布的历史（<code>master</code> 分支上的所有提交都会分配一个版本号）。</li>
<li><code>develop</code> 分支作为功能的集成分支。</li>
<li>每个新功能位于一个自己的 <code>Feature</code> 分支，该分支使用 <code>develop</code> 分支作为父分支。当新功能完成时，合并回 <code>develop</code> 分支。新功能提交应该从不直接与 <code>master</code> 分支交互。</li>
<li>一旦 <code>develop</code> 分支上有了做一次发布（或者说快到了既定的发布日）的足够功能，就从 <code>develop</code> 分支上 <code>fork</code> 一个 <code>release</code>分支。<br>
新建的分支用于开始发布循环，所以从这个时间点开始之后新的功能不能再加到这个分支上。 这个分支只应该做 <code>Bug</code> 修复、文档生成和其它面向发布任务。<br>
对外发布的工作完成后，发布分支会合并到 <code>master</code> 分支并分配一个版本号打好 <code>Tag</code>。另外，这些从新建发布分支以来的做的修改要合并回 <code>develop</code> 分支。</li>
<li><code>hotfix</code> 分支用于生成快速给产品发布版本（production releases）打补丁，修复完成，修改应该马上合并回 <code>master</code> 分支（打好 <code>Tag</code>）和 <code>develop</code> 分支（当前的发布分支）。</li>
</ol>
<h1 id="参考">参考</h1>
<ul>
<li><a href="https://github.com/bingoHuang/progit2-gitbook">Pro Git 第二版pdf</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2018/10/git-internals.html">Git 原理入门</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html">常用 Git 命令清单</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2014/06/git_remote.html">Git 远程操作详解</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2015/12/git-workflow.html">Git 工作流程</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2015/08/git-use-process.html">Git 使用规范流程</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2012/07/git.html">Git 分支管理策略</a></li>
<li><a href="http://guibin.iteye.com/blog/1014369">GIT 基本概念和用法总结</a></li>
<li><a href="http://blog.jobbole.com/76867/">Git 工作流指南：Gitflow 工作流</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Git——25个进阶技巧]]></title>
        <id>https://faded.auspicious.space/post/git-25-advanced-skills/</id>
        <link href="https://faded.auspicious.space/post/git-25-advanced-skills/">
        </link>
        <updated>2020-04-17T02:54:39.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p><a href="https://linux.cn/article-5418-1.html">25个 Git 进阶技巧</a></p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p><a href="https://linux.cn/article-5418-1.html">25个 Git 进阶技巧</a></p>
</blockquote>
<!-- more -->
<h1 id="基本技巧">基本技巧</h1>
<h2 id="1-安装后的第一步">1. 安装后的第一步</h2>
<p>在安装好 <code>git</code> 后，你第一件该做的事是设置你的名字和电子邮箱，因为每次提交都要用到这些信息：</p>
<pre><code class="language-bash">$ git config --global user.name &quot;Some One&quot;
$ git config --global user.email &quot;someone@gmail.com&quot;
</code></pre>
<h2 id="2-git-是基于指针的">2. Git 是基于指针的</h2>
<p>保存在 <code>git</code> 里的一切都是文件。当你创建一个提交的时候，会建立一个包含你的提交信息和相关数据（名字，邮件地址，日期/时间，前一个提交，等等）的文件，并把它链接到一个树文件中。这个树文件中包含了对象或其他树的列表。这里的提到的对象（或二进制大对象）是和本次提交相关的实际内容（它也是一个文件，另外，尽管文件名并没有包含在对象里，但是存储在树中）。所有这些文件都使用对象的 <code>SHA-1</code> 哈希值作为文件名。</p>
<p>用这种方式，分支和标签就是简单的文件（基本上是这样），包含指向该提交的 <code>SHA-1</code> 哈希值。使用这些索引会带来优秀的灵活性和速度，比如创建一个新分支就是简单地用分支名字和所分出的那个提交的 <code>SHA-1</code> 索引来创建一个文件。当然，你不需要自己做这些，而只要使用 <code>Git</code> 命令行工具（或者 GUI），但是实际上就是这么简单。</p>
<p>你也许听说过叫 <code>HEAD</code> 的索引。这只是简单的一个文件，包含了你当前指向的那个提交的 <code>SHA-1</code> 索引值。如果你正在解决一次合并冲突然后看到了 <code>HEAD</code>，这并不是一个特别的分支或分支上的一个必需的特殊位置，只是标明你当前所在位置。</p>
<p>所有的分支指针都保存在 <code>.git/refs/heads</code> 里，<code>HEAD</code> 在 <code>.git/HEAD</code> 里，而标签保存在 <code>.git/refs/tags</code> 里——自己可以随便进去看看。</p>
<h2 id="3-两个爸爸父节点-你没看错">3. 两个爸爸（父节点） - 你没看错！</h2>
<p>在历史中查看一个合并提交的信息时，你将看到有两个父节点（不同于工作副本上的常规提交的情况）。第一个父节点是你所在的分支，第二个是你合并过来的分支。</p>
<h2 id="4-合并冲突">4. 合并冲突</h2>
<p>目前我相信你碰到过合并冲突并且解决过。通常是编辑一下文件，去掉 <code>&lt;&lt;&lt;&lt;</code>，<code>====</code>，<code>&gt;&gt;&gt;&gt;</code> 标志，保留需要留下的代码。有时能够看到这两个修改之前的代码会很不错，比如，在这两个现在冲突的分支之前的改动。下面是一种方式：</p>
<pre><code class="language-bash">$ git diff --merge
diff --cc dummy.rb  
index 5175dde,0c65895..4a00477  
--- a/dummy.rb
+++ b/dummy.rb
@@@ -1,5 -1,5 +1,5 @@@
  class MyFoo
    def say
-     puts &quot;Bonjour&quot;
 -    puts &quot;Hello world&quot;
++    puts &quot;Annyong Haseyo&quot;
    end
  end
</code></pre>
<p>如果是二进制文件，比较差异就没那么简单了...通常你要做的就是测试这个二进制文件的两个版本来决定保留哪个（或者在二进制文件编辑器里手工复制冲突部分）。从一个特定分支获取文件拷贝（比如说你在合并 <code>master</code> 和 <code>feature123</code> 两个分支）：</p>
<pre><code class="language-bash">$ git checkout master flash/foo.fla # 或者...
$ git checkout feature132 flash/foo.fla
$ # 然后...
$ git add flash/foo.fla
</code></pre>
<p>另一种方式是通过 <code>git</code> 输出文件——你可以输出到另外的文件名，然后当你决定了要用哪个后，再将选定的正确文件复制为正常的文件名：</p>
<pre><code class="language-bash">$ git show master:flash/foo.fla &gt; master-foo.fla
$ git show feature132:flash/foo.fla &gt; feature132-foo.fla
$ # 检出master-foo.fla和feature132-foo.fla
$ # 假如说我们决定来自feature132的文件是正确的
$ rm flash/foo.fla
$ mv feature132-foo.fla flash/foo.fla
$ rm master-foo.fla
$ git add flash/foo.fla
</code></pre>
<p>更新：感谢 Carl 在原博客文章上评论里的提醒，你实际上可以用 <code>git checkout —ours flash/foo.fla</code> 和 <code>git checkout —theirs flash/foo.fla</code> 来检出特定版本的文件，而不用记住你在合并的分支名字。就我个人来说喜欢更精确一点，但这也是一种方式...</p>
<p>记着在解决完冲突后要将文件加入提交（像我上面做的那样）。</p>
<h1 id="服务器分支和标签">服务器，分支和标签</h1>
<h2 id="5-远端服务器">5. 远端服务器</h2>
<p><code>git</code> 的一个超强大的功能就是可以有不止一个远端服务器（实际上你一直都在一个本地仓库上工作）。你并不是一定都要有这些服务器的写权限，你可以有多个可以读取的服务器（用来合并他们的工作）然后写入到另外一个仓库。添加一个新的远端服务器很简单：</p>
<pre><code class="language-bash">$ git remote add john git@github.com:johnsomeone/someproject.git
</code></pre>
<p>如果你想查看远端服务器的信息可以这样做：</p>
<pre><code class="language-bash"># 显示每个远端服务器的URL
$ git remote -v 
# 提供更多详细信息
$ git remote show name 
</code></pre>
<p>你随时都可以查看本地分支和远端分支的差异：</p>
<pre><code class="language-bash">$ git diff master..john/master
</code></pre>
<p>你也可以查看没有在远端分支上的 <code>HEAD</code> 的改动：</p>
<pre><code class="language-bash">$ git log remote/branch..
# 注意：..后面没有结束的特定引用
</code></pre>
<h2 id="6-标签">6. 标签</h2>
<p>在 <code>git</code> 里有两种类型的标签——轻量级标签和带注释标签。记住<a href="#2-git-%E6%98%AF%E5%9F%BA%E4%BA%8E%E6%8C%87%E9%92%88%E7%9A%84">技巧 2</a> 里说过 <code>git</code> 是基于指针的，这两者之间的差异也很简单。轻量级标签只是一个简单的指向一次提交的带名字指针。你随时都可以将它指向另一个提交。带注释标签是一个指向标签对象的带名字指针，带有自己的信息和历史。因为有自己的信息，它可以根据需要用 <code>GPG</code> 签名。</p>
<p>建立这两种类型的标签都很简单（只有一个命令行开关的差异）</p>
<pre><code class="language-bash">$ git tag to-be-tested
$ git tag -a v1.1.0 # 会提示输入标签的信息
</code></pre>
<h2 id="7-建立分支">7. 建立分支</h2>
<p>在 <code>git</code> 里建立分支非常简单（而且像闪电一样快，因为它只需要创建一个小于 100 字节的文件）。用普通方式建立新分支并切换过去：</p>
<pre><code class="language-bash">$ git branch feature132
$ git checkout feature132
</code></pre>
<p>当然，如果你确定自己直接切换到新建的分支，可以用一个命令实现：</p>
<pre><code class="language-bash">$ git checkout -b feature132
</code></pre>
<p>如果你想重命名一个本地分支也很简单（可以显示发生了什么的较长的方式）：</p>
<pre><code class="language-bash">$ git checkout -b twitter-experiment feature132
$ git branch -d feature132
</code></pre>
<p>更新：你也可以（像 Brian Palmer 在原博客文章的评论里提出的）只用 <code>git branch</code> 的 <code>-m</code> 开关在一个命令里实现（像 Mike 提出的，如果你只指定了一个分支参数，就会重命名当前分支）：</p>
<pre><code class="language-bash">$ git branch -m twitter-experiment
$ git branch -m feature132 twitter-experiment
</code></pre>
<h2 id="8-合并分支">8. 合并分支</h2>
<p>也许在将来的某个时候，你希望将改动合并。有两种方式：</p>
<pre><code class="language-bash">$ git checkout master
$ git merge feature83 # 或者...
$ git rebase feature83
</code></pre>
<p><code>merge</code> 和 <code>rebase</code> 之间的差别是 <code>merge</code> 会尝试处理改动并建立一个新的混合了两者的提交。<code>rebase</code> 会尝试把你从一个分支最后一次分离后的所有改动，一个个加到该分支的 <code>HEAD</code> 上。不过，在已经将分支推到远端服务器后不要再 <code>rebase</code> 了 - 这会引起冲突/问题。</p>
<p>如果你不确定在哪些分支上还有独有的工作——所以你也不知道哪些分支需要合并而哪些可以删除，<code>git branch</code> 有两个开关可以帮你：</p>
<pre><code class="language-bash"># 显示已经全部合并到当前分支的分支
$ git branch --merged
# 显示没有合并到当前分支的分支
$ git branch --no-merged
</code></pre>
<h2 id="9-远端分支">9. 远端分支</h2>
<p>如果你在本地有一个分支希望推到远端服务器上，你可以用一行命令推送上去：</p>
<pre><code class="language-bash">$ git push origin twitter-experiment:refs/heads/twitter-experiment
# origin是我们服务器的名字，而twitter-experiment是分支名字
</code></pre>
<p>更新：感谢 Erlend 在原博客文章上的评论——这个实际上和 <code>git push origin twitter-experiment</code> 效果一样，不过使用完整的语法，你可以在两者之间使用不同的分支名（这样本地分支可以是 <code>add-ssl-support</code> 而远端是 issue-1723）。</p>
<p>如果你想在远端服务器上删除一个分支（注意分支名前面的冒号）：</p>
<pre><code class="language-bash">$ git push origin :twitter-experiment
</code></pre>
<p>如果你想查看所有远端分支的状态可以这样做：</p>
<pre><code class="language-bash">$ git remote show origin
</code></pre>
<p>这个命令可能会列出服务器上一些以前有过但现在已经不在了的分支。如果碰到这种情况你可以用下面的命令从你本地分支里清理掉：</p>
<pre><code class="language-bash">$ git remote prune
</code></pre>
<p>最后，如果你想在本地跟踪一个远端分支，普通的方式是：</p>
<pre><code class="language-bash">$ git branch --track myfeature origin/myfeature
$ git checkout myfeature
</code></pre>
<p>不过，新版的 <code>git</code> 在使用 <code>-b</code> 标记检出分支时会自动设定跟踪：</p>
<pre><code class="language-bash">$ git checkout -b myfeature origin/myfeature
</code></pre>
<h1 id="在储藏点索引和文件系统中保存内容">在储藏点，索引和文件系统中保存内容</h1>
<h2 id="10-储藏">10. 储藏</h2>
<p>在 <code>git</code> 里你可以把当前工作状态放进一个储藏堆栈中，然后可以再取出来。最简单的情形是下面这样：</p>
<pre><code class="language-bash">$ git stash
# 做点其他事情...
$ git stash pop
</code></pre>
<p>许多人建议使用 <code>git stash apply</code> 来代替 <code>pop</code>，不过如果这样做的话最后会遗留一个很长的储藏列表。而 <code>pop</code> 会在全部加载后自动从堆栈中移除。如果使用过 <code>git stash apply</code>，你也可以使用下面的命令从堆栈上移除最后一项：</p>
<pre><code class="language-bash">$ git stash drop
</code></pre>
<p><code>git</code> 会基于当前的提交信息自动创建评论。如果你更希望有自定义信息的话（因为它可能和前一个提交没有任何联系）：</p>
<pre><code class="language-bash">$ git stash save &quot;My stash message&quot;
</code></pre>
<p>如果你希望从列表中取出一个特定的储藏点（不一定非得是最后一个）可以先列出它们然后用下面的方式取出：</p>
<pre><code class="language-bash">$ git stash list
  stash@{0}: On master: Changed to German
  stash@{1}: On master: Language is now Italian
$ git stash apply stash@{1}
</code></pre>
<h2 id="11-交互式添加">11. 交互式添加</h2>
<p>在 <code>subversion</code> 的世界里你只能修改文件然后提交所有改动。而在 <code>git</code> 里你有强大得多的方式来提交部分文件或者甚至是部分补丁。提交部分文件或文件中的部分改动你需要进入交互式模式：</p>
<pre><code class="language-bash">$ git add -i
           staged     unstaged path
*** Commands ***
  1: status      2: update   3: revert   4: add untracked
  5: patch      6: diff     7: quit     8: help
What now&gt;  
</code></pre>
<p>这会让你进入一个基于菜单的交互式提示。你可以使用命令中的数字或高亮的字母（如果你在终端里打开了高亮的话）来进入相应的模式。然后就只是输入你希望操作的文件的数字了（你可以使用这样的格式，<code>1</code> 或者 <code>1-4</code> 或 <code>2,4,7</code>）。</p>
<p>如果你想进入补丁模式（交互式模式下按 <code>p</code> 或 <code>5</code>），你也可以直接进入：</p>
<pre><code class="language-bash">$ git add -p    
diff --git a/dummy.rb b/dummy.rb  
index 4a00477..f856fb0 100644  
--- a/dummy.rb
+++ b/dummy.rb
@@ -1,5 +1,5 @@
 class MyFoo
   def say
-    puts &quot;Annyong Haseyo&quot;
+    puts &quot;Guten Tag&quot;
   end
 end
Stage this hunk [y,n,q,a,d,/,e,?]?  
</code></pre>
<p>你可以看到下方会有一些选项供选择用来添加该文件的这个改动、该文件的所有改动，等等。使用 <code>?</code> 命令可以详细解释这些选项。</p>
<h2 id="12-从文件系统里保存取回改动">12. 从文件系统里保存/取回改动</h2>
<p>有些项目（比如 <code>Git</code> 项目本身）在 <code>git</code> 文件系统中直接保存额外文件而并没有将它们加入到版本控制中。<br>
让我们从在 <code>git</code> 中存储一个随机文件开始：</p>
<pre><code class="language-bash">$ echo &quot;Foo&quot; | git hash-object -w --stdin
51fc03a9bb365fae74fd2bf66517b30bf48020cb  
</code></pre>
<p>这样这个目标文件就已经保存到数据库中了，但是如果你没有设定一个指向它的指针的话它会被当做垃圾回收。最简单的方式是设定一个标签：</p>
<pre><code class="language-bash">$ git tag myfile 51fc03a9bb365fae74fd2bf66517b30bf48020cb
</code></pre>
<p>注意这里我们使用了标签 <code>myfile</code>。当我们需要使用这个文件的时候可以这样做：</p>
<pre><code class="language-bash">$ git cat-file blob myfile
</code></pre>
<p>这个对于一些工具文件很有用，开发者可能会用到（密码，<code>GPG</code> 密钥，等等）但是又不希望每次都检出到硬盘（尤其是在实际工作中）。</p>
<h1 id="日志以及有哪些改动">日志以及有哪些改动？</h1>
<h2 id="13-查看日志">13. 查看日志</h2>
<p>长时间使用 <code>Git</code> 的话，不会没用过 <code>git log</code> 来查看最近的提交。不过，有一些技巧来更好地应用。比如，你可以使用下面的命令来查看每次提交的具体改动：</p>
<pre><code class="language-bash">$ git log -p
</code></pre>
<p>或者你可以仅仅查看有哪些文件改动：</p>
<pre><code class="language-bash">$ git log --stat
</code></pre>
<p>有个很不错的别名你可以试试，会显示简短提交名和一个不错的分支图并在一行里显示提交信息（有点像 <code>gitk</code>，但是是在命令行下）：</p>
<pre><code class="language-bash">$ git config --global alias.lol &quot;log --pretty=oneline --abbrev-commit --graph --decorate&quot;
$ git lol
* 4d2409a (master) Oops, meant that to be in Korean
* 169b845 Hello world
</code></pre>
<h2 id="14-搜索日志">14. 搜索日志</h2>
<p>如果你想找特定提交者可以这样做：</p>
<pre><code class="language-bash">$ git log --author=Andy
</code></pre>
<p>更新：感谢 Johannes 的评论，我已经去掉了之前这里的一些有混淆的地方。</p>
<p>或者你想在提交信息里找一些相关字段：</p>
<pre><code class="language-bash">$ git log --grep=&quot;Something in the message&quot;
</code></pre>
<p>也有一个更强大的叫做 <code>pickaxe</code> 的命令用来查找包含了删除或添加的某个特定内容的提交（比如，该内容第一次出现或被删除）。这可以告诉你什么时候增加了一行（但这一行里的某个字符后面被改动过就不行了）：</p>
<pre><code class="language-bash">$ git log -S &quot;TODO: Check for admin status&quot;
</code></pre>
<p>假如你改动了一个特定的文件，比如 <code>lib/foo.rb</code></p>
<pre><code class="language-bash">$ git log lib/foo.rb
</code></pre>
<p>比如说你有一个 <code>feature/132</code> 分支和 <code>feature/145</code> 分支，然后你想看看这两个分支上不在 <code>master</code> 分支里的提交（注意符号 <code>^</code> 是不在的意思）：</p>
<pre><code class="language-bash">$ git log feature/132 feature/145 ^master
</code></pre>
<p>你也可以使用 <code>ActiveSupport</code> 格式的日期来缩小到某个日期范围：</p>
<pre><code class="language-bash">$ git log --since=2.months.ago --until=1.day.ago
</code></pre>
<p>默认情况下会用 <code>OR</code> 来组合查询，但你可以轻易地改为 <code>AND</code>（如果你有超过一条的查询标准）</p>
<pre><code class="language-bash">$ git log --since=2.months.ago --until=1.day.ago --author=andy -S &quot;something&quot; --all-match
</code></pre>
<h2 id="15-查看修改版本">15. 查看/修改版本</h2>
<p>有很多方式可以用来引用一个版本，看你记得哪个：</p>
<pre><code class="language-bash">$ git show 12a86bc38 # 根据版本
$ git show v1.0.1 # 根据标签
$ git show feature132 # 根据分支名
$ git show 12a86bc38^ # 一次提交的父节点
$ git show 12a86bc38~2 # 一次提交的祖父节点
$ git show feature132@{yesterday} # 时间相关
$ git show feature132@{2.hours.ago} # 时间相关
</code></pre>
<p>注意和之前部分有些不同，末尾 <code>^</code> 的意思是该提交的父节点——开始位置 <code>^</code> 的意思是不在这个分支。</p>
<h2 id="16-选择范围">16. 选择范围</h2>
<p>最简单的方式：</p>
<pre><code class="language-bash">$ git log origin/master..new
# [old]..[new] - 所有你还没有推送的提交
</code></pre>
<p>你也可以省略 <code>[new]</code>，将使用当前的 <code>HEAD</code>。</p>
<h1 id="时光回溯和后悔药">时光回溯和后悔药</h1>
<h2 id="17-重置改动">17. 重置改动</h2>
<p>如果你还没有提交的话可以用下面的命令轻松地取消改动：</p>
<pre><code class="language-bash">$ git reset HEAD lib/foo.rb
</code></pre>
<p>通常会使用 <code>unstage</code> 的别名，因为上面的看上去有些不直观。</p>
<pre><code class="language-bash">$ git config --global alias.unstage &quot;reset HEAD&quot;
$ git unstage lib/foo.rb
</code></pre>
<p>如果你已经提交了该文件，你可以做两件事 - 如果是最后一次提交你还可以改正：</p>
<pre><code class="language-bash">$ git commit --amend
</code></pre>
<p>这会取消最后一次提交，把工作分支回退到提交前标记了所有改动的状态，而且提交信息也都准备好可以修改或直接提交。</p>
<p>如果你已经提交过多次而且希望全部回退，你可以将分支重置到合适的位置。</p>
<pre><code class="language-bash">$ git checkout feature132
$ git reset --hard HEAD~2
</code></pre>
<p>如果你实际上希望将分支指向一个完全不同的 <code>SHA1</code>（也许你要将一个分支的 <code>HEAD</code> 替换到另一个分支，或者之后的某次提交）你可以使用下面的较长的方式：</p>
<pre><code class="language-bash">$ git checkout FOO
$ git reset --hard SHA
</code></pre>
<p>实际上有一个快速的方式（不需要先把你的工作分支切换到 <code>FOO</code> 再前进到 <code>SHA</code>）：</p>
<pre><code class="language-bash">$ git update-ref refs/heads/FOO SHA
</code></pre>
<h2 id="18-提交到了错误的分支">18. 提交到了错误的分支</h2>
<p>好吧，假如说你已经提交到了 <code>master</code>，但却应该创建一个叫 <code>experimental</code> 的主题分支更合适。要移动这些改动，你可以在当前位置创建分支，回退 <code>HEAD</code> 再检出新分支：</p>
<pre><code class="language-bash">$ git branch experimental   # 创建一个指向当前master的位置的指针
$ git reset --hard master~3 # 移动master分支的指针到3个版本之前
$ git checkout experimental
</code></pre>
<p>如果你的改动是在分支的分支的分支上会更复杂。那样你需要做的是将分支基础切换到其他地方：</p>
<pre><code class="language-bash">$ git branch newtopic STARTPOINT
$ git rebase oldtopic --onto newtopic
</code></pre>
<h2 id="19-交互式切换基础">19. 交互式切换基础</h2>
<p>这是一个我之前看过展示却没真正理解过的很赞的功能，现在觉得它就很简单了。假如说你提交了3次但是你希望更改顺序或编辑（或者合并）：</p>
<pre><code class="language-bash">$ git rebase -i master~3
</code></pre>
<p>然后这会启动你的编辑器并带有一些指令。你所要做的就是修改这些指令来选择/插入/编辑（或者删除）提交和保存/退出。然后在编辑完后你可以用 <code>git rebase --continue</code> 命令来让每一条指令生效。</p>
<p>如果你有修改，将会切换到你提交时所处的状态，之后你需要使用命令 <code>git commit --amend</code> 来编辑。</p>
<table>
<thead>
<tr>
<th>注意：在 <code>rebase</code> 的时候千万不要提交 - 只能先添加然后使用参数 <code>--continue</code>，<code>--skip</code> 或 <code>--abort</code>。</th>
</tr>
</thead>
<tbody></tbody>
</table>
<h2 id="20-清理">20. 清理</h2>
<p>如果你提交了一些内容到你的分支（也许你从 <code>SVN</code> 导入了一些旧仓库），然后你希望把某个文件从历史记录中全部删掉：</p>
<pre><code class="language-bash">$ git filter-branch --tree-filter 'rm -f *.class' HEAD
</code></pre>
<p>如果你已经推送到 <code>origin</code> 了，但之后提交了一些垃圾改动，你也可以在推送前在本地系统里这样做：</p>
<pre><code class="language-bash">$ git filter-branch --tree-filter 'rm -f *.class' origin/master..HEAD
</code></pre>
<h1 id="其他技巧">其他技巧</h1>
<h2 id="21-你查看过的前一个引用">21. 你查看过的前一个引用</h2>
<p>如果你知道自己之前查看过一个 <code>SHA-1</code>，但是随后做了一些重置/回退的操作，你可以使用 <code>reflog</code> 命令来列出最近查看过的 <code>SHA-1</code> 记录：</p>
<pre><code class="language-bash">$ git reflog
$ git log -g # 和上面一样，但是使用'log'格式输出
</code></pre>
<h2 id="22-分支命名">22. 分支命名</h2>
<p>一个可爱的小技巧 - 别忘了分支名并不限于 <code>a-z</code> 和 <code>0-9</code>。名字中可以用/和.将非常方便用来建立伪命名空间或版本，例如：</p>
<pre><code class="language-bash">$ # 生成版本132的改动历史
$ git shortlog release/132 ^release/131
$ # 贴上v1.0.1的标签
$ git tag v1.0.1 release/132
</code></pre>
<h2 id="23-找出谁是凶手">23. 找出谁是凶手</h2>
<p>通常找出来谁改动了某个文件里的某行代码会很有用。实现这个功能的最简单命令是：</p>
<pre><code class="language-bash">$ git blame FILE
</code></pre>
<p>有时候这些改动来自其他文件（如果你合并了两个文件，或者你移动了某个函数）所以你可以使用下面的命令：</p>
<pre><code class="language-bash">$ # 显示内容来自哪个文件
$ git blame -C FILE
</code></pre>
<p>有时候通过点击各个改动然后回到很早很早以前来跟踪改动会很不错。有一个很好的内建 GUI 命令来做这个：</p>
<pre><code class="language-bash">$ git gui blame FILE
</code></pre>
<h2 id="24-数据维护">24. 数据维护</h2>
<p>通常 <code>git</code> 不需要经常维护，它把自己照顾的很好。不过，你可以通过下面的命令查看数据统计：</p>
<pre><code class="language-bash">$ git count-objects -v
</code></pre>
<p>如果占用很多空间的话，你可以选择在你的本地仓库做垃圾回收。这不会影响推送或其他人，却会让一些命令运行更快而且减少空间占用：</p>
<pre><code class="language-bash">$ git gc
</code></pre>
<p>经常运行完整性检查也很有意义：</p>
<pre><code class="language-bash">$ git fsck --full
</code></pre>
<p>你也可以在末尾加上 <code>--auto</code> 参数（如果你在服务器上通过 <code>crontab</code> 经常/每天都运行这个命令的话），然后它只会在必要的时候才执行 fsck` 动作。</p>
<p>在检查的时候，看到 <code>dangling</code> 或 <code>unreachable</code> 是正常的，通常这是由回退 <code>HEAD</code> 或切换基础的结果。而看到 <code>missing</code> 或 <code>sha1 mismatch</code> 就不对了...找专业人士帮忙吧！</p>
<h2 id="25-恢复遗失的分支">25. 恢复遗失的分支</h2>
<p>如果你使用 <code>-D</code> 参数删除了 <code>experimental</code> 分支，可以用下面的命令重新建立：</p>
<pre><code class="language-bash">$ git branch experimental SHA1_OF_HASH
</code></pre>
<p>如果你最近访问过的话，你通常可以用 <code>git reflog</code> 来找到 <code>SHA1</code> 哈希值。</p>
<p>另一种方式是使用 <code>git fsck —lost-found</code>。其中一个 <code>dangling</code> 的提交就是丢失的 <code>HEAD</code>（它只是已删除分支的 <code>HEAD</code>，而 <code>HEAD</code> 被引用为当前的 <code>HEAD</code> 所以它并不处于 <code>dangling</code> 状态）。</p>
]]></content>
    </entry>
</feed>