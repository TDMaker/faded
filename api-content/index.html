{"posts":[{"title":"区块链——入门","content":"1 涉及到的技术 密码学 分布式一致性协议 点对点网络通信技术 智能合约编程语言等。 2 区块链的分类 按照参与方式：公开链、私有链、联盟链。 2.1 公开链 公有链的任何节点都是向任何人开放的，每个人都可以参与到这个区块链中的计算，而且任何人都可以下载获得完整区块链数据，即全部账本。 2.2 私有链 在某些区块链的应用场景下，开发者并不希望任何人都可以参与这个系统，因此建立一种不对外公开、只有被许可的节点才可以参与并且查看所有数据的私有区块链，私有链一般适用于特定机构的内部数据管理与审计。 2.3 联盟链 联盟链是指参与每个节点的权限都完全对等，各节点在不需要完全互信的情况下就可以实现数据的可信交换，联盟链的各个节点通常有与之对应的实体机构组织，通过授权后才能加入或退出网络。联盟链是一种公司与公司、组织与组织之间达成联盟的模式。 3 区块链的工作量证明机制 3.1 POW：proof of power, 工作量证明机制 PoW（工作量证明），也就是像比特币的挖矿机制，矿工通过把网络尚未记录的现有交易打包到一个区块，然后不断遍历尝试来寻找一个随机数，使得新区块加上随机数的哈希值满足一定的难度条件，例如前面 10 位是零。找到满足条件的随机数，就相当于确定了区块链最新的一个区块，也相当于获得了区块链的本轮记账权。矿工把满足挖矿难度条件的区块在网络中广播出去，全网其他节点在验证该区块满足挖矿难度条件，同时区块里的交易数据符合协议规范后，将各自把该区块链接到自己版本的区块链上，从而在全网形成对当前网络状态的共识。 优点：完全去中心化，节点自由进出，避免了建立和维护中心化信用机构的成本。只要网络破坏者的算力不超过网络总算力的 50%，网络的交易状态就能达成一致。 缺点：目前比特币挖矿造成大量的资源浪费；另外挖矿的激励机制也造成矿池算力的高度集中，背离了当初去中心化设计的初衷。更大的问题是 PoW 机制的共识达成的周期较长，每秒只能最多做 7 笔交易，不适合商业应用。 3.2 POS：proof of stake, 股权证明 PoS 权益证明，要求节点提供拥有一定数量的代币证明来获取竞争区块链记账权的一种分布式共识机制。如果单纯依靠代币余额来决定记账者必然使得富有者胜出，导致记账权的中心化，降低共识的公正性，因此不同的 PoS 机制在权益证明的基础上，采用不同方式来增加记账权的随机性来避免中心化。例如点点币（PeerCoin）PoS 机制中，拥有最多链龄长的比特币获得记账权的几率就越大。NXT 和 Blackcoin 则采用一个公式来预测下一个记账的节点。拥有多的代币被选为记账节点的概率就会大。未来以太坊也会从目前的 PoW 机制转换到 PoS 机制，从目前看到的资料看，以太坊的 PoS 机制将采用节点下赌注来赌下一个区块，赌中者有额外以太币奖，赌不中者会被扣以太币的方式来达成下一区块的共识。 优点：在一定程度上缩短了共识达成的时间，降低了 PoW 机制的资源浪费。 缺点：破坏者对网络攻击的成本低，网络的安全性有待验证。另外拥有代币数量大的节点获得记账权的几率更大，会使得网络的共识受少数富裕账户支配，从而失去公正性。 3.3 DPOS：delegated proof of stake, 共识机制，委托权以证明 DPoS（股份授权证明）机制，类似于董事会投票。比特股（bitshares）采用的 PoS 机制是持股者投票选出一定数量的见证人，每个见证人按序有两秒的权限时间生成区块，若见证人在给定的时间片不能生成区块，区块生成权限交给下一个时间片对应的见证人。持股人可以随时通过投票更换这些见证人。DPoS 的这种设计使得区块的生成更为快速，也更加节能。 优点：大幅缩小参与验证和记账节点的数量，可以达到秒级的共识验证。 缺点：选举固定数量的见证人作为记账候选人有可能不适合于完全去中心化的场景。另外在网络节点数少的场景，选举的见证人的代表性也不强。 4 分布式一致性算法 分布式一致性算法是基于传统的分布式一致性技术。其中有分为解决拜占庭将军问题的拜占庭容错算法，如 PBFT。另外解决非拜占庭问题的分布式一致性算法（Pasox、Raft）。该类算法目前是联盟链和私有链场景中常用的共识机制。 优点：实现秒级的快速共识机制，保证一致性。 缺点：去中心化程度不如公有链上的共识机制；更适合多方参与的多中心商业模式。 4.1 拜占庭将军问题 /Byzantine Generals Problem/ BGP 由莱斯利·兰波特在其同名论文中提出的分布式对等网络通信容错问题。在分布式计算中，不同的计算机通过通讯交换信息达成共识而按照同一套协作策略行动。但有时候，系统中的成员计算机可能出错而发送错误的信息，用于传递信息的通讯网络也可能导致信息损坏，使得网络中不同的成员关于全体协作的策略得出不同结论，从而破坏系统一致性。拜占庭将军问题被认为是容错性问题中最难的问题类型之一。 4.2 改进型实用拜占庭容错 /Practical Byzantine Fault Tolerance/ PBFT PBET 共识机制是少数服从多数，根据信息在分布式网络中节点间互相交换后各节点列出所有得到的信息，一个节点代表一票，选择大多数的结果作为解决办法。PBET 将容错量控制在全部节点数的 $$\\bar{x}$$，即如只要有超过2/3 的正常节点，整个系统便可正常运作。 ","link":"https://tdmaker.github.io/faded/post/blockchain-introduction/"},{"title":"正则表达式——完整版教程","content":" JS正则表达式完整教程（略长） 引言 本文内容共有七章，用 JavaScript 语言完整地讨论了正则表达式的方方面面。 具体章节如下： 引言 第 1 章 正则表达式字符匹配攻略 第 2 章 正则表达式位置匹配攻略 第 3 章 正则表达式括号的作用 第 4 章 正则表达式回溯法原理 第 5 章 正则表达式的拆分 第 6 章 正则表达式的构建 第 7 章 正则表达式编程后记 下面简单地说说每一章都讨论了什么。 正则是匹配模式，要么匹配字符，要么匹配位置。 第 1 章和第 2 章以这个角度去讲解了正则的基础。 在正则中可以使用括号捕获数据，要么在 API 中进行分组引用，要么在正则里进行反向引用。 这是第 3 章的主题，讲解了正则中括号的作用。 学习正则表达式，是需要了解其匹配原理的。第 4 章，讲解了正则了正则表达式的回溯法原理。另外在第 6 章里，也讲解了正则的表达式的整体工作原理。 不仅能看懂别人的正则，还要自己会写正则。 第 5 章，是从读的角度，去拆分一个正则表达式，而第 6 章是从写的角度，去构建一个正则表达式。 学习正则，是为了在真实世界里应用的。 第 7 章讲解了正则的用法，和相关 API 需要注意的地方。 第 1 章 正则表达式字符匹配攻略 正则表达式是匹配模式，要么匹配字符，要么匹配位置。请记住这句话。 然而关于正则如何匹配字符的学习，大部分人都觉得这块比较杂乱。 毕竟元字符太多了，看起来没有系统性，不好记。本章就解决这个问题。 内容包括： 两种模糊匹配 字符组 量词 多选分支 案例分析 1.1 两种模糊匹配 如果正则只有精确匹配是没多大意义的，比如 /hello/，也只能匹配字符串中的 &quot;hello&quot; 这个子串。 const regex = /hello/; console.log(regex.test('hello')); // =&gt; true 正则表达式之所以强大，是因为其能实现模糊匹配。而模糊匹配，有两个方向上的“模糊”：横向模糊匹配和纵向模糊匹配。 1.1.1 横向模糊匹配 横向模糊指的是，一个正则可匹配的字符串的长度不是固定的，可以是多种情况的。其实现的方式是使用量词。譬如 {m,n}，表示连续出现最少 m 次，最多 n 次。比如 /ab{2,5}c/ 表示匹配这样一个字符串：第一个字符是 &quot;a&quot;，接下来是 2 到 5 个字符是 &quot;b&quot;，最后是字符 &quot;c&quot;。测试如下： const regex = /ab{2,5}c/g; const string = 'abc abbc abbbc abbbbc abbbbbc abbbbbbc'; console.log(string.match(regex)); // =&gt; [&quot;abbc&quot;, &quot;abbbc&quot;, &quot;abbbbc&quot;, &quot;abbbbbc&quot;] 注意：案例中用的正则是 /ab{2,5}c/g，后面多了 g，它是正则的一个修饰符。表示全局匹配，即在目标字符串中按顺序找到满足匹配模式的所有子串，强调的是“所有”，而不只是“第一个”。g 是单词 global 的首字母。 1.1.2 纵向模糊匹配 纵向模糊指的是，一个正则匹配的字符串，具体到某一位字符时，它可以不是某个确定的字符，可以有多种可能。其实现的方式是使用字符组。譬如 [abc]，表示该字符是可以字符 &quot;a&quot;、&quot;b&quot;、&quot;c&quot; 中的任何一个。比如 /a[123]b/ 可以匹配如下三种字符串：&quot;a1b&quot;、&quot;a2b&quot;、&quot;a3b&quot;。测试如下： const regex = /a[123]b/g; const string = 'a0b a1b a2b a3b a4b'; console.log(string.match(regex)); // =&gt; [&quot;a1b&quot;, &quot;a2b&quot;, &quot;a3b&quot;] 以上就是本章讲的主体内容，只要掌握横向和纵向模糊匹配，就能解决很大部分正则匹配问题。 接下来的内容就是展开说了，如果对此都比较熟悉的话，可以跳过，直接看本章案例那节。 1.2 字符组 需要强调的是，虽叫字符组（字符类），但只是其中一个字符。例如 [abc]，表示匹配一个字符，它可以是 &quot;a&quot;、&quot;b&quot;、&quot;c&quot; 之一。 1.2.1 范围表示法 如果字符组里的字符特别多的话，怎么办？可以使用范围表示法。 比如 [123456abcdefGHIJKLM]，可以写成 [1-6a-fG-M]。用连字符 - 来省略和简写。 因为连字符有特殊用途，那么要匹配 &quot;a&quot;、&quot;-&quot;、&quot;z&quot; 这三者中任意一个字符，该怎么做呢？ 不能写成 [a-z]，因为其表示小写字符中的任何一个字符。 可以写成如下的方式：[-az] 或[az-] 或 [a\\-z]。即要么放在开头，要么放在结尾，要么转义。总之不会让引擎认为是范围表示法就行了。 1.2.2 排除字符组 纵向模糊匹配，还有一种情形就是，某位字符可以是任何东西，但就不能是 &quot;a&quot;、&quot;b&quot;、&quot;c&quot;。 此时就是排除字符组（反义字符组）的概念。例如 [^abc]，表示是一个除 &quot;a&quot;、&quot;b&quot;、&quot;c&quot; 之外的任意一个字符。字符组的第一位放 ^（脱字符），表示求反的概念。 当然，也有相应的范围表示法。 1.2.3 常见的简写形式 有了字符组的概念后，一些常见的符号我们也就理解了。因为它们都是系统自带的简写形式。 \\d 就是 [0-9]。表示是一位数字。记忆方式：其英文是 digit（数字）； \\D 就是 [^0-9]。表示除数字外的任意字符； \\w 就是 [0-9a-zA-Z_]。表示数字、大小写字母和下划线。记忆方式：w 是 word 的简写，也称单词字符； \\W 是 [^0-9a-zA-Z_]。非单词字符； \\s是 [ \\t\\v\\n\\r\\f]。表示空白符，包括空格、水平制表符、垂直制表符、换行符、回车符、换页符。记忆方式：s 是 space character 的首字母； \\S 是 [^ \\t\\v\\n\\r\\f]。 非空白符。 . 就是 [^\\n\\r\\u2028\\u2029]。通配符，表示几乎任意字符。换行符、回车符、行分隔符和段分隔符除外。记忆方式：想想省略号...中的每个点，都可以理解成占位符，表示任何类似的东西。 如果要匹配任意字符怎么办？可以使用 [\\d\\D]、[\\w\\W]、[\\s\\S] 和 [^] 中任何的一个。 1.3 量词 量词也称重复。掌握 {m,n} 的准确含义后，只需要记住一些简写形式。 1.3.1 简写形式 {m,} 表示至少出现 m 次。 {m} 等价于 {m,m}，表示出现 m 次。 ? 等价于 {0,1}，表示出现或者不出现。记忆方式：问号的意思表示，有吗？ + 等价于 {1,}，表示出现至少一次。记忆方式：加号是追加的意思，得先有一个，然后才考虑追加。 * 等价于 {0,}，表示出现任意次，有可能不出现。记忆方式：看看天上的星星，可能一颗没有，可能零散有几颗，可能数也数不过来。 1.3.2 贪婪匹配和惰性匹配 看如下的例子： const regex = /\\d{2,5}/g; const string = '123 1234 12345 123456'; console.log(string.match(regex)); // =&gt; [&quot;123&quot;, &quot;1234&quot;, &quot;12345&quot;, &quot;12345&quot;] 其中正则 /\\d{2,5}/，表示数字连续出现 2 到 5 次。会匹配 2 位、3 位、4 位、5 位连续数字。 但是其是贪婪的，它会尽可能多的匹配。你能给我 6 个，我就要 5 个。你能给我3个，我就要 3 个。反正只要在能力范围内，越多越好。 我们知道有时贪婪不是一件好事（请看文章最后一个例子）。而惰性匹配，就是尽可能少的匹配： const regex = /\\d{2,5}?/g; const string = '123 1234 12345 123456'; console.log(string.match(regex)); // =&gt; [&quot;12&quot;, &quot;12&quot;, &quot;34&quot;, &quot;12&quot;, &quot;34&quot;, &quot;12&quot;, &quot;34&quot;, &quot;56&quot;] 其中 /\\d{2,5}?/ 表示，虽然 2 到 5 次都行，当 2 个就够的时候，就不在往下尝试了。 通过在量词后面加个问号就能实现惰性匹配，因此所有惰性匹配情形如下： {m,n}? {m,}? ?? +? *? 1.4 多选分支 一个模式可以实现横向和纵向模糊匹配。而多选分支可以支持多个子模式任选其一。 具体形式如下：(p1|p2|p3)，其中 p1、p2 和 p3 是子模式，用 |（管道符）分隔，表示其中任何之一。 例如要匹配 &quot;good&quot; 和 &quot;nice&quot; 可以使用 /good|nice/。测试如下： const regex = /good|nice/g; const string = 'good idea, nice try.'; console.log(string.match(regex)); // =&gt; [&quot;good&quot;, &quot;nice&quot;] 但有个事实我们应该注意，比如我用 /good|goodbye/，去匹配 &quot;goodbye&quot; 字符串时，结果是 &quot;good&quot;： const regex = /good|goodbye/g; const string = 'goodbye'; console.log(string.match(regex)); // =&gt; [&quot;good&quot;] 而把正则改成 /goodbye|good/，结果是： var regex = /goodbye|good/g; var string = 'goodbye'; console.log(string.match(regex)); // =&gt; [&quot;goodbye&quot;] 也就是说，分支结构也是惰性的，即当前面的匹配上了，后面的就不再尝试了。 1.5 案例分析 匹配字符，无非就是字符组、量词和分支结构的组合使用罢了。 下面找几个例子演练一下（其中，每个正则并不是只有唯一写法）： 1.5.1 匹配 16 进制颜色值 要求匹配： #ffbbad #Fc01DF #FFF #ffE 分析： 表示一个 16 进制字符，可以用字符组 [0-9a-fA-F]。 其中字符可以出现 3 或 6 次，需要是用量词和分支结构。 使用分支结构时，需要注意顺序。 正则如下： const regex = /#([0-9a-fA-F]{6}|[0-9a-fA-F]{3})/g; const string = '#ffbbad #Fc01DF #FFF #ffE'; console.log(string.match(regex)); // =&gt; [&quot;#ffbbad&quot;, &quot;#Fc01DF&quot;, &quot;#FFF&quot;, &quot;#ffE&quot;] 1.5.2 匹配时间 以 24 小时制为例。 要求匹配： 23:59 02:07 分析： 共 4 位数字，第一位数字可以为 [0-2]； 当第 1 位为 2 时，第2位可以为 [0-3]，其他情况时，第 2 位为 [0-9]； 第 3 位数字为 [0-5]，第 4 位为 [0-9]。 正则如下： const regex = /^([01][0-9]|[2][0-3]):[0-5][0-9]$/; console.log(regex.test('23:59')); console.log(regex.test('02:07')); // =&gt; true // =&gt; true 如果也要求匹配 7:9，也就是说时分前面的 0 可以省略。 此时正则变成： const regex = /^(0?[0-9]|1[0-9]|[2][0-3]):(0?[0-9]|[1-5][0-9])$/; console.log( regex.test('23:59') ); console.log( regex.test('02:07') ); console.log( regex.test('7:9') ); // =&gt; true // =&gt; true // =&gt; true 1.5.3 匹配日期 比如 yyyy-mm-dd 格式为例。 要求匹配： 2017-06-10 分析： 年，四位数字即可，可用 [0-9]{4}； 月，共 12 个月，分两种情况 01、02、……、09 和 10、11、12，可用 (0[1-9]|1[0-2])； 日，最大 31 天，可用 (0[1-9]|[12][0-9]|3[01])。 正则如下： const regex = /^[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/; console.log(regex.test('2017-06-10')); // =&gt; true 1.5.4 Window 操作系统文件路径 要求匹配： F:\\study\\javascript\\regex\\regular expression.pdf F:\\study\\javascript\\regex\\ F:\\study\\javascript -F:\\ 分析： 整体模式是: 盘符:\\文件夹\\文件夹\\文件夹\\； 其中匹配 F:\\，需要使用[a-zA-Z]:\\\\，其中盘符不区分大小写，注意 \\ 字符需要转义； 文件名或者文件夹名，不能包含一些特殊字符，此时我们需要排除字符组 [^\\\\:*&lt;&gt;|&quot;?\\r\\n/] 来表示合法字符。另外不能为空名，至少有一个字符，也就是要使用量词 +。因此匹配 &quot;文件夹&quot;，可用[^\\\\:*&lt;&gt;|&quot;?\\r\\n/]+\\\\； 另外“文件夹\\”，可以出现任意次。也就是 ([^\\\\:*&lt;&gt;|&quot;?\\r\\n/]+\\\\)*。其中括号提供子表达式； 路径的最后一部分可以是“文件夹”，没有 \\，因此需要添加 ([^\\\\:*&lt;&gt;|&quot;?\\r\\n/]+)?。 最后拼接成了一个看起来比较复杂的正则： const regex = /^[a-zA-Z]:\\\\([^\\\\:*&lt;&gt;|&quot;?\\r\\n/]+\\\\)*([^\\\\:*&lt;&gt;|&quot;?\\r\\n/]+)?$/; console.log(regex.test('F:\\\\study\\\\javascript\\\\regex\\\\regular expression.pdf')); console.log(regex.test('F:\\\\study\\\\javascript\\\\regex\\\\')); console.log(regex.test('F:\\\\study\\\\javascript')); console.log(regex.test('F:\\\\')); // =&gt; true // =&gt; true // =&gt; true // =&gt; true 其中，JS 中字符串表示 \\ 时，也要转义。 1.5.5 匹配 id 要求从 &lt;div id=&quot;container&quot; class=&quot;main&quot;&gt;&lt;/div&gt; 提取出 id=&quot;container&quot;。 可能最开始想到的正则是： const regex = /id=&quot;.*&quot;/ const string = '&lt;div id=&quot;container&quot; class=&quot;main&quot;&gt;&lt;/div&gt;'; console.log(string.match(regex)[0]); // =&gt; id=&quot;container&quot; class=&quot;main&quot; 因为 . 是通配符，本身就匹配双引号的，而量词 * 又是贪婪的，当遇到 container 后面双引号时，不会停下来，会继续匹配，直到遇到最后一个双引号为止。 解决之道，可以使用惰性匹配： const regex = /id=&quot;.*?&quot;/ const string = '&lt;div id=&quot;container&quot; class=&quot;main&quot;&gt;&lt;/div&gt;'; console.log(string.match(regex)[0]); // =&gt; id=&quot;container&quot; 当然，这样也会有个问题。效率比较低，因为其匹配原理会涉及到“回溯”这个概念（这里也只是顺便提一下，第四章会详细说明）。可以优化如下： const regex = /id=&quot;[^&quot;]*&quot;/ const string = '&lt;div id=&quot;container&quot; class=&quot;main&quot;&gt;&lt;/div&gt;'; console.log(string.match(regex)[0]); // =&gt; id=&quot;container&quot; 第 1 章小结 字符匹配相关的案例，挺多的，不一而足。 掌握字符组和量词就能解决大部分常见的情形，也就是说，当你会了这二者，JS 正则算是入门了。 第 2 章 正则表达式位置匹配攻略 正则表达式是匹配模式，要么匹配字符，要么匹配位置。请记住这句话。 然而大部分人学习正则时，对于匹配位置的重视程度没有那么高。 本章讲讲正则匹配位置的总总。 内容包括： 什么是位置？ 如何匹配位置？ 位置的特性 几个应用实例分析 2.1 什么是位置呢？ 位置是相邻字符之间的位置。比如，下图中箭头所指的地方： 2.2. 如何匹配位置呢？ 在 ES5 中，共有 6 个锚字符：^ $ \\b \\B (?=p) (?!p)。 2.2.1 ^ 和 $ ^（脱字符）匹配开头，在多行匹配中匹配行开头； $（美元符号）匹配结尾，在多行匹配中匹配行结尾。 比如我们把字符串的开头和结尾用“#”替换（位置是可以替换成字符的！）： const result = 'hello'.replace(/^|$/g, '#'); console.log(result); // =&gt; &quot;#hello#&quot; 多行匹配模式时，二者是行的概念，这个需要我们的注意： const result = 'I\\nlove\\njavascript'.replace(/^|$/gm, '#'); console.log(result); /* #I# #love# #javascript# */ 2.2.2 \\b 和 \\B \\b 是单词边界，具体就是 \\w 和 \\W 之间的位置，也包括 \\w 和 ^ 之间的位置，也包括 \\w和 $ 之间的位置。 比如一个文件名是 &quot;[JS] Lesson_01.mp4&quot; 中的 \\b，如下： const result = '[JS] Lesson_01.mp4'.replace(/\\b/g, '#'); console.log(result); // =&gt; &quot;[#JS#] #Lesson_01#.#mp4#&quot; 为什么是这样呢？这需要仔细看看。 首先，我们知道，\\w 是字符组 [0-9a-zA-Z_] 的简写形式，即 \\w 是字母数字或者下划线的中任何一个字符。而 \\W 是排除字符组 [^0-9a-zA-Z_] 的简写形式，即 \\W 是 \\w 以外的任何一个字符。此时我们可以看看 &quot;[#JS#] #Lesson_01#.#mp4#&quot; 中的每一个 &quot;#&quot;，是怎么来的。 第一个&quot;#&quot;，两边是 &quot;[&quot;与 &quot;J&quot;，是 \\W 和 \\w 之间的位置； 第二个&quot;#&quot;，两边是 &quot;S&quot; 与 &quot;]&quot;，也就是 \\w 和 \\W 之间的位置； 第三个&quot;#&quot;，两边是空格与 &quot;L&quot;，也就是 \\W 和 \\w 之间的位置； 第四个&quot;#&quot;，两边是 &quot;1&quot; 与 &quot;.&quot;，也就是 \\w 和 \\W 之间的位置； 第五个&quot;#&quot;，两边是 &quot;.&quot;与 &quot;m&quot;，也就是 \\W 和 \\w 之间的位置； 第六个&quot;#&quot;，其对应的位置是结尾，但其前面的字符 &quot;4&quot; 是 \\w，即 \\w 和 $ 之间的位置。 知道了 \\b 的概念后，那么 \\B 也就相对好理解了。 \\B 就是 \\b 的反面的意思，非单词边界。例如在字符串中所有位置中，扣掉 \\b，剩下的都是 \\B 的。 具体说来就是 \\w 与 \\w、\\W 与 \\W、^ 与 \\W，\\W 与 $ 之间的位置。 比如上面的例子，把所有 \\B 替换成 &quot;#&quot;： const result = '[JS] Lesson_01.mp4'.replace(/\\B/g, '#'); console.log(result); // =&gt; &quot;#[J#S]# L#e#s#s#o#n#_#0#1.m#p#4&quot; 2.2.3 (?=p) 和 (?!p) (?=p)，其中 p 是一个子模式，即 p 前面的位置。 比如 (?=l)，表示 &quot;l&quot; 字符前面的位置，例如： const result = 'hello'.replace(/(?=l)/g, '#'); console.log(result); // =&gt; &quot;he#l#lo&quot; 而 (?!p) 就是 (?=p) 的反面意思，比如： const result = 'hello'.replace(/(?!l)/g, '#'); console.log(result); // =&gt; &quot;#h#ell#o#&quot; 二者的学名分别是 positive lookahead 和 negative lookahead。 中文翻译分别是正向先行断言和负向先行断言。 ES6中，还支持 positive lookbehind 和 negative lookbehind。 具体是 (?&lt;=p) 和 (?&lt;!p)。 也有书上把这四个东西，翻译成环视，即看看右边或看看左边。 但一般书上，没有很好强调这四者是个位置。 比如 (?=p)，一般都理解成：要求接下来的字符与 p 匹配，但不能包括 p 的那些字符。 而在本人看来 (?=p) 就与 ^ 一样好理解，就是 p 前面的那个位置。 2.3. 位置的特性 对于位置的理解，我们可以理解成空字符&quot;&quot;。 比如 &quot;hello&quot; 字符串等价于如下的形式： 'hello' == '' + 'h' + '' + 'e' + '' + 'l' + '' + 'l' + 'o' + ''; 也等价于： 'hello' == '' + '' + 'hello'; 因此，把 /^hello$/ 写成 /^^hello$$$/，是没有任何问题的： const result = /^^hello$$$/.test('hello'); console.log(result); // =&gt; true 甚至可以写成更复杂的： const result = /(?=he)^^he(?=\\w)llo$\\b\\b$/.test('hello'); console.log(result); // =&gt; true 也就是说字符之间的位置，可以写成多个。 把位置理解空字符，是对位置非常有效的理解方式。 2.4 相关案例 2.4.1 不匹配任何东西的正则 让你写个正则不匹配任何东西 easy，/.^/ 因为此正则要求只有一个字符，但该字符后面是开头。 2.4.2 数字的千位分隔符表示法 比如把 &quot;12345678&quot;，变成 &quot;12,345,678&quot;。 可见是需要把相应的位置替换成 &quot;,&quot;。 思路是什么呢？ 2.4.2.1 弄出最后一个逗号 使用 (?=\\d{3}$) 就可以做到： const result = '12345678'.replace(/(?=\\d{3}$)/g, ',') console.log(result); // =&gt; &quot;12345,678&quot; 2.4.2.2 弄出所有的逗号 因为逗号出现的位置，要求后面 3 个数字一组，也就是 \\d{3} 至少出现一次。 此时可以使用量词 +： const result = '12345678'.replace(/(?=(\\d{3})+$)/g, ',') console.log(result); // =&gt; &quot;12,345,678&quot; 2.4.2.3 匹配其余案例 写完正则后，要多验证几个案例，此时我们会发现问题： const result = '123456789'.replace(/(?=(\\d{3})+$)/g, ',') console.log(result); // =&gt; &quot;,123,456,789&quot; 因为上面的正则，仅仅表示把从结尾向前数，一但是 3 的倍数，就把其前面的位置替换成逗号。因此才会出现这个问题。 怎么解决呢？我们要求匹配的到这个位置不能是开头。 我们知道匹配开头可以使用 ^，但要求这个位置不是开头怎么办？easy，(?!^)，你想到了吗？测试如下： const string1 = '12345678'; const string2 = '123456789'; const reg = /(?!^)(?=(\\d{3})+$)/g; const result = string1.replace(reg, ',') console.log(result); // =&gt; &quot;12,345,678&quot; result = string2.replace(reg, ','); console.log(result); // =&gt; &quot;123,456,789&quot; 2.4.2.4 支持其他形式 如果要把 &quot;12345678 123456789&quot; 替换成 &quot;12,345,678 123,456,789&quot;。 此时我们需要修改正则，把里面的开头 ^ 和结尾 $，替换成 \\b： const string = '12345678 123456789'; const reg = /(?!\\b)(?=(\\d{3})+\\b)/g; const result = string.replace(reg, ','); console.log(result); // =&gt; &quot;12,345,678 123,456,789&quot; 其中 (?!\\b) 怎么理解呢？ 要求当前是一个位置，但不是 \\b 前面的位置，其实 (?!\\b) 说的就是 \\B。 因此最终正则变成了：/\\B(?=(\\d{3})+\\b)/g。 2.4.3 验证密码问题 密码长度 6-12 位，由数字、小写字符和大写字母组成，但必须至少包括 2 种字符。 此题，如果写成多个正则来判断，比较容易。但要写成一个正则就比较困难。 那么，我们就来挑战一下。看看我们对位置的理解是否深刻。 2.4.3.1 简化 不考虑“但必须至少包括 2 种字符”这一条件。我们可以容易写出： const reg = /^[0-9A-Za-z]{6,12}$/; 2.4.3.2 判断是否包含有某一种字符 假设，要求的必须包含数字，怎么办？此时我们可以使用 (?=.*[0-9]) 来做。 因此正则变成： const reg = /(?=.*[0-9])^[0-9A-Za-z]{6,12}$/; 2.4.3.3 同时包含具体两种字符 比如同时包含数字和小写字母，可以用 (?=.*[0-9])(?=.*[a-z]) 来做。 因此正则变成： const reg = /(?=.*[0-9])(?=.*[a-z])^[0-9A-Za-z]{6,12}$/; 2.4.3.4 解答 我们可以把原题变成下列几种情况之一： 同时包含数字和小写字母； 同时包含数字和大写字母； 同时包含小写字母和大写字母； 同时包含数字、小写字母和大写字母。 以上的 4 种情况是或的关系（实际上，可以不用第 4 条）。 最终答案是： const reg = /((?=.*[0-9])(?=.*[a-z])|(?=.*[0-9])(?=.*[A-Z])|(?=.*[a-z])(?=.*[A-Z]))^[0-9A-Za-z]{6,12}$/; console.log(reg.test('1234567')); // false 全是数字 console.log(reg.test('abcdef')); // false 全是小写字母 console.log(reg.test('ABCDEFGH')); // false 全是大写字母 console.log(reg.test('ab23C')); // false 不足 6 位 console.log(reg.test('ABCDEF234')); // true 大写字母和数字 console.log(reg.test('abcdEF234')); // true 三者都有 2.4.3.5 解惑 上面的正则看起来比较复杂，只要理解了第二步，其余就全部理解了。 /(?=.*[0-9])^[0-9A-Za-z]{6,12}$/ 对于这个正则，我们只需要弄明白 (?=.*[0-9])^即可。 分开来看就是 (?=.*[0-9]) 和 ^。 表示开头前面还有个位置（当然也是开头，即同一个位置，想想之前的空字符类比）。 (?=.*[0-9]) 表示该位置后面的字符匹配 .*[0-9]，即，有任何多个任意字符，后面再跟个数字。 翻译成大白话，就是接下来的字符，必须包含个数字。 2.4.3.6 另外一种解法 “至少包含两种字符”的意思就是说，不能全部都是数字，也不能全部都是小写字母，也不能全部都是大写字母。 那么要求“不能全部都是数字”，怎么做呢？(?!p) 出马！ 对应的正则是： const reg = /(?!^[0-9]{6,12}$)^[0-9A-Za-z]{6,12}$/; 三种“都不能”呢？ 最终答案是： const reg = /(?!^[0-9]{6,12}$)(?!^[a-z]{6,12}$)(?!^[A-Z]{6,12}$)^[0-9A-Za-z]{6,12}$/; console.log(reg.test('1234567')); // false 全是数字 console.log(reg.test('abcdef')); // false 全是小写字母 console.log(reg.test('ABCDEFGH')); // false 全是大写字母 console.log(reg.test('ab23C')); // false 不足 6 位 console.log(reg.test('ABCDEF234')); // true 大写字母和数字 console.log(reg.test('abcdEF234')); // true 三者都有 第 2 章小结 位置匹配相关的案例，挺多的，不一而足。 掌握匹配位置的这 6 个锚字符，给我们解决正则问题一个新工具。 第 3 章 正则表达式括号的作用 不管哪门语言中都有括号。正则表达式也是一门语言，而括号的存在使这门语言更为强大。 对括号的使用是否得心应手，是衡量对正则的掌握水平的一个侧面标准。 括号的作用，其实三言两语就能说明白，括号提供了分组，便于我们引用它。 引用某个分组，会有两种情形：在 JavaScript 里引用它，在正则表达式里引用它。 本章内容虽相对简单，但我也要写长点。内容包括： 分组和分支结构 引用分组 反向引用 非捕获分组 相关案例 3.1 分组和分支结构 这二者是括号最直觉的作用，也是最原始的功能。 3.1.1 分组 我们知道 /a+/ 匹配连续出现的 &quot;a&quot;，而要匹配连续出现的 &quot;ab&quot; 时，需要使用 /(ab)+/。 其中括号是提供分组功能，使量词 + 作用于 &quot;ab&quot; 这个整体，测试如下： const regex = /(ab)+/g; const string = 'ababa abbb ababab'; console.log(string.match(regex)); // =&gt; [&quot;abab&quot;, &quot;ab&quot;, &quot;ababab&quot;] 3.1.2 分支结构 而在多选分支结构 (p1|p2) 中，此处括号的作用也是不言而喻的，提供了子表达式的所有可能。 比如，要匹配如下的字符串： I love JavaScript I love Regular Expression 可以使用正则： const regex = /^I love (JavaScript|Regular Expression)$/; console.log(regex.test('I love JavaScript')); console.log(regex.test('I love Regular Expression')); // =&gt; true // =&gt; true 如果去掉正则中的括号，即 /^I love JavaScript|Regular Expression$/，匹配字符串是 &quot;I love JavaScript&quot; 和 &quot;Regular Expression&quot;，当然这不是我们想要的。 3.2 引用分组 这是括号一个重要的作用，有了它，我们就可以进行数据提取，以及更强大的替换操作。 而要使用它带来的好处，必须配合使用实现环境的 API。 以日期为例。假设格式是 yyyy-mm-dd 的，我们可以先写一个简单的正则： const regex = /\\d{4}-\\d{2}-\\d{2}/; 然后再修改成括号版的： const regex = /(\\d{4})-(\\d{2})-(\\d{2})/; 为什么要使用这个正则呢？ 3.2.1 提取数据 比如提取出年、月、日，可以这么做： const regex = /(\\d{4})-(\\d{2})-(\\d{2})/; const string = '2017-06-12'; console.log(string.match(regex)); // =&gt; [&quot;2017-06-12&quot;, &quot;2017&quot;, &quot;06&quot;, &quot;12&quot;, index: 0, input: &quot;2017-06-12&quot;] match 返回的一个数组，第一个元素是整体匹配结果，然后是各个分组（括号里）匹配的内容，然后是匹配下标，最后是输入的文本。（注意：如果正则是否有修饰符 g，match 返回的数组格式是不一样的）。 另外也可以使用正则对象的 exec 方法： const regex = /(\\d{4})-(\\d{2})-(\\d{2})/; const string = '2017-06-12'; console.log(regex.exec(string)); // =&gt; [&quot;2017-06-12&quot;, &quot;2017&quot;, &quot;06&quot;, &quot;12&quot;, index: 0, input: &quot;2017-06-12&quot;] 同时，也可以使用构造函数的全局属性 $1 至 $9 来获取： const regex = /(\\d{4})-(\\d{2})-(\\d{2})/; const string = '2017-06-12'; regex.test(string); // 正则操作即可，例如 //regex.exec(string); //string.match(regex); console.log(RegExp.$1); // &quot;2017&quot; console.log(RegExp.$2); // &quot;06&quot; console.log(RegExp.$3); // &quot;12&quot; 3.2.2 替换数据 比如，想把 yyyy-mm-dd 格式，替换成 mm/dd/yyyy 怎么做？ const regex = /(\\d{4})-(\\d{2})-(\\d{2})/; const string = '2017-06-12'; const result = string.replace(regex, '$2/$3/$1'); console.log(result); // =&gt; &quot;06/12/2017&quot; 其中 replace 中的，第二个参数里用 $1、$2、$3 指代相应的分组。等价于如下的形式： const regex = /(\\d{4})-(\\d{2})-(\\d{2})/; const string = '2017-06-12'; const result = string.replace(regex, function() { return RegExp.$2 + '/' + RegExp.$3 + '/' + RegExp.$1; }); console.log(result); // =&gt; &quot;06/12/2017&quot; 也等价于： const regex = /(\\d{4})-(\\d{2})-(\\d{2})/; const string = '2017-06-12'; const result = string.replace(regex, function(match, year, month, day) { return month + '/' + day + '/' + year; }); console.log(result); // =&gt; &quot;06/12/2017&quot; 3.3 反向引用 除了使用相应 API 来引用分组，也可以在正则本身里引用分组。但只能引用之前出现的分组，即反向引用。 还是以日期为例。 比如要写一个正则支持匹配如下三种格式： 2016-06-12 2016/06/12 2016.06.12 最先可能想到的正则是： const regex = /\\d{4}(-|\\/|\\.)\\d{2}(-|\\/|\\.)\\d{2}/; const string1 = '2017-06-12'; const string2 = '2017/06/12'; const string3 = '2017.06.12'; const string4 = '2016-06/12'; console.log(regex.test(string1)); // true console.log(regex.test(string2)); // true console.log(regex.test(string3)); // true console.log(regex.test(string4)); // true 其中 / 和 . 需要转义。虽然匹配了要求的情况，但也匹配 &quot;2016-06/12&quot; 这样的数据。 假设我们想要求分割符前后一致怎么办？此时需要使用反向引用： const regex = /\\d{4}(-|\\/|\\.)\\d{2}\\1\\d{2}/; const string1 = '2017-06-12'; const string2 = '2017/06/12'; const string3 = '2017.06.12'; const string4 = '2016-06/12'; console.log(regex.test(string1)); // true console.log(regex.test(string2)); // true console.log(regex.test(string3)); // true console.log(regex.test(string4)); // false 注意里面的 \\1，表示的引用之前的那个分组 (-|\\/|\\.)。不管它匹配到什么（比如 -），\\1 都匹配那个同样的具体某个字符。 我们知道了 \\1 的含义后，那么 \\2 和 \\3 的概念也就理解了，即分别指代第二个和第三个分组。 看到这里，此时，恐怕你会有三个问题。 3.3.1 括号嵌套怎么办？ 以左括号（开括号）为准。比如： const regex = /^((\\d)(\\d(\\d)))\\1\\2\\3\\4$/; const string = '1231231233'; console.log(regex.test(string)); // true console.log(RegExp.$1); // 123 console.log(RegExp.$2 ); // 1 console.log(RegExp.$3); // 23 console.log(RegExp.$4); // 3 我们可以看看这个正则匹配模式： 第一个字符是数字，比如说 1， 第二个字符是数字，比如说 2， 第三个字符是数字，比如说 3， 接下来的是 \\1，是第一个分组内容，那么看第一个开括号对应的分组是什么，是 123， 接下来的是 \\2，找到第 2 个开括号，对应的分组，匹配的内容是 1， 接下来的是 \\3，找到第 3 个开括号，对应的分组，匹配的内容是 23， 最后的是 \\4，找到第 3 个开括号，对应的分组，匹配的内容是 3。 这个问题，估计仔细看一下，就该明白了。 3.3.2 \\10 表示什么呢？ 另外一个疑问可能是，即 \\10 是表示第 10 个分组，还是 \\1 和 0 呢？ 答案是前者，虽然一个正则里出现 \\10 比较罕见。测试如下： const regex = /(1)(2)(3)(4)(5)(6)(7)(8)(9)(#) \\10+/; const string = '123456789# ######'; console.log(regex.test(string)); // =&gt; true 3.3.3 引用不存在的分组会怎样？ 因为反向引用，是引用前面的分组，但我们在正则里引用了不存在的分组时，此时正则不会报错，只是匹配反向引用的字符本身。例如 \\2，就匹配“\\2”。注意“\\2”表示对“2”进行了转意。 const regex = /\\1\\2\\3\\4\\5\\6\\7\\8\\9/; console.log(regex.test('\\1\\2\\3\\4\\5\\6\\7\\8\\9')); console.log('\\1\\2\\3\\4\\5\\6\\7\\8\\9'.split('')); Chrome 浏览器打印的结果： Node 打印的结果： 4. 非捕获分组 之前文中出现的分组，都会捕获它们匹配到的数据，以便后续引用，因此也称他们是捕获型分组。 如果只想要括号最原始的功能，但不会引用它，即，既不在 API 里引用，也不在正则里反向引用。此时可以使用非捕获分组 (?:p)，例如本文第一个例子可以修改为： const regex = /(?:ab)+/g; const string = 'ababa abbb ababab'; console.log(string.match(regex)); // =&gt; [&quot;abab&quot;, &quot;ab&quot;, &quot;ababab&quot;] 3.5 相关案例 至此括号的作用已经讲完了，总结一句话，就是提供了可供我们使用的分组，如何用就看我们的了。 3.5.1 字符串 trim 方法模拟 trim 方法是去掉字符串的开头和结尾的空白符。有两种思路去做。 第一种，匹配到开头和结尾的空白符，然后替换成空字符。如： function trim(str) { return str.replace(/^\\s+|\\s+$/g, ''); } console.log(trim(' foobar ')); // =&gt; &quot;foobar&quot; 第二种，匹配整个字符串，然后用引用来提取出相应的数据： function trim(str) { return str.replace(/^\\s*(.*?)\\s*$/g, '$1'); } console.log(trim(' foobar ')); // =&gt; &quot;foobar&quot; 这里使用了惰性匹配 *?，不然也会匹配最后一个空格之前的所有空格的。 当然，前者效率高。 3.5.2 将每个单词的首字母转换为大写 function titleize(str) { return str.toLowerCase().replace(/(?:^|\\s)\\w/g, function(c) { return c.toUpperCase(); }); } console.log(titleize('my name is epeli')); // =&gt; &quot;My Name Is Epeli&quot; 思路是找到每个单词的首字母，当然这里不使用非捕获匹配也是可以的。 3.5.3 驼峰化 function camelize(str) { return str.replace(/[-_\\s]+(.)?/g, function(match, c) { return c ? c.toUpperCase() : ''; }); } console.log(camelize('-moz-transform')); // =&gt; &quot;MozTransform&quot; 其中分组 (.) 表示首字母。单词的界定是，前面的字符可以是多个连字符、下划线以及空白符。正则后面的 ? 的目的，是为了应对 str 尾部的字符可能不是单词字符，比如 str 是'-moz-transform'。 3.5.4 中划线化 function dasherize(str) { return str.replace(/([A-Z])/g, '-$1').replace(/[-_\\s]+/g, '-').toLowerCase(); } console.log(dasherize('MozTransform')); // =&gt; &quot;-moz-transform&quot; 驼峰化的逆过程。 3.5.5 html 转义和反转义 // 将HTML特殊字符转换成等值的实体 function escapeHTML(str) { var escapeChars = { '¢' : 'cent', '£' : 'pound', '¥' : 'yen', '€': 'euro', '©' :'copy', '®' : 'reg', '&lt;' : 'lt', '&gt;' : 'gt', '&quot;' : 'quot', '&amp;' : 'amp', '\\'' : '#39' }; return str.replace(new RegExp('[' + Object.keys(escapeChars).join('') +']', 'g'), function(match) { return '&amp;' + escapeChars[match] + ';'; }); } console.log(escapeHTML('&lt;div&gt;Blah blah blah&lt;/div&gt;')); // =&gt; &quot;&amp;lt;div&amp;gt;Blah blah blah&amp;lt;/div&amp;gt&quot;; 其中使用了用构造函数生成的正则，然后替换相应的格式就行了，这个跟本章没多大关系。 倒是它的逆过程，使用了括号，以便提供引用，也很简单，如下： // 实体字符转换为等值的HTML。 function unescapeHTML(str) { var htmlEntities = { nbsp: ' ', cent: '¢', pound: '£', yen: '¥', euro: '€', copy: '©', reg: '®', lt: '&lt;', gt: '&gt;', quot: '&quot;', amp: '&amp;', apos: '\\'' }; return str.replace(/\\&amp;([^;]+);/g, function(match, key) { if (key in htmlEntities) { return htmlEntities[key]; } return match; }); } console.log(unescapeHTML('&amp;lt;div&amp;gt;Blah blah blah&amp;lt;/div&amp;gt;')); // =&gt; &quot;&lt;div&gt;Blah blah blah&lt;/div&gt;&quot; 通过 key 获取相应的分组引用，然后作为对象的键。 3.5.6 匹配成对标签 要求匹配： &lt;title&gt;regular expression&lt;/title&gt; &lt;p&gt;laoyao bye bye&lt;/p&gt; 不匹配： &lt;title&gt;wrong!&lt;/p&gt; 匹配一个开标签，可以使用正则 &lt;[^&gt;]+&gt;， 匹配一个闭标签，可以使用 &lt;\\/[^&gt;]+&gt;， 但是要求匹配成对标签，那就需要使用反向引用，如： const regex = /&lt;([^&gt;]+)&gt;[\\d\\D]*&lt;\\/\\1&gt;/; const string1 = '&lt;title&gt;regular expression&lt;/title&gt;'; const string2 = '&lt;p&gt;laoyao bye bye&lt;/p&gt;'; const string3 = '&lt;title&gt;wrong!&lt;/p&gt;'; console.log(regex.test(string1)); // true console.log(regex.test(string2)); // true console.log(regex.test(string3)); // false 其中开标签 &lt;[^&gt;]+&gt; 改成 &lt;([^&gt;]+)&gt;，使用括号的目的是为了后面使用反向引用，而提供分组。闭标签使用了反向引用，&lt;\\/\\1&gt;。 另外 [\\d\\D] 的意思是，这个字符是数字或者不是数字，因此，也就是匹配任意字符的意思。 第 3 章小结 正则中使用括号的例子那可是太多了，不一而足。 重点理解括号可以提供分组，我们可以提取数据，应该就可以了。 例子中的代码，基本没做多少分析，相信你都能看懂的。 第 4 章 正则表达式回溯法原理 学习正则表达式，是需要懂点儿匹配原理的。 而研究匹配原理时，有两个字出现的频率比较高：“回溯”。 听起来挺高大上，确实还有很多人对此不明不白的。 因此，本章就简单扼要地说清楚回溯到底是什么东西。 内容包括： 没有回溯的匹配 有回溯的匹配 常见的回溯形式 4.1 没有回溯的匹配 假设我们的正则是 /ab{1,3}c/，其可视化形式是： 而当目标字符串是 &quot;abbbc&quot; 时，就没有所谓的“回溯”。其匹配过程是： 其中子表达式 b{1,3} 表示 &quot;b&quot;字符连续出现 1 到 3 次。 4.2 有回溯的匹配 如果目标字符串是 &quot;abbc&quot;，中间就有回溯。 图中第 5 步有红颜色，表示匹配不成功。此时 b{1,3} 已经匹配到了 2 个字符 &quot;b&quot;，准备尝试第三个时，结果发现接下来的字符是 &quot;c&quot;。那么就认为 b{1,3} 就已经匹配完毕。然后状态又回到之前的状态（即第 6 步，与第 4 步一样），最后再用子表达式 c，去匹配字符 &quot;c&quot;。当然，此时整个表达式匹配成功了。 图中的第 6 步，就是“回溯”。 你可能对此没有感觉，这里我们再举一个例子。正则是： 目标字符串是 &quot;abbbc&quot;，匹配过程是： 其中第 7 步和第 10 步是回溯。第 7 步与第 4 步一样，此时 b{1,3} 匹配了两个 &quot;b&quot;，而第 10 步与第 3 步一样，此时 b{1,3} 只匹配了一个 &quot;b&quot;，这也是 b{1,3} 的最终匹配结果。 这里再看一个清晰的回溯，正则是： 目标字符串是：&quot;acd&quot;ef，匹配过程是： 图中省略了尝试匹配双引号失败的过程。可以看出 .* 是非常影响效率的。 为了减少一些不必要的回溯，可以把正则修改为 /&quot;[^&quot;]*&quot;/。 4.3 常见的回溯形式 正则表达式匹配字符串的这种方式，有个学名，叫回溯法。 回溯法也称试探法，它的基本思想是：从问题的某一种状态（初始状态）出发，搜索从这种状态出发所能达到的所有“状态”，当一条路走到“尽头”的时候（不能再前进），再后退一步或若干步，从另一种可能“状态”出发，继续搜索，直到所有的“路径”（状态）都试探过。这种不断“前进”、不断“回溯”寻找解的方法，就称作“回溯法”。（来自百度百科）。 本质上就是深度优先搜索算法。其中退到之前的某一步这一过程，我们称为“回溯”。从上面的描述过程中，可以看出，路走不通时，就会发生“回溯”。即，尝试匹配失败时，接下来的一步通常就是回溯。 道理，我们是懂了。那么 JS 中正则表达式会产生回溯的地方都有哪些呢？ 4.3.1 贪婪量词 之前的例子都是贪婪量词相关的。比如 b{1,3}，因为其是贪婪的，尝试可能的顺序是从多往少的方向去尝试。首先会尝试 &quot;bbb&quot;，然后再看整个正则是否能匹配。不能匹配时，吐出一个 &quot;b&quot;，即在 &quot;bb&quot; 的基础上，再继续尝试。如果还不行，再吐出一个，再试。如果还不行呢？只能说明匹配失败了。 虽然局部匹配是贪婪的，但也要满足整体能正确匹配。否则，皮之不存，毛将焉附？ 此时我们不禁会问，如果当多个贪婪量词挨着存在，并相互有冲突时，此时会是怎样？ 答案是，先下手为强！因为深度优先搜索。测试如下： const string = '12345'; const regex = /(\\d{1,3})(\\d{1,3})/; console.log(string.match(regex)); // =&gt; [&quot;12345&quot;, &quot;123&quot;, &quot;45&quot;, index: 0, input: &quot;12345&quot;] 其中，前面的 \\d{1,3} 匹配的是 &quot;123&quot;，后面的 \\d{1,3} 匹配的是 &quot;45&quot;。 4.3.2 惰性量词 惰性量词就是在贪婪量词后面加个问号。表示尽可能少的匹配，比如： const string = '12345'; const regex = /(\\d{1,3}?)(\\d{1,3})/; console.log(string.match(regex)); // =&gt; [&quot;1234&quot;, &quot;1&quot;, &quot;234&quot;, index: 0, input: &quot;12345&quot;] 其中 \\d{1,3}? 只匹配到一个字符 &quot;1&quot;，而后面的 \\d{1,3} 匹配了 &quot;234&quot;。 虽然惰性量词不贪，但也会有回溯的现象。比如正则是： 目标字符串是 &quot;12345&quot;，匹配过程是： 知道你不贪、很知足，但是为了整体匹配成，没办法，也只能给你多塞点了。因此最后 \\d{1,3}? 匹配的字符是 &quot;12&quot;，是两个数字，而不是一个。 4.3.3 分支结构 我们知道分支也是惰性的，比如/can|candy/，去匹配字符串&quot;candy&quot;，得到的结果是&quot;can&quot;，因为分支会一个一个尝试，如果前面的满足了，后面就不会再试验了。 分支结构，可能前面的子模式会形成了局部匹配，如果接下来表达式整体不匹配时，仍会继续尝试剩下的分支。这种尝试也可以看成一种回溯。 比如正则： 目标字符串是 &quot;candy&quot;，匹配过程： 上面第 5 步，虽然没有回到之前的状态，但仍然回到了分支结构，尝试下一种可能。所以，可以认为它是一种回溯的。 第 4 章小结 其实回溯法，很容易掌握的。 简单总结就是，正因为有多种可能，所以要一个一个试。直到，要么到某一步时，整体匹配成功了；要么最后都试完后，发现整体匹配不成功。 贪婪量词“试”的策略是：买衣服砍价。价钱太高了，便宜点，不行，再便宜点。 惰性量词“试”的策略是：卖东西加价。给少了，再多给点行不，还有点少啊，再给点。 分支结构“试”的策略是：货比三家。这家不行，换一家吧，还不行，再换。 既然有回溯的过程，那么匹配效率肯定低一些。相对谁呢？相对那些 DFA 引擎。 而 JS 的正则引擎是 NFA，NFA 是“非确定型有限自动机”的简写。 大部分语言中的正则都是 NFA，为啥它这么流行呢？ 答：你别看我匹配慢，但是我编译快啊，而且我还有趣哦。 第 5 章 正则表达式的拆分 对于一门语言的掌握程度怎么样，可以有两个角度来衡量：读和写。 不仅要求自己能解决问题，还要看懂别人的解决方案。代码是这样，正则表达式也是这样。 正则这门语言跟其他语言有一点不同，它通常就是一大堆字符，而没有所谓“语句”的概念。 如何能正确地把一大串正则拆分成一块一块的，成为了破解“天书”的关键。 本章就解决这一问题，内容包括： 结构和操作符 注意要点 案例分析 5.1 结构和操作符 编程语言一般都有操作符。只要有操作符，就会出现一个问题。当一大堆操作在一起时，先操作谁，又后操作谁呢？为了不产生歧义，就需要语言本身定义好操作顺序，即所谓的优先级。 而在正则表达式中，操作符都体现在结构中，即由特殊字符和普通字符所代表的一个个特殊整体。 JS 正则表达式中，都有哪些结构呢？ 字符字面量，匹配一个具体字符，包括不用转义的和需要转义的。比如 a 匹配字符 &quot;a&quot;，又比如 \\n 匹配换行符，又比如 \\. 匹配小数点。 字符组，匹配一个字符，可以是多种可能之一，比如 [0-9]，表示匹配一个数字。也有 \\d 的简写形式。另外还有反义字符组，表示可以是除了特定字符之外任何一个字符，比如 [^0-9]，表示一个非数字字符，也有 \\D的简写形式。 量词，表示一个字符连续出现，比如 a{1,3}表示 &quot;a&quot; 字符连续出现 3 次。另外还有常见的简写形式，比如 a+ 表示 &quot;a&quot; 字符连续出现至少一次。 锚字符，匹配一个位置，而不是字符。比如 ^ 匹配字符串的开头，又比如 \\b 匹配单词边界，又比如 (?=\\d) 表示数字前面的位置。 分组，用括号表示一个整体，比如 (ab)+，表示 &quot;ab&quot; 两个字符连续出现多次，也可以使用非捕获分组 (?:ab)+。 选择分支，多个子表达式多选一，比如 abc|bcd，表达式匹配 &quot;abc&quot; 或者 &quot;bcd&quot; 字符子串。 反向引用，比如 \\2，表示引用第 2 个分组。 其中涉及到的操作符有： 转义符 \\ 括号和方括号 (...)、(?:...)、(?=...)、(?!...)、[...] 量词限定符 {m}、{m,n}、{m,}、?、*、+ 位置和序列 ^、$、\\ 元字符、 一般字符 管道符（竖杠）| 上面操作符的优先级从上至下，由高到低。这里，我们来分析一个正则：/ab?(c|de*)+|fg/： 由于括号的存在，所以，(c|de*) 是一个整体结构。 在 (c|de*) 中，注意其中的量词 *，因此 e* 是一个整体结构。 又因为分支结构 | 优先级最低，因此 c 是一个整体、而 de* 是另一个整体。 同理，整个正则分成了 a、b?、(...)+、f、g。而由于分支的原因，又可以分成 ab?(c|de*)+ 和 fg 这两部分。 希望你没被我绕晕，上面的分析可用其可视化形式描述如下： 5.2 注意要点 关于结构和操作符，还是有几点需要强调： 2.1 匹配字符串整体问题 因为是要匹配整个字符串，我们经常会在正则前后中加上锚字符 ^ 和 $。 比如要匹配目标字符串 &quot;abc&quot; 或者 &quot;bcd&quot; 时，如果一不小心，就会写成 /^abc|bcd$/。 而位置字符和字符序列优先级要比竖杠高，故其匹配的结构是： 应该修改成： 5.2.2 量词连缀问题 假设，要匹配这样的字符串： 每个字符为a、b、c任选其一； 字符串的长度是 3 的倍数。 此时正则不能想当然地写成 /^[abc]{3}+$/，这样会报错，说 + 前面没什么可重复的： 此时要修改成： 5.2.3 元字符转义问题 所谓元字符，就是正则中有特殊含义的字符。 所有结构里，用到的元字符总结如下：^ $ . * + ? | \\ / ( ) [ ] { } = ! : - ,。 当匹配上面的字符本身时，可以一律转义： const string = '^$.*+?|\\\\/[]{}=!:-,'; const regex = /\\^\\$\\.\\*\\+\\?\\|\\\\\\/\\[\\]\\{\\}\\=\\!\\:\\-\\,/; console.log(regex.test(string)); // =&gt; true 其中 string 中的 \\ 字符也要转义的。 另外，在 string 中，也可以把每个字符转义，当然，转义后的结果仍是本身： const string = '^$.*+?|\\\\/[]{}=!:-,'; const string2 = '\\^\\$\\.\\*\\+\\?\\|\\\\\\/\\[\\]\\{\\}\\=\\!\\:\\-\\,'; console.log(string == string2); // =&gt; true 现在的问题是，是不是每个字符都需要转义呢？否，看情况。 5.2.3.1 字符组中的元字符 跟字符组相关的元字符有 []、^、-。因此在会引起歧义的地方进行转义。例如开头的 ^ 必须转义，不然会把整个字符组，看成反义字符组。 const string = '^$.*+?|\\\\/[]{}=!:-,'; const regex = /[\\^$.*+?|\\\\/\\[\\]{}=!:\\-,]/g; console.log(string.match(regex)); // =&gt; [&quot;^&quot;, &quot;$&quot;, &quot;.&quot;, &quot;*&quot;, &quot;+&quot;, &quot;?&quot;, &quot;|&quot;, &quot;\\&quot;, &quot;/&quot;, &quot;[&quot;, &quot;]&quot;, &quot;{&quot;, &quot;}&quot;, &quot;=&quot;, &quot;!&quot;, &quot;:&quot;, &quot;-&quot;, &quot;,&quot;] 5.2.3.2 匹配 &quot;[abc]&quot; 和 &quot;{3,5}&quot; 我们知道 [abc]，是个字符组。如果要匹配字符串 &quot;[abc]&quot; 时，该怎么办？ 可以写成 /\\[abc\\]/，也可以写成 /\\[abc]/，测试如下： const string = '[abc]'; const regex = /\\[abc]/g; console.log(string.match(regex)[0]); // =&gt; &quot;[abc]&quot; 只需要在第一个方括号转义即可，因为后面的方括号构不成字符组，正则不会引发歧义，自然不需要转义。 同理，要匹配字符串 &quot;{3,5}&quot;，只需要把正则写成 /\\{3,5}/ 即可。 另外，我们知道量词有简写形式 {m,}，却没有 {,n} 的情况。虽然后者不构成量词的形式，但此时并不会报错。当然，匹配的字符串也是 &quot;{,n}&quot;，测试如下： const string = '{,3}'; const regex = /{,3}/g; console.log(string.match(regex)[0]); // =&gt; &quot;{,3}&quot; 5.2.3.3 其余情况 比如 = ! : - , 等符号，只要不在特殊结构中，也不需要转义。 但是，括号需要前后都转义的，如 /\\(123\\)/。 至于剩下的 ^ $ . * + ? | \\ / 等字符，只要不在字符组内，都需要转义的。 5.3 案例分析 接下来分析两个例子，一个简单的，一个复杂的。 5.3.1 身份证 正则表达式是：/^(\\d{15}|\\d{17}[\\dxX])$/，因为竖杠 | 的优先级最低，所以正则分成了两部分 \\d{15} 和 \\d{17}[\\dxX]。 \\d{15} 表示 15 位连续数字。 \\d{17}[\\dxX] 表示 17 位连续数字，最后一位可以是数字可以大小写字母 &quot;x&quot;。 可视化如下： 5.3.2 IPv4 地址 正则表达式是： /^((0{0,2}\\d|0?\\d{2}|1\\d{2}|2[0-4]\\d|25[0-5])\\.){3}(0{0,2}\\d|0?\\d{2}|1\\d{2}|2[0-4]\\d|25[0-5])$/ 这个正则，看起来非常吓人。但是熟悉优先级后，会立马得出如下的结构： ((...)\\.){3}(...) 上面的两个 (...) 是一样的结构。表示匹配的是 3 位数字。因此整个结构是： 3位数.3位数.3位数.3位数 然后再来分析 (...)： (0{0,2}\\d|0?\\d{2}|1\\d{2}|2[0-4]\\d|25[0-5])(0{0,2}\\d|0?\\d{2}|1\\d{2}|2[0-4]\\d|25[0-5]) 它是一个多选结构，分成 5 个部分： 0{0,2}\\d，匹配一位数，包括 0 补齐的。比如 9、09、009； 0?\\d{2}，匹配两位数，包括 0 补齐的，也包括一位数； 1\\d{2}，匹配 100 到 199; 2[0-4]\\d，匹配 200-249； 25[0-5]，匹配 250-255。 最后来看一下其可视化形式： 第 5 章小结 掌握正则表达式中的优先级后，再看任何正则应该都有信心分析下去了。 至于例子，不一而足，没有写太多。 这里稍微总结一下，竖杠的优先级最低，即最后运算。 只要知道这一点，就能读懂大部分正则。 另外关于元字符转义问题，当自己不确定与否时，尽管去转义，总之是不会错的。 第 6 章 正则表达式的构建 对于一门语言的掌握程度怎么样，可以有两个角度来衡量：读和写。 不仅要看懂别人的解决方案，也要能独立地解决问题。代码是这样，正则表达式也是这样。 与“读”相比，“写”往往更为重要，这个道理是不言而喻的。 对正则的运用，首重就是：如何针对问题，构建一个合适的正则表达式？ 本章就解决该问题，内容包括： 平衡法则 构建正则前提 准确性 效率 6.1 平衡法则 构建正则有一点非常重要，需要做到下面几点的平衡： 匹配预期的字符串 不匹配非预期的字符串 可读性和可维护性 效率 6.2 构建正则前提 6.2.1 是否能使用正则 正则太强大了，以至于我们随便遇到一个操作字符串问题时，都会下意识地去想，用正则该怎么做。但我们始终要提醒自己，正则虽然强大，但不是万能的，很多看似很简单的事情，还是做不到的。 比如匹配这样的字符串：1010010001.... 虽然很有规律，但是只靠正则就是无能为力。 6.2.2 是否有必要使用正则 要认识到正则的局限，不要去研究根本无法完成的任务。同时，也不能走入另一个极端：无所不用正则。能用字符串API解决的简单问题，就不该正则出马。 比如，从日期中提取出年月日，虽然可以使用正则： const string = '2017-07-01'; const regex = /^(\\d{4})-(\\d{2})-(\\d{2})/; console.log(string.match(regex)); // =&gt; [&quot;2017-07-01&quot;, &quot;2017&quot;, &quot;07&quot;, &quot;01&quot;, index: 0, input: &quot;2017-07-01&quot;] 其实，可以使用字符串的 split 方法来做，即可： const string = '2017-07-01'; const result = string.split('-'); console.log(result); // =&gt; [&quot;2017&quot;, &quot;07&quot;, &quot;01&quot;] 比如，判断是否有问号，虽然可以使用： const string = '?id=xx&amp;act=search'; console.log(string.search(/\\?/)); // =&gt; 0 其实，可以使用字符串的 indexOf 方法： const string = '?id=xx&amp;act=search'; console.log(string.indexOf('?')); // =&gt; 0 比如获取子串，虽然可以使用正则： const string = 'JavaScript'; console.log(string.match(/.{4}(.+)/)[1]); // =&gt; Script 其实，可以直接使用字符串的 substring 或 substr 方法来做： const string = 'JavaScript'; console.log(string.substring(4)); // =&gt; Script 6.2.3 是否有必要构建一个复杂的正则 比如密码匹配问题，要求密码长度 6-12 位，由数字、小写字符和大写字母组成，但必须至少包括 2 种字符。 在第 2 章里，我们写出了正则是：/(?!^[0-9]{6,12}$)(?!^[a-z]{6,12}$)(?!^[A-Z]{6,12}$)^[0-9A-Za-z]{6,12}$/ 其实可以使用多个小正则来做： const regex1 = /^[0-9A-Za-z]{6,12}$/; const regex2 = /^[0-9]{6,12}$/; const regex3 = /^[A-Z]{6,12}$/; const regex4 = /^[a-z]{6,12}$/; function checkPassword(string) { if (!regex1.test(string)) return false; if ( regex2.test(string)) return false; if ( regex3.test(string)) return false; if ( regex4.test(string)) return false; return true; } 6.3. 准确性 所谓准确性，就是能匹配预期的目标，并且不匹配非预期的目标。 这里提到了“预期”二字，那么我们就需要知道目标的组成规则。 不然没法界定什么样的目标字符串是符合预期的，什么样的又不是符合预期的。 下面将举例说明，当目标字符串构成比较复杂时，该如何构建正则，并考虑到哪些平衡。 6.3.1 匹配固定电话 比如要匹配如下格式的固定电话号码： 055188888888 0551-88888888 (0551)88888888 第一步，了解各部分的模式规则。 上面的电话，总体上分为区号和号码两部分（不考虑分机号和 +86 的情形）。 区号是 0 开头的 3 到 4 位数字，对应的正则是：0\\d{2,3} 号码是非 0 开头的 7 到 8 位数字，对应的正则是：[1-9]\\d{6,7} 因此，匹配 055188888888 的正则是：/^0\\d{2,3}[1-9]\\d{6,7}$/ 匹配 0551-88888888 的正则是：/^0\\d{2,3}-[1-9]\\d{6,7}$/ 匹配 (0551)88888888 的正则是：/^\\(0\\d{2,3}\\)[1-9]\\d{6,7}$/ 第二步，明确形式关系。 这三者情形是或的关系，可以构建分支： /^0\\d{2,3}[1-9]\\d{6,7}$|^0\\d{2,3}-[1-9]\\d{6,7}$|^\\(0\\d{2,3}\\)[1-9]\\d{6,7}$/ 提取公共部分： /^(0\\d{2,3}|0\\d{2,3}-|\\(0\\d{2,3}\\))[1-9]\\d{6,7}$/ 进一步简写： /^(0\\d{2,3}-?|\\(0\\d{2,3}\\))[1-9]\\d{6,7}$/ 其可视化形式： 上面的正则构建过程略显罗嗦，但是这样做，能保证正则是准确的。 上述三种情形是或的关系，这一点很重要，不然很容易按字符是否出现的情形把正则写成： /^\\(?0\\d{2,3}\\)?-?[1-9]\\d{6,7}$/ 虽然也能匹配上述目标字符串，但也会匹配 (0551-88888888 这样的字符串。当然，这不是我们想要的。 其实这个正则也不是完美的，因为现实中，并不是每个 3 位数和 4 位数都是一个真实的区号。 这就是一个平衡取舍问题，一般够用就行。 6.3.2 匹配浮点数 要求匹配如下的格式： 1.23、+1.23、-1.23 10、+10、-10 .2、+.2、-.2 可以看出正则分为三部分。 符号部分：[+-] 整数部分：\\d+ 小数部分：\\.\\d+ 上述三个部分，并不是全部都出现。如果此时很容易写出如下的正则： /^[+-]?(\\d+)?(\\.\\d+)?$/ 此正则看似没问题，但这个正则也会匹配空字符&quot;&quot;。 因为目标字符串的形式关系不是要求每部分都是可选的。 要匹配 1.23、+1.23、-1.23，可以用 /^[+-]?\\d+\\.\\d+$/ 要匹配 10、+10、-10，可以用 /^[+-]?\\d+$/ 要匹配.2、+.2、-.2，可以用 /^[+-]?\\.\\d+$/ 因此整个正则是这三者的或的关系，提取公众部分后是： /^[+-]?(\\d+\\.\\d+|\\d+|\\.\\d+)$/ 其可视化形式是： 如果要求不匹配 +.2 和 -.2，此时正则变成： /^([+-]?(\\d+\\.\\d+|\\d+)|\\.\\d+)$/ 其可视化形式是： 当然，/^[+-]?(\\d+\\.\\d+|\\d+|\\.\\d+)$/ 也不是完美的，我们也是做了些取舍，比如： 它也会匹配 012 这样以 0 开头的整数。如果要求不匹配的话，需要修改整数部分的正则。 一般进行验证操作之前，都要经过 trim 和判空。那样的话，也许那个错误正则也就够用了。 也可以进一步改写成：/^[+-]?(\\d+)?(\\.)?\\d+$/，这样我们就需要考虑可读性和可维护性了。 6.4 效率 保证了准确性后，才需要是否要考虑要优化。大多数情形是不需要优化的，除非运行的非常慢。什么情形正则表达式运行才慢呢？我们需要考察正则表达式的运行过程（原理）。 正则表达式的运行分为如下的阶段： 编译； 设定起始位置； 尝试匹配； 匹配失败的话，从下一位开始继续第 3 步； 最终结果：匹配成功或失败。 下面以代码为例，来看看这几个阶段都做了什么： const regex = /\\d+/g; console.log(regex.lastIndex, regex.exec('123abc34def')); console.log(regex.lastIndex, regex.exec('123abc34def')); console.log(regex.lastIndex, regex.exec('123abc34def')); console.log(regex.lastIndex, regex.exec('123abc34def')); // =&gt; 0 [&quot;123&quot;, index: 0, input: &quot;123abc34def&quot;] // =&gt; 3 [&quot;34&quot;, index: 6, input: &quot;123abc34def&quot;] // =&gt; 8 null // =&gt; 0 [&quot;123&quot;, index: 0, input: &quot;123abc34def&quot;] 具体分析如下： const regex = /\\d+/g; 当生成一个正则时，引擎会对其进行编译。报错与否出现这这个阶段。 regex.exec('123abc34def') 当尝试匹配时，需要确定从哪一位置开始匹配。一般情形都是字符串的开头，即第 0 位。 但当使用 test 和 exec 方法，且正则有 g 时，起始位置是从正则对象的 lastIndex 属性开始。 因此第一次 exec 是从第 0 位开始，而第二次是从 3 开始的。 设定好起始位置后，就开始尝试匹配了。 比如第一次 exec，从 0 开始，去尝试匹配，并且成功地匹配到 3 个数字。此时结束时的下标是 2，因此下一次的起始位置是 3。 而第二次，起始下标是 3，但第 3 个字符是 &quot;a&quot;，并不是数字。但此时并不会直接报匹配失败，而是移动到下一位置，即从第 4 位开始继续尝试匹配，但该字符是 b，也不是数字。再移动到下一位，是 c 仍不行，再移动一位是数字 3，此时匹配到了两位数字 34。此时，下一次匹配的位置是 d 的位置，即第 8 位。 第三次，是从第 8 位开始匹配，直到试到最后一位，也没发现匹配的，因此匹配失败，返回 null。同时设置 lastIndex 为 0，即，如要再尝试匹配的话，需从头开始。 从上面可以看出，匹配会出现效率问题，主要出现在上面的第 3 阶段和第 4 阶段。 因此，主要优化手法也是针对这两阶段的。 6.4.1 使用具体型字符组来代替通配符，来消除回溯 而在第三阶段，最大的问题就是回溯。 例如，匹配双引用号之间的字符。如，匹配字符串 123&quot;abc&quot;456 中的 &quot;abc&quot;。 如果正则用的是：/&quot;.*&quot;/，会在第 3 阶段产生 4 次回溯（粉色表示 .* 匹配的内容）： 如果正则用的是：/&quot;.*?&quot;/，会产生 2 次回溯（粉色表示 .*? 匹配的内容）： 因为回溯的存在，需要引擎保存多种可能中未尝试过的状态，以便后续回溯时使用。注定要占用一定的内存。 此时要使用具体化的字符组，来代替通配符.，以便消除不必要的字符，此时使用正则 /&quot;[^&quot;]*&quot;/，即可。 6.4.2 使用非捕获型分组 因为括号的作用之一是，可以捕获分组和分支里的数据。那么就需要内存来保存它们。 当我们不需要使用分组引用和反向引用时，此时可以使用非捕获分组。例如： /^[+-]?(\\d+\\.\\d+|\\d+|\\.\\d+)$/ 可以修改成：/^[+-]?(?:\\d+\\.\\d+|\\d+|\\.\\d+)$/ 6.4.3 独立出确定字符 例如 /a+/，可以修改成 /aa*/。 因为后者能比前者多确定了字符 a。这样会在第四步中，加快判断是否匹配失败，进而加快移位的速度。 6.4.4 提取分支公共部分 比如 /^abc|^def/，修改成 /^(?:abc|def)/。 又比如 /this|that/，修改成 /th(?:is|at)/。 这样做，可以减少匹配过程中可消除的重复。 6.4.5 减少分支的数量，缩小它们的范围 /red|read/，可以修改成 /rea?d/。此时分支和量词产生的回溯的成本是不一样的。但这样优化后，可读性会降低的。 第 6 章小结 本章涉及的内容并不多。一般情况下，针对某问题能写出一个满足需求的正则，基本上就可以了。至于准确性和效率方面的追求，纯属看个人要求了。我觉得够用就行了。关于准确性，本章关心的是最常用的解决思路：针对每种情形，分别写出正则，然用分支把他们合并在一起，再提取分支公共部分，就能得到准确的正则。至于优化，本章没有为了凑数，去写一大堆。了解了匹配原理，常见的优化手法也就这么几种。 第 7 章 正则表达式编程 什么叫知识，能指导我们实践的东西才叫知识。学习一样东西，如果不能使用，最多只能算作纸上谈兵。 正则表达式的学习，也不例外。掌握了正则表达式的语法后，下一步，也是关键的一步，就是在真实世界中使用它。那么如何使用正则表达式呢？有哪些关键的点呢？本章就解决这个问题。内容包括： 正则表达式的四种操作 相关API注意要点 真实案例 7.1 正则表达式的四种操作 正则表达式是匹配模式，不管如何使用正则表达式，万变不离其宗，都需要先“匹配”。 有了匹配这一基本操作后，才有其他的操作：验证、切分、提取、替换。 进行任何相关操作，也需要宿主引擎相关 API 的配合使用。当然，在 JS 中，相关 API 也不多。 7.1.1 验证 验证是正则表达式最直接的应用，比如表单验证。 在说验证之前，先要说清楚匹配是什么概念。 所谓匹配，就是看目标字符串里是否有满足匹配的子串。因此，“匹配”的本质就是“查找”。 有没有匹配，是不是匹配上，判断是否的操作，即称为“验证”。 这里举一个例子，来看看如何使用相关API进行验证操作的。 比如，判断一个字符串中是否有数字。 使用 search const regex = /\\d/; const string = 'abc123'; console.log(!!~string.search(regex)); // =&gt; true 使用 test const regex = /\\d/; const string = 'abc123'; console.log(regex.test(string)); // =&gt; true 使用 match const regex = /\\d/; const string = 'abc123'; console.log(!!string.match(regex)); // =&gt; true 使用 exec const regex = /\\d/; const string = 'abc123'; console.log(!!regex.exec(string)); // =&gt; true 其中，最常用的是 test。 7.1.2 切分 匹配上了，我们就可以进行一些操作，比如切分。 所谓“切分”，就是把目标字符串，切成一段一段的。在 JS 中使用的是 split。 比如，目标字符串是 &quot;html,css,javascript&quot;，按逗号来切分： const regex = /,/; const string = 'html,css,javascript'; console.log(string.split(regex)); // =&gt; [&quot;html&quot;, &quot;css&quot;, &quot;javascript&quot;] 又比如，如下的日期格式： 2017/06/26 2017.06.26 2017-06-26 可以使用 split“切出”年月日： const regex = /\\D/; console.log('2017/06/26'.split(regex)); console.log('2017.06.26'.split(regex)); console.log('2017-06-26'.split(regex)); // =&gt; [&quot;2017&quot;, &quot;06&quot;, &quot;26&quot;] // =&gt; [&quot;2017&quot;, &quot;06&quot;, &quot;26&quot;] // =&gt; [&quot;2017&quot;, &quot;06&quot;, &quot;26&quot;] 7.1.3 提取 虽然整体匹配上了，但有时需要提取部分匹配的数据。 此时正则通常要使用分组引用（分组捕获）功能，还需要配合使用相关 API。 这里，还是以日期为例，提取出年月日。注意下面正则中的括号： match const regex = /^(\\d{4})\\D(\\d{2})\\D(\\d{2})$/; const string = '2017-06-26'; console.log(string.match(regex)); // =&gt;[&quot;2017-06-26&quot;, &quot;2017&quot;, &quot;06&quot;, &quot;26&quot;, index: 0, input: &quot;2017-06-26&quot;] exec const regex = /^(\\d{4})\\D(\\d{2})\\D(\\d{2})$/; const string = '2017-06-26'; console.log(regex.exec(string)); // =&gt;[&quot;2017-06-26&quot;, &quot;2017&quot;, &quot;06&quot;, &quot;26&quot;, index: 0, input: &quot;2017-06-26&quot;] test const regex = /^(\\d{4})\\D(\\d{2})\\D(\\d{2})$/; const string = '2017-06-26'; regex.test(string); console.log(RegExp.$1, RegExp.$2, RegExp.$3); // =&gt; &quot;2017&quot; &quot;06&quot; &quot;26&quot; search const regex = /^(\\d{4})\\D(\\d{2})\\D(\\d{2})$/; const string = '2017-06-26'; string.search(regex); console.log(RegExp.$1, RegExp.$2, RegExp.$3); // =&gt; &quot;2017&quot; &quot;06&quot; &quot;26&quot; replace const regex = /^(\\d{4})\\D(\\d{2})\\D(\\d{2})$/; const string = '2017-06-26'; const date = []; string.replace(regex, function(match, year, month, day) { date.push(year, month, day); }); console.log(date); // =&gt; [&quot;2017&quot;, &quot;06&quot;, &quot;26&quot;] 其中，最常用的是 match。 7.1.4 替换 找，往往不是目的，通常下一步是为了替换。在 JS 中，使用 replace 进行替换。 比如把日期格式，从 yyyy-mm-dd 替换成 yyyy/mm/dd： const string = '2017-06-26'; const today = new Date(string.replace(/-/g, '/')); console.log(today); // =&gt; Mon Jun 26 2017 00:00:00 GMT+0800 (中国标准时间) 这里只是简单地应用了一下 replace。但，replace 方法是强大的，是需要重点掌握的。 7.2. 相关API注意要点 从上面可以看出用于正则操作的方法，共有 6 个，字符串实例 4 个，正则实例 2 个： String#search String#split String#match String#replace RegExp#test RegExp#exec 本文不打算详细地讲解它们的方方面面细节，具体可以参考《JavaScript权威指南》的第三部分。本文重点列出一些容易忽视的地方，以飨读者。 7.2.1 search 和 match 的参数问题 我们知道字符串实例的那 4 个方法参数都支持正则和字符串。 但 search 和 match，会把字符串转换为正则的。 const string = '2017.06.27'; console.log(string.search('.')); // =&gt; 0 //需要修改成下列形式之一 console.log(string.search('\\\\.')); console.log(string.search(/\\./)); // =&gt; 4 // =&gt; 4 console.log(string.match('.')); // =&gt; [&quot;2&quot;, index: 0, input: &quot;2017.06.27&quot;] //需要修改成下列形式之一 console.log(string.match('\\\\.')); console.log(string.match(/\\./)); // =&gt; [&quot;.&quot;, index: 4, input: &quot;2017.06.27&quot;] // =&gt; [&quot;.&quot;, index: 4, input: &quot;2017.06.27&quot;] console.log(string.split('.')); // =&gt; [&quot;2017&quot;, &quot;06&quot;, &quot;27&quot;] console.log(string.replace('.', '/')); // =&gt; &quot;2017/06.27&quot; 7.2.2 match 返回结果的格式问题 match 返回结果的格式，与正则对象是否有修饰符 g 有关。 const string = '2017.06.27'; const regex1 = /\\b(\\d+)\\b/; const regex2 = /\\b(\\d+)\\b/g; console.log(string.match(regex1)); console.log(string.match(regex2)); // =&gt; [&quot;2017&quot;, &quot;2017&quot;, index: 0, input: &quot;2017.06.27&quot;] // =&gt; [&quot;2017&quot;, &quot;06&quot;, &quot;27&quot;] 没有 g，返回的是标准匹配格式，即，数组的第一个元素是整体匹配的内容，接下来是分组捕获的内容，然后是整体匹配的第一个下标，最后是输入的目标字符串。 有 g，返回的是所有匹配的内容。 当没有匹配时，不管有无 g，都返回 null。 7.2.3 exec比match更强大 当正则没有 g 时，使用 match 返回的信息比较多。但是有 g 后，就没有关键的信息 index 了。 而 exec 方法就能解决这个问题，它能接着上一次匹配后继续匹配： const string = '2017.06.27'; const regex2 = /\\b(\\d+)\\b/g; console.log(regex2.exec(string)); console.log(regex2.lastIndex); console.log(regex2.exec(string)); console.log(regex2.lastIndex); console.log(regex2.exec(string)); console.log(regex2.lastIndex); console.log(regex2.exec(string)); console.log(regex2.lastIndex); // =&gt; [&quot;2017&quot;, &quot;2017&quot;, index: 0, input: &quot;2017.06.27&quot;] // =&gt; 4 // =&gt; [&quot;06&quot;, &quot;06&quot;, index: 5, input: &quot;2017.06.27&quot;] // =&gt; 7 // =&gt; [&quot;27&quot;, &quot;27&quot;, index: 8, input: &quot;2017.06.27&quot;] // =&gt; 10 // =&gt; null // =&gt; 0 其中正则实例 lastIndex 属性，表示下一次匹配开始的位置。 比如第一次匹配了 &quot;2017&quot;，开始下标是 0，共 4 个字符，因此这次匹配结束的位置是 3，下一次开始匹配的位置是 4。 从上述代码看出，在使用 exec 时，经常需要配合使用 while 循环： const string = '2017.06.27'; const regex2 = /\\b(\\d+)\\b/g; const result; while (result = regex2.exec(string)) { console.log(result, regex2.lastIndex); } // =&gt; [&quot;2017&quot;, &quot;2017&quot;, index: 0, input: &quot;2017.06.27&quot;] 4 // =&gt; [&quot;06&quot;, &quot;06&quot;, index: 5, input: &quot;2017.06.27&quot;] 7 // =&gt; [&quot;27&quot;, &quot;27&quot;, index: 8, input: &quot;2017.06.27&quot;] 10 7.2.4 修饰符g，对exex和test的影响 上面提到了正则实例的 lastIndex 属性，表示尝试匹配时，从字符串的 lastIndex 位开始去匹配。 字符串的四个方法，每次匹配时，都是从 0 开始的，即 lastIndex 属性始终不变。 而正则实例的两个方法 exec、test，当正则是全局匹配时，每一次匹配完成后，都会修改 lastIndex。下面让我们以 test 为例，看看你是否会迷糊： const regex = /a/g; console.log(regex.test('a'), regex.lastIndex); console.log(regex.test('aba'), regex.lastIndex); console.log(regex.test('ababc'), regex.lastIndex); // =&gt; true 1 // =&gt; true 3 // =&gt; false 0 注意上面代码中的第三次调用 test，因为这一次尝试匹配，开始从下标 lastIndex 即 3 位置处开始查找，自然就找不到了。 如果没有 g，自然都是从字符串第 0 个字符处开始尝试匹配： const regex = /a/; console.log(regex.test('a'), regex.lastIndex); console.log(regex.test('aba'), regex.lastIndex); console.log(regex.test('ababc'), regex.lastIndex); // =&gt; true 0 // =&gt; true 0 // =&gt; true 0 7.2.5 test 整体匹配时需要使用 ^ 和 $ 这个相对容易理解，因为 test 是看目标字符串中是否有子串匹配正则，即有部分匹配即可。 如果，要整体匹配，正则前后需要添加开头和结尾： console.log(/123/.test('a123b')); // =&gt; true console.log(/^123$/.test('a123b')); // =&gt; false console.log(/^123$/.test('123')); // =&gt; true 7.2.6 split 相关注意事项 split 方法看起来不起眼，但要注意的地方有两个的。 第一，它可以有第二个参数，表示结果数组的最大长度： const string = 'html,css,javascript'; console.log(string.split(/,/, 2)); // =&gt;[&quot;html&quot;, &quot;css&quot;] 第二，正则使用分组时，结果数组中是包含分隔符的： const string = 'html,css,javascript'; console.log(string.split(/(,)/)); // =&gt;[&quot;html&quot;, &quot;,&quot;, &quot;css&quot;, &quot;,&quot;, &quot;javascript&quot;] 7.2.7 replace 是很强大的 《JavaScript权威指南》认为 exec 是这 6 个 API 中最强大的，而我始终认为 replace 才是最强大的。因为它也能拿到该拿到的信息，然后可以假借替换之名，做些其他事情。 总体来说 replace 有两种使用形式，这是因为它的第二个参数，可以是字符串，也可以是函数。 当第二个参数是字符串时，如下的字符有特殊的含义： $1,$2,...,$99 匹配第 1~99 个分组里捕获的文本 $&amp; 匹配到的子串文本 $` 匹配到的子串的左边文本 $' 匹配到的子串的右边文本 $$ 美元符号 例如，把 &quot;2,3,5&quot;，变成 &quot;5=2+3&quot;： const result = '2,3,5'.replace(/(\\d+),(\\d+),(\\d+)/, '$3=$1+$2'); console.log(result); // =&gt; &quot;5=2+3&quot; 又例如，把 &quot;2,3,5&quot;，变成 &quot;222,333,555&quot;: const result = '2,3,5'.replace(/(\\d+)/g, '$&amp;$&amp;$&amp;'); console.log(result); // =&gt; &quot;222,333,555&quot; 当第二个参数是函数时，我们需要注意该回调函数的参数具体是什么： '1234 2345 3456'.replace(/(\\d)\\d{2}(\\d)/g, function(match, $1, $2, index, input) { console.log([match, $1, $2, index, input]); }); // =&gt; [&quot;1234&quot;, &quot;1&quot;, &quot;4&quot;, 0, &quot;1234 2345 3456&quot;] // =&gt; [&quot;2345&quot;, &quot;2&quot;, &quot;5&quot;, 5, &quot;1234 2345 3456&quot;] // =&gt; [&quot;3456&quot;, &quot;3&quot;, &quot;6&quot;, 10, &quot;1234 2345 3456&quot;] 此时我们可以看到 replace 拿到的信息，并不比 exec 少。 7.2.8 使用构造函数需要注意的问题 一般不推荐使用构造函数生成正则，而应该优先使用字面量。因为用构造函数会多写很多 \\。 const string = '2017-06-27 2017.06.27 2017/06/27'; const regex = /\\d{4}(-|\\.|\\/)\\d{2}\\1\\d{2}/g; console.log(string.match(regex)); // =&gt; [&quot;2017-06-27&quot;, &quot;2017.06.27&quot;, &quot;2017/06/27&quot;] regex = new RegExp('\\\\d{4}(-|\\\\.|\\\\/)\\\\d{2}\\\\1\\\\d{2}', 'g'); console.log(string.match(regex)); // =&gt; [&quot;2017-06-27&quot;, &quot;2017.06.27&quot;, &quot;2017/06/27&quot;] 7.2.9 修饰符 ES5中修饰符，共3个： g 全局匹配，即找到所有匹配的，单词是 global i 忽略字母大小写，单词 ingoreCase m 多行匹配，只影响 ^ 和 $，二者变成行的概念，即行开头和行结尾。单词是 multiline 当然正则对象也有相应的只读属性： const regex = /\\w/img; console.log(regex.global); console.log(regex.ignoreCase); console.log(regex.multiline); // =&gt; true // =&gt; true // =&gt; true 7.2.10 source 属性 正则实例对象属性，除了 global、ingnoreCase、multiline、lastIndex 属性之外，还有一个 source 属性。 它什么时候有用呢？ 比如，在构建动态的正则表达式时，可以通过查看该属性，来确认构建出的正则到底是什么： const className = 'high'; const regex = new RegExp('(^|\\\\s)' + className + '(\\\\s|$)'); console.log(regex.source) // =&gt; (^|\\s)high(\\s|$) 即字符串&quot;(^|\\\\s)high(\\\\s|$)&quot; 7.2.11 构造函数属性 构造函数的静态属性基于所执行的最近一次正则操作而变化。除了是 $1,...,$9 之外，还有几个不太常用的属性（有兼容性问题）： RegExp.input 最近一次目标字符串，简写成 RegExp[&quot;$_&quot;] RegExp.lastMatch 最近一次匹配的文本，简写成 RegExp[&quot;$&amp;&quot;] RegExp.lastParen 最近一次捕获的文本，简写成 RegExp[&quot;$+&quot;] RegExp.leftContext 目标字符串中 lastMatch 之前的文本，简写成 RegExp[&quot;$`&quot;] RegExp.rightContext 目标字符串中 lastMatch 之后的文本，简写成 RegExp[&quot;$'&quot;] 测试代码如下： const regex = /([abc])(\\d)/g; const string = 'a1b2c3d4e5'; string.match(regex); console.log(RegExp.input); console.log(RegExp['$_']); // =&gt; &quot;a1b2c3d4e5&quot; console.log(RegExp.lastMatch); console.log(RegExp['$&amp;']); // =&gt; &quot;c3&quot; console.log(RegExp.lastParen); console.log(RegExp['$+']); // =&gt; &quot;3&quot; console.log(RegExp.leftContext); console.log(RegExp[&quot;$`&quot;]); // =&gt; &quot;a1b2&quot; console.log(RegExp.rightContext); console.log(RegExp[&quot;$'&quot;]); // =&gt; &quot;d4e5&quot; 7.3 真实案例 7.3.1 使用构造函数生成正则表达式 我们知道要优先使用字面量来创建正则，但有时正则表达式的主体是不确定的，此时可以使用构造函数来创建。模拟 getElementsByClassName 方法，就是很能说明该问题的一个例子。 这里 getElementsByClassName 函数的实现思路是： 比如要获取 className 为 &quot;high&quot; 的 dom 元素； 首先生成一个正则：/(^|\\s)high(\\s|$)/； 然后再用其逐一验证页面上的所有 dom 元素的类名，拿到满足匹配的元素即可。 代码如下(可以直接复制到本地查看运行效果)： &lt;p class=&quot;high&quot;&gt;1111&lt;/p&gt; &lt;p class=&quot;high&quot;&gt;2222&lt;/p&gt; &lt;p&gt;3333&lt;/p&gt; &lt;script&gt; function getElementsByClassName(className) { var elements = document.getElementsByTagName(&quot;*&quot;); var regex = new RegExp(&quot;(^|\\\\s)&quot; + className + &quot;(\\\\s|$)&quot;); var result = []; for (var i = 0; i &lt; elements.length; i++) { var element = elements[i]; if (regex.test(element.className)) { result.push(element) } } return result; } var highs = getElementsByClassName('high'); highs.forEach(function(item) { item.style.color = 'red'; }); &lt;/script&gt; 7.3.2 使用字符串保存数据 一般情况下，我们都愿意使用数组来保存数据。但我看到有的框架中，使用的却是字符串。 使用时，仍需要把字符串切分成数组。虽然不一定用到正则，但总感觉酷酷的，这里分享如下： const utils = {}; 'Boolean|Number|String|Function|Array|Date|RegExp|Object|Error'.split('|').forEach(function(item) { utils['is' + item] = function(obj) { return {}.toString.call(obj) == '[object ' + item + ']'; }; }); console.log( utils.isArray([1, 2, 3]) ); // =&gt; true 7.3.3 if 语句中使用正则替代 &amp;&amp; 比如，模拟 ready 函数，即加载完毕后再执行回调（不兼容 IE 的）： const readyRE = /complete|loaded|interactive/; function ready(callback) { if (readyRE.test(document.readyState) &amp;&amp; document.body) { callback() } else { document.addEventListener( 'DOMContentLoaded', function () { callback() }, false ); } }; ready(function() { alert('加载完毕！') }); 7.3.4 使用强大的 replace 因为 replace 方法比较强大，有时用它根本不是为了替换，只是拿其匹配到的信息来做文章。 这里以查询字符串（querystring）压缩技术为例，注意下面 replace 方法中，回调函数根本没有返回任何东西。 function compress(source) { var keys = {}; source.replace(/([^=&amp;]+)=([^&amp;]*)/g, function(full, key, value) { keys[key] = (keys[key] ? keys[key] + ',' : '') + value; }); var result = []; for (var key in keys) { result.push(key + '=' + keys[key]); } return result.join('&amp;'); } console.log(compress(&quot;a=1&amp;b=2&amp;a=3&amp;b=4&quot;)); // =&gt; &quot;a=1,3&amp;b=2,4&quot; 7.3.5 综合运用 最后这里再做个简单实用的正则测试器。 具体效果如下： 代码，直接贴了，相信你能看得懂： &lt;section&gt; &lt;div id=&quot;err&quot;&gt;&lt;/div&gt; &lt;input id=&quot;regex&quot; placeholder=&quot;请输入正则表达式&quot;&gt; &lt;input id=&quot;text&quot; placeholder=&quot;请输入测试文本&quot;&gt; &lt;button id=&quot;run&quot;&gt;测试一下&lt;/button&gt; &lt;div id=&quot;result&quot;&gt;&lt;/div&gt; &lt;/section&gt; &lt;style&gt; section{ display:flex; flex-direction:column; justify-content:space-around; height:300px; padding:0 200px; } section *{ min-height:30px; } #err { color:red; } #result{ line-height:30px; } .info { background:#00c5ff; padding:2px; margin:2px; display:inline-block; } &lt;/style&gt; &lt;script&gt; (function() { // 获取相应dom元素 var regexInput = document.getElementById(&quot;regex&quot;); var textInput = document.getElementById(&quot;text&quot;); var runBtn = document.getElementById(&quot;run&quot;); var errBox = document.getElementById(&quot;err&quot;); var resultBox = document.getElementById(&quot;result&quot;); // 绑定点击事件 runBtn.onclick = function() { // 清除错误和结果 errBox.innerHTML = &quot;&quot;; resultBox.innerHTML = &quot;&quot;; // 获取正则和文本 var text = textInput.value; var regex = regexInput.value; if (regex == &quot;&quot;) { errBox.innerHTML = &quot;请输入正则表达式&quot;; } else if (text == &quot;&quot;) { errBox.innerHTML = &quot;请输入测试文本&quot;; } else { regex = createRegex(regex); if (!regex) return; var result, results = []; // 没有修饰符g的话，会死循环 if (regex.global) { while(result = regex.exec(text)) { results.push(result); } } else { results.push(regex.exec(text)); } if (results[0] == null) { resultBox.innerHTML = &quot;匹配到0个结果&quot;; return; } // 倒序是有必要的 for (var i = results.length - 1; i &gt;= 0; i--) { var result = results[i]; var match = result[0]; var prefix = text.substr(0, result.index); var suffix = text.substr(result.index + match.length); text = prefix + '&lt;span class=&quot;info&quot;&gt;' + match + '&lt;/span&gt;' + suffix; } resultBox.innerHTML = &quot;匹配到&quot; + results.length + &quot;个结果:&lt;br&gt;&quot; + text; } }; // 生成正则表达式，核心函数 function createRegex(regex) { try { if (regex[0] == &quot;/&quot;) { regex = regex.split(&quot;/&quot;); regex.shift(); var flags = regex.pop(); regex = regex.join(&quot;/&quot;); regex = new RegExp(regex, flags); } else { regex = new RegExp(regex, &quot;g&quot;); } return regex; } catch(e) { errBox.innerHTML = &quot;无效的正则表达式&quot;; return false; } } })(); &lt;/script&gt; 第 7 章小结 相关API的注意点，本章基本上算是一网打尽了。 至于文中的例子，都是点睛之笔，没有详细解析。如有理解不透的，建议自己敲一敲。 后记 文章要结束了，最后还要有几点说明。 1. 需要注意的地方 本文主要讨论的是 JavaScript 的正则表达式，更精确地说是 ES5 的正则表达式。 JavaScript 的正则表达式引擎是传统型 NFA 的，因此本系列的讨论是适合任何一门正则引擎是传统型 NFA 的编程语言。当然，市面上大部分语言的正则引擎都是这种的。而 JS 里正则涉及到的所有语法要点，是这种引擎支持的核心子集。也就是说，要学正则表达式，不妨以 JS 正则为出发点。 2. 参考资料 当然本文不是无本之末。主要参考的是几本书籍。 以下书籍中核心章节都认真阅读过，甚至阅读多遍。 《JavaScript权威指南》，看完本系列，再去看书中的第 10 章，你就知道了什么叫字字珠玑。 《精通正则表达式》，权威且比较杂乱，我阅读的第一本正则表达式书籍。 《正则表达式必知必会》，这是我看的第二本正则，看完后，确定自己算是入门了。 《正则指引》，《精通正则表达式》的译者写的，相对清晰。 《正则表达式入门》，我看的是英文版的，对于已经入门的我，基本没多少收获了。 《正则表达式经典实例》，除了第 3 章，比较杂外，也有收获，以实例为主导的一本书。 《JavaScript Regular Expressions》，为数不多转讲 JS 正则的。页数不多，也有收获。 《高性能JavaScript 》第 5 章，我看的是英文版的。第 5 章，讲了回溯和优化。 《JavaScript忍者秘籍》第 7 章，大概讲了一下正则的用法，几个例子还不错。 《JavaScript高级程序设计》第 5.4 节，比较简短的介绍。 使用的工具： Regulex，一款可视化工具 ProcessOn - 免费在线作图，实时协作 LICEcap – 灵活好用，GIF 屏幕录制工具 ","link":"https://tdmaker.github.io/faded/post/regular-expression-full-tutorial/"},{"title":"正则表达式——断言人话版","content":" 这次不会说我的正则教程没写全了吧？？ 零宽断言 断言：俗话的断言就是“我断定什么什么”，而正则中的断言，就是说正则可以指明在指定内容的前面或后面会出现满足指定规则的内容，意思正则也可以像人类那样断定什么什么，比如“ss1aa2bb3”，正则可以用断言找出 aa2 前面有 bb3，也可以找出 aa2 后面有 ss1。 零宽：就是没有宽度，在正则中，断言只是匹配位置，不占字符，也就是说，匹配结果里是不会返回断言本身。 假设我们要用爬虫抓取 csdn 里的文章阅读量。通过查看源代码可以看到文章阅读量这个内容是这样的结构： &lt;span class=&quot;read-count&quot;&gt;阅读数：641&lt;/span&gt; 需要获得这里边的‘641’有很多种办法，但如果使用正则应该怎么匹配呢？下面先讲一下几种类型的断言： 💡正向先行断言（正前瞻） 语法：(?=pattern)； 作用：匹配 pattern 表达式的前面内容，不返回本身。 要取到阅读量，在正则表达式中就意味着要能匹配到‘&lt;/span&gt;’前面的数字内容，按照上所说的正向先行断言可以匹配表达式前面的内容，那意思就是：(?=&lt;/span&gt;) 就可以匹配到前面的内容了。 const regExp = /.+(?=&lt;\\/span&gt;)/; const str = &quot;&lt;span class=\\&quot;read-count\\&quot;&gt;阅读数：641&lt;/span&gt;&quot; console.log(regExp.exec(str)); // 匹配结果： [ '&lt;span class=&quot;read-count&quot;&gt;阅读数：641', index: 0, input: '&lt;span class=&quot;read-count&quot;&gt;阅读数：641&lt;/span&gt;', groups: undefined ] 仅匹配前面的数字： const regExp = /\\d+(?=&lt;\\/span&gt;)/; const str = &quot;&lt;span class=\\&quot;read-count\\&quot;&gt;阅读数：641&lt;/span&gt;&quot; console.log(regExp.exec(str)); // 匹配结果： [ '641', index: 29, input: '&lt;span class=&quot;read-count&quot;&gt;阅读数：641&lt;/span&gt;', groups: undefined ] 💡正向后行断言（正后顾）: 语法：(?&lt;=pattern)； 作用：匹配 pattern 表达式的后面的内容，不返回本身。 有先行就有后行，先行是匹配前面的内容，那后行就是匹配后面的内容啦。上面的栗子，我们也可以用后行断言来处理。 const regExp= /(?&lt;=&lt;span class=\\&quot;read-count\\&quot;&gt;阅读数：)\\d+/; const str = &quot;&lt;span class=\\&quot;read-count\\&quot;&gt;阅读数：641&lt;/span&gt;&quot; console.log(regExp.exec(str)); // 匹配结果 [ '641', index: 29, input: '&lt;span class=&quot;read-count&quot;&gt;阅读数：641&lt;/span&gt;', groups: undefined ] 💡负向先行断言（负前瞻） 语法：(?!pattern)； 作用：匹配非 pattern 表达式的前面内容，不返回本身。 有正向也有负向，负向在这里其实就是非的意思。举个栗子：比如有一句 “我爱祖国，我是祖国的花朵”，现在要找到不是 “的花朵”前面的“祖国”，用正则就可以这样写：祖国(?!的花朵)。 💡负向后行断言（负后顾） 语法：(?&lt;!pattern)； 作用：匹配非 pattern 表达式的后面内容，不返回本身。 捕获和非捕获 单纯说到捕获，他的意思是匹配表达式，但捕获通常和分组联系在一起，也就是“捕获组”。捕获组：匹配子表达式的内容，把匹配结果保存到内存中数字编号或显示命名的组里，以深度优先进行编号，之后可以通过序号或名称来使用这些匹配结果。 而根据命名方式的不同，又可以分为两种组： 💡数字编号捕获组 语法：(exp)； 解释：从表达式左侧开始，每出现一个左括号和它对应的右括号之间的内容为一个分组，在分组中，第 0 组为整个表达式，第一组开始为分组。 比如固定电话的：020-85653333，它的正则表达式为：(0\\d{2})-(\\d{8})，按照左括号的顺序，这个表达式有如下分组： 序号 编号 分组 内容 0 0 (0\\d{2})-(\\d{8}) 020-85653333 1 1 (0\\d{2}) 020 2 2 (\\d{8}) 85653333 下面来验证一下： const str = '020-85653333'; const regExp=/(0\\d{2})-(\\d{8})/; console.log(regExp.exec(str)); // 输出结果： [ '020-85653333', '020', '85653333', index: 0, input: '020-85653333', groups: undefined ] 可见，分组个数是2，但是因为第0个为整个表达式本身，因此也一起输出了。 💡命名编号捕获组： 语法：(?&lt;name&gt;exp)； 解释：分组的命名由表达式中的name指定。 比如区号也可以这样写: (?&lt;quhao&gt;\\0\\d{2})-(?&lt;haoma&gt;\\d{8})，按照左括号的顺序，这个表达式有如下分组： 序号 名称 分组 内容 0 0 (0\\d{2})-(\\d{8}) 020-85653333 1 quhao (0\\d{2}) 020 2 haoma (\\d{8}) 85653333 const str = '020-85653333'; const regExp=/(?&lt;quhao&gt;0\\d{2})-(?&lt;haoma&gt;\\d{8})/; console.log(regExp.exec(str)); // 输出结果： [ '020-85653333', '020', '85653333', index: 0, input: '020-85653333', groups: [Object: null prototype] { quhao: '020', haoma: '85653333' } ] 💡非捕获组： 语法：(?:exp)； 解释：和捕获组刚好相反，它用来标识那些不需要捕获的分组，说的通俗一点，就是你可以根据需要去保存你的分组。 比如上面的正则表达式，程序不需要用到第一个分组，那就可以这样写：1(?:\\0\\d{2})-(\\d{8})。 序号 编号 分组 内容 0 0 (0\\d{2})-(\\d{8}) 020-85653333 1 1 (\\d{8}) 85653333 const str = '020-85653333'; const regExp=/(?:0\\d{2})-(\\d{8})/; console.log(regExp.exec(str)); // 运行结果： [ '020-85653333', '85653333', index: 0, input: '020-85653333', groups: undefined ] 反向引用 上面讲到捕获，我们知道：捕获会返回一个捕获组，这个分组是保存在内存中，不仅可以在正则表达式外部通过程序进行引用，也可以在正则表达式内部进行引用，这种引用方式就是反向引用。 根据捕获组的命名规则，反向引用可分为： 数字编号组反向引用：\\k 或 \\number； 命名编号组反向引用：\\k或者 \\'name'。 捕获组通常是和反向引用一起使用的。上面说到捕获组是匹配子表达式的内容按序号或者命名保存起来以便使用。注意两个字眼：“内容” 和 “使用”，这里所说的“内容”，是匹配结果，而不是子表达式本身。这里所说的“使用”的作用主要是用来查找一些重复的内容或者做替换指定字符。 还是举栗子吧：比如要查找一串字母 &quot;aabbbbgbddesddfiid&quot; 里成对的字母，如果按照我们之前学到的正则，什么区间啊限定啊断言啊可能是办不到的，现在我们先用程序思维理一下思路： 匹配到一个字母； 匹配第下一个字母，检查是否和上一个字母是否一样； 如果一样，则匹配成功，否则失败； 这里的思路 2 中匹配下一个字母时，需要用到上一个字母，那怎么记住上一个字母呢？这下子捕获就有用处啦，我们可以利用捕获把上一个匹配成功的内容用来作为本次匹配的条件。好了，有思路就要实践，首先匹配一个字母：\\w，我们需要做成分组才能捕获，因此写成这样：(\\w)，那这个表达式就有一个捕获组：(\\w)，然后我们要用这个捕获组作为条件，那就可以：(\\w)\\1，这样就大功告成了，可能有人不明白了，\\1 是什么意思呢？ 还记得捕获组有两种命名方式吗，一种是是根据捕获分组顺序命名，一种是自定义命名来作为捕获组的命名。在默认情况下都是以数字来命名，而且数字命名的顺序是从 1 开始的。因此要引用第一个捕获组，根据反向引用的数字命名规则 就需要 \\k&lt;1&gt; 或者 \\1 当然，通常都是是后者。 我们来测试一下： const str = 'aabbbbgbddesddfiid'; const regExp=/(\\w)\\1/g; console.log(str.match(regExp)); 运行结果： [ 'aa', 'bb', 'bb', 'dd', 'dd', 'ii' ] 再举个替换的例子，假如想要把字符串中 abc 换成 a： const str = 'abcbbabcbcgbddesddfiid'; const regExp=/(a)(b)c/g; console.log(str.replace(regExp, '$1')); // 输出结果： abcbbabcbcgbddesddfiid 贪婪和非贪婪 💡贪婪 贪婪匹配：当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符，这匹配方式叫做贪婪匹配。 特性：一次性读入整个字符串进行匹配，每当不匹配就舍弃最右边一个字符，继续匹配，依次匹配和舍弃（这种匹配-舍弃的方式也叫做回溯），直到匹配成功或者把整个字符串舍弃完为止，因此它是一种最大化的数据返回，能多不会少。 前面我们讲过重复限定符，其实这些限定符就是贪婪量词，比如表达式：\\d{3,6} 用来匹配 3 到 6 位数字，在这种情况下，它是一种贪婪模式的匹配，也就是假如字符串里有 6 个数字可以匹配，那它就是全部匹配到。例如： const str = &quot;61762828 176 2991 871&quot;; const regExp=/\\d{3,6}/g; console.log(str.match(regExp)); // 输出结果： [ '617628', '176', '2991', '871' ] 由结果可见：本来字符串中的“61762828”这一段，其实只需要出现3个（617）就已经匹配成功了的，但是他并不满足，而是匹配到了最大能匹配的字符，也就是6个。 一个量词就如此贪婪了，那有人会问，如果多个贪婪量词凑在一起，那他们是如何支配自己的匹配权的呢？是这样的，多个贪婪在一起时，如果字符串能满足他们各自最大程度的匹配时，就互不干扰，但如果不能满足时，会根据深度优先原则，也就是从左到右的每一个贪婪量词，优先最大数量的满足，剩余再分配下一个量词匹配。 const str = &quot;61762828 176 2991 87321&quot;; const regExp=/(\\d{1,2})(\\d{3,4})/g; console.log(str.match(regExp)); // 输出结果： [ '617628', '2991', '87321' ] 解答： “617628” 是前面的 \\d{1,2} 匹配出了 61，后面的匹配出了 7628； “2991”是前面的 \\d{1,2} 匹配出了 2 ，后面的匹配出了 991(满足匹配优先，再最大程度的贪婪)； “87321”是前面的 \\d{1,2} 匹配出了 87，后面的匹配出了 321。 💡懒惰（非贪婪） 懒惰匹配：当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能少的字符，这匹配方式叫做懒惰匹配。 特性：从左到右，从字符串的最左边开始匹配，每次试图不读入字符匹配，匹配成功，则完成匹配，否则读入一个字符再匹配，依此循环（读入字符、匹配）直到匹配成功或者把字符串的字符匹配完为止。 懒惰量词是在贪婪量词后面加个“?”。 代码 说明 *? 重复任意次，但尽可能少重复 +? 重复 1 次或更多次，但尽可能少重复 ?? 重复 0 次或 1 次，但尽可能少重复 {n,m}? 重复 n 到 m 次，但尽可能少重复 {n,}? 重复 n 次以上，但尽可能少重复 const str = &quot;61762828 176 2991 87321&quot;; const regExp=/(\\d{1,2}?)(\\d{3,4})/g; console.log(str.match(regExp)); // 输出结果： [ '61762', '2991', '87321' ] 解答： “61762”是左边的懒惰匹配出 6，右边的贪婪匹配出 1762； “2991”是左边的懒惰匹配出 2，右边的贪婪匹配出 991； “87321”左边的懒惰匹配出 8，右边的贪婪匹配出 7321。 反义 前面说到元字符的都是要匹配什么什么，当然如果你想反着来，不想匹配某些字符，正则也提供了一些常用的反义元字符： 元字符 解释 \\W 匹配任意不是字母，数字，下划线，汉字的字符 \\S 匹配任意不是空白符的字符 \\D 匹配任意非数字的字符 \\B 匹配不是单词开头或结束的位置 [^x] 匹配除了 x 以外的任意字符 [^aeiou] 匹配除了 aeiou 这几个字母以外的任意字符 ","link":"https://tdmaker.github.io/faded/post/regular-expression-assert-mandarin/"},{"title":"正则表达式——NFA","content":" 正则表达式和NFA NFA NFA 是指 Nondeterministic Finite Automaton，非确定有限状态自动机。 目前正则表达式引擎主要有两种：NFA 和 DFA； JavaScript 采用的是 NFA 引擎。 状态机中有这样一些要素，对照上图分别说下： 开始状态：圆圈表示状态，被一个“没有起点的箭头”指向的状态，是开始状态，上例中是 S1； 最终状态：也叫接受状态，图中用双圆圈表示，这个例子中也是 S1； 输入：在一个状态下，向状态机输入的符号/信号，不同输入导致状态机产生不同的状态改变； 转换：在一个状态下，根据特定输入，改变到特定状态的过程，就是转换。 所以有限状态机的工作过程，就是从开始状态，根据不同的输入，自动进行状态转换的过程。 上图中的状态机的功能，是检测二进制数是否含有偶数个 0。从图上可以看出，输入只有 1 和 0 两种。从 S1 状态开始，只有输入 0 才会转换到 S2 状态，同样 S2 状态下只有输入 0 才会转换到 S1。所以，二进制数输入完毕，如果满足最终状态，也就是最后停在 S1 状态，那么输入的二进制数就含有偶数个 0。 正则表达式，可以认为是对一组字符串集合的描述。例如 (a+|b)c 对应的字符串集合是： ac bc aac aaac aaaac ... 有限状态机也可以用来描述字符串集合，同样是正则表达式所描述的集合，用有限状态机来表示，可以是这样的： 并且，有限状态机是可以“执行”的，给出如上的状态机之后，就可以用来对输入的字符串进行检测。如果最终匹配，也就意味着输入的字符串和正则表达式 (a+|b)c 匹配。 所以，编程语言中的正则表达式，一般是通过有限状态机来实现。正则表达式匹配字符串的过程，可以分解为： 正则表达式转换为等价的有限状态机； 有限状态机输入字符串执行。 这里再讲一下 NFA 和 DFA 的区别。DFA 是 Deterministic Finite Automaton，确定有限状态机。DFA 可以认为是一种特殊的 NFA，它最大的特点，就是确定性。它的确定性在于，在一个状态下，输入一个符号，一定是转换到确定的状态，没有其他的可能性。 举个例子，对于正则表达式 ab|ac，对应 NFA 可以是这样的： 可以看到，在状态 1 这里，如果输入 a，其实有两种可能，如果后面的符号是 b，那么可以匹配成功，后面符号是 c 也能匹配成功。所以状态机在执行过程中，可能要尝试所有的可能性。在尝试一种可能路径匹配失败后，还要回到之前的状态再尝试其他的路径，这就是“回溯”。 但是 DFA 消除了这种不确定性，所以可以想见，其执行性能应该要比 NFA 更好，因为不需要回溯。 NFA 是可以转换为等价的 DFA 的，也就是说，理论上讲，正则表达式可以用 DFA 来实现，从而获得优于 NFA 的执行性能。但是 NFA 转换 DFA 的过程，会消耗更多资源，甚至最终得到的 DFA 要占用大量存储空间（据有的资料的说法，可能会产生指数级增长）。而且，DFA 相比 NFA，在实现一些正则表达式的特性时会更复杂，成本更高。所以当前的许多编程语言，其正则表达式引擎为 NFA 模式。 /nfa|nfa not/.test('nfa not'); 用上面的正则表达式来测试字符串 nfa not，NFA 引擎在检测满足 nfa 就返回匹配成功的结果了，而 DFA 则会尝试继续查找，也就是说会得到“最长的匹配结果”。 从正则表达式到 NFA 🏈Thompson 算法 Thompson 算法用于转换正则表达式为 NFA，它并非最高效的算法，但是实用，易于理解。 Thompson 算法中使用最基本的两种转换： 普通转换就是在一个状态下，输入字符 a 后转换至另一个状态；epsilon转换则不需要有输入，就从一个状态转换至另一个状态。 正则表达式中的各种运算，可以通过组合上述两种转换实现： 组合转换 RS： 替换转换 R|S： 重复转换 R*： 上面图中的 R、S 是有开始状态和结束状态的 NFA。 以正则表达式 ab|c 为例，包括两个运算： ab 组合 ab 的结果，与 c 替换 这样我们把正则表达式视为一系列输入和运算，进行分解、组合，就可以得到最终的 NFA。 首先，我们要把正则表达式转换为方便记录输入、运算的方式。 🏈正则表达式 → 后缀表达式 后缀表达式是一种方便记录输入、运算的表达式，本身已包含了运算符的优先级，也称为逆波兰表示法（Reverse Polish Notation，简写为 RPN）。 为方便记录运算，我们为正则表达式中的组合运算也创建一个运算符“.”（本文只涉及最简单的正则表达式形式，这里的“.”不是用于匹配任意字符的特殊符号）。 正则表达式 ab|c对应的后缀表达式为 ab.c|。 这样，通过逐个扫描后缀表达式，并识别其中的运算符来执行，就可以对后缀表达式进行求解。对于正则表达式来说，则是在将其变为后缀表达式后，通过“求值”的过程来进一步构建并得到最终的 NFA。 用于创建后缀表达式的是调度场算法。 对于这里的正则表达式处理的场景，算法的大致描述如下： 创建输出队列 output 和运算符栈 ops； 依次读取输入字符串中每一个字符 ch； 如果 ch 是普通字符，追加到 output； 如果 ch 是运算符，只要 ops 栈顶的运算符优先级不低于 ch，依次出栈并追加到 output，最后将 ch 入栈 ops； 如果 ch 是“(”，入栈 ops； 如果 ch 是“)”，只要 ops 栈顶不是“(”，依次出栈并追加到 output； 将 ops 中运算符依次出栈追加到 output； 返回 output。 具体处理过程中，由于原始正则表达式中并没有组合运算符，所以需要自行判断合理的插入位置。 运算符优先级如下（由高到低）： * ? + . | ( 🏈后缀表达式 → NFA 基于后缀表达式创建 NFA，是一个由简单的 NFA 进行不断组合得到复杂 NFA 的过程。 用于表示状态 State 的数据结构为： // State { id: String, type: String, // 'n' - normal, 'e' - epsilon, 'end' symbol: String, // 普通状态对应的输入字符 out: State, // 允许的下一个状态 out1: State // 允许的下一个状态 } 每个状态可以对应最多两个 out 状态，像 a|b|c 的表达式，会被分解为 (a|b)|c，每次运算符“|”都只处理两个（子）表达式。 在构造最终 NFA 过程中，每次会创建 NFA 的片段 Fragment： // Fragment { start: State, out: State } 不管 NFA 片段内部是怎样复杂，它都只有一个入口（开始状态），一个出口（最终状态）。 处理的过程大致为： 创建用于记录 NFA 片段的栈 stack； 依次读取输入的后缀表达式的每个字符 ch； 如果 ch 是运算符，从 stack 出栈所需数目的 NFA 片段，构建新的 NFA 片段后入栈 stack； 如果 ch 是普通字符，创建新的状态，并构建只包含此状态的 NFA 片段入栈 stack； 返回 stack 栈顶的 NFA 片段，即最终结果。 以对组合运算的处理为例： const e2 = stack.pop(); const e1 = stack.pop(); e1.out.out = e2.start; stack.push(new Fragment(e1.start, e2.out)); 从 stack 出栈两个 NFA 片段，然后将其首尾相连后构建新的 NFA 片段再入栈。 NFA 的执行 NFA 的执行过程就是用当前状态来比对字符串的当前字符，如果匹配就继续比对下一个状态和下一个字符，否则匹配失败。 不过由于 NFA 的不确定性，所以可能会同时有多个匹配的状态。 总结 综上，正则表达式的执行，可以通过构建等价的 NFA，然后执行 NFA 来匹配输入的字符串。真实的 JavaScript 中的正则表达式拥有更多的特性，其正则表达式引擎也更加复杂。 简单正则表达式引擎的实现 简单的正则表达式引擎实现 🏈基本的数据结构定义 核心思路是读取正则表达式以后生成对应的NFA，NFA中有边和状态两个结构。边的结构记录了它的起点和终点，同时通过枚举类型记录匹配的其他需求。 //用于处理‘^’字符 enum { NEXCLUDED = false, EXCLUDED = true }; //用于处理预处理类型，0-128以内ASCII字符直接匹配 enum { LCASES=256, UCASES=257, NUM=258, EPSILON=259, ANY=260, WS=261 }; class Edge { public: State *start; State *end; int type; int exclude; Edge(State *s, State *e, int t, bool ex = NEXCLUDED) :start(s), end(e), type(t), exclude(ex) {}; } 状态有预备，成功和失败三种，同时每个状态维护两个向量，向量存储了出边和入边的指针。 enum { READY = -1, SUCCESS = 1, FAIL = 0}; class State { public: int status; std::list&lt;Edge *&gt; InEdges; std::list&lt;Edge *&gt; OutEdges; } NFA 类会存储一个正则表达式，同时存储 NFA 的起点和终点，并使用了两个链表来维护 NFA 的边和状态，同时用一个链表来存储匹配成功的字符串。两个静态的字符串指针用于记录文件和正则表达式字符串的读取状态，静态常量，使得最终函数只会对文件内容和正则表达式扫描一次，避免在匹配成功的字符串中再匹配子串。 char *regex; State *Start; State *End; std::list&lt;Edge *&gt; edgeList; std::list&lt;State *&gt; stateList; std::list&lt;char&gt; matchedChar; static char *regRead; static char *fileRead; } 生成NFA的过程中，通过 currentEnd 和 currentStart 两个指针分别指向当前字符读取完成后生成的最后一个状态和当前字符读取之前的开始状态，维护这两个指针的目的是为了记录 NFA 的生成过程，在处理‘*’、‘+’、‘？’等字符的时候起到了重要的作用。同时我们利用list内置的迭代器对链表进行遍历，这个方式在匹配过程中也用到了。 State *currentEnd, *currentStart; State *alternate; list&lt;Edge *&gt;::iterator itor; 🏈NFA的生成 关键的部分在于匹配字符串时采取的思路，尤其是特殊字符的生成 NFA 的方式，这个不同于课本上最开始的 NFA 生成算法，而是基于读取字符串的过程，同时避免了字符串的回退等，读取一个字符就生成一个对应的边并压入链表中，对‘*’、‘+’，‘？’和特殊符号也是如此，使得处理更加简单的同时避免生成过于冗余的状态，兼顾了时间和空间效率。以下举例说明。 🏈边和状态的生成 边的生成使用 newEdge 函数,需要记录起点和终点，以及类型，同时在生成边以后要用重载的两个 patch函数将状态和边完全连接起来。 void Nfa::newEdge(State * start, State * end, int type, int exclude = NEXCLUDED) { Edge *out = new Edge(start, end, type, exclude); end-&gt;patch(out, end); start-&gt;patch(start, out); edgeList.push_back(out); } 以普通字符的生成和‘.’字符的产生方式为例，他们都是生成一条边和一个新的状态。 case '.': /* any */ currentStart = currentEnd; currentEnd = new State(); newEdge(currentStart, currentEnd, ANY, NEXCLUDED); stateList.push_back(currentEnd); default: currentStart = currentEnd; currentEnd = new State(); newEdge(currentStart, currentEnd, *regRead, NEXCLUDED); stateList.push_back(currentEnd); break; 如下图所示： 接下来的符号处理都假定初始状态如下图所示： 🏈'|'的处理 以 currentStart 指向的状态作为子 NFA 的起点，同时将子 NFA 的终点状态和原 NFA 的终点进行合并。 case '|': // alternate regRead++; currentStart = start; alternate= regex2nfa(regRead, start); currentEnd-&gt;merge(alternate); stateList.remove(alternate); regRead--; 如下图所示： 🏈'?' &amp; '*' &amp; '+'的处理 读取到‘?’只需要在上一条边的基础上继续连接原有的边即可： case '?': // zero or one newEdge(currentStart, currentEnd, EPSILON, NEXCLUDED); break; 读取到‘\\*’后，直接将 currentStart 和 currentEnd 进行合并成环： case '*': // zero or more alternate = currentEnd; currentStart-&gt;merge(alternate); stateList.remove(alternate); currentEnd = currentStart; break; 读取到‘+’后，只需添加若干条边从 currentEnd 状态指向 currentStart 状态的下一个状态即可： case '+': /* one or more */ itor = currentStart-&gt;OutEdges.begin(); for (;itor != currentStart-&gt;OutEdges.end();itor++) newEdge(currentEnd, (*itor)-&gt;end, (*itor)-&gt;type, (*itor)-&gt;exclude); break; 如下图所示： 🏈简单的分组支持 对于中括号和括号进行了一定的支持，括号直接递归调用 NFA 的生成函数，中括号和预定义字符都有其对应的函数进行支持。 🏈NFA匹配 匹配过程采用了递归的方式，step函数调用match函数匹配边和文件字符，匹配成功后即递归调用进入下一个状态。 if (End-&gt;status == SUCCESS) return SUCCESS; for(;itor != current-&gt;OutEdges.end();itor++) { if ((*itor)-&gt;match(fileRead)) { (*itor)-&gt;end-&gt;status = SUCCESS; matchedChar.push_back(*fileRead); ++fileRead; if (step((*itor)-&gt;end)) return SUCCESS; --fileRead; matchedChar.pop_back(); } if ((*itor)-&gt;type == EPSILON &amp;&amp; step((*itor)-&gt;end)) return SUCCESS; } return FAIL; ","link":"https://tdmaker.github.io/faded/post/regular-expression-nfa/"},{"title":"正则表达式——断言","content":" 正则表达式断言 正则表达式大多数结构匹配的文本会出现在最终的匹配结果中，但也有些结构并不真正匹配文本，而只是负责判断某个位置左/右侧是否符合要求，这种结构被称为断言（assertion）。常见的断言有三类： 单词边界、行起始/结束位置、环视。本文主要简单阐述对三类断言的理解。 单词边界 单词边界顾名思义，是指单词字符 (\\w) 能匹配的字符串的左右位置。在 JavaScript、php、Python 2、Ruby 中，单词字符 (\\w) 等同于 [0-9a-zA-Z]，所以在这些语言中，给定一段文本可以用 \\b\\w+\\b 把所有单词提取出来。 例如： ('Love is composed of a single soul inhabiting two bodies.').match(/\\b\\w+\\b/g) return [&quot;Love&quot;, &quot;is&quot;, &quot;composed&quot;, &quot;of&quot;, &quot;a&quot;, &quot;single&quot;, &quot;soul&quot;, &quot;inhabiting&quot;, &quot;two&quot;, &quot;bodies&quot;] 这里值得注意的是，有些单词例如 E-mail 和组合词 I'm 这样的，\\b\\w+\\b 是无法匹配的。如要匹配，可根据需求修改为 \\b['-\\w]\\b。 单词边界记为 \\b，它能匹配的位置：一边是单词字符 \\w，一边是非单词字符 \\W。 与单词边界对应的是非单词边界 \\B，两者关系类似 \\w 与 \\W、\\d 与 \\D。 这里注意，非单词边界（\\B）和单词字符（\\w）是不一样的，因为前者是断言，而后者是普通匹配。 例如： // 式一 String(1234567890).replace(/(?=(\\B)(\\d{3})+$)/g, ',') =&gt; 1,234,567,890 // 式二 String(1234567890).replace(/(?=(\\w)(\\d{3})+$)/g, ',') =&gt; ,123,456,7890 // 附加常用例子，20180911格式化为2018-09-11 '20180911'.replace(/(?=\\B(\\d{2})+$)/g, '-').replace(/-/, '') =&gt;2018-09-11 造成差异的原因就是: 式一中的 \\B 匹配边界（是断言）。第一次匹配时，在 1234567890 中数字 1 的前方时，会环视后方进行肯定断言(?=)：后方必须是满足两个 pattern 才通过。第一个 pattern (\\B)在数字 1 的前方匹配成功；故继续在此位置匹配第二个 pattern (\\d{3})+$，发现 123456789 之后并不是结束符（结束符和开始符也是断言，下文讲述），故匹配失败。开始第二次匹配，从数字 1 和数字 2 的中间开始...最后会匹配成功三个位置：1 和 2 之间、4 和 5 之间、7 和 8 之间，再被,替换，故得到结果。 同理，式二在第一次匹配时，在数字 1 的前方环视后方进行肯定断言：后方必须是满足两个 pattern 才通过。第一个 pattern (\\w) 在数字 1 的前方匹配成功，并将匹配位置移动到 1 和 2 之间；然后继续匹配第二个pattern (\\d{3})+$...第一次匹配成功，故数字 1 前方的断言是成功的，标记该位置...最后得到三个位置：1 前方、3 和 4 之间、6 和 7 之间，再被,替换，故得到结果。 所以 \\B 只是去判断该位置左右是否只有一边有单词字符，另一边不是单词字符，且在匹配成功时，不会导致匹配位置发生改变。说起来算是一种判断吧~ 这种只是匹配某个位置而不是文本的元字符，在正则中也被称为锚点。下文继续介绍常见锚点之二：行起始/结束位置。 行起始/结束位置 ^ 与 $ 分别表示（行）起始位置和（行）结束位置，比如正则表达式 /^lu.*r$/ 只能匹配的 lu 开始并以 r 结束的字符串，例如：luwuer、lu fd --r，不能匹配 nb luwuer、lu fd --rb等。 其实行起始/结束位置断言，常用在正则表达式开启多行模式（Multiline Mode）的情况下。 例如： ('first line\\nsecond line\\nlast line').match(/^\\w+/gm) return [&quot;first&quot;, &quot;second&quot;, &quot;last&quot;] 既然是多行匹配，这里说说如何划分行。 在编辑文本时，敲回车键就向文本输入了行终止符（line terminal），表示结束当前行。这里只需注意，敲入回车时向文本中输入的行终止符在主流平台上是有差别的： Windows 的行终止符是 \\r\\n。 UNIX/Linux/Mac OS 的行终止符是 \\n。 不过正则的行起始/结束位置断言都是可以识别的哈~ 环视 环视是指在某个位置向左/向右看，保证其左/右位置必须出现某类字符（包括单词字符 \\w 和非单词字符\\W），且环视也同上两个断言，只是做一个判断（匹配一个位置，本身不匹配任何字符，但又比上两个断言灵活）。也有人称环视为零宽断言。 环视分为四种： 肯定顺序环视（正向肯定断言）positive-lookahead: ?=pattern； 否定顺序环视（正向否定断言）negative-lookahead: ?!pattern； 肯定逆序环视（反向肯定断言）positive-lookahead: ?&lt;=pattern，js不支持； 否定逆序环视（反向否定断言）negative-lookahead: ?&lt;=pattern，js不支持。 比如我们要匹配一串文字中包含在书名号《》中的书名，如不考虑环视可能需要如下实现： ('三体是刘慈欣创作的系列长篇科幻小说，由《三体》、《三体Ⅱ·黑暗森林》、《三体Ⅲ·死神永生》组成。').match(/《.*?》/g).join(',').replace(/[《》]/g, '').split(',') return [&quot;三体&quot;, &quot;三体Ⅱ·黑暗森林&quot;, &quot;三体Ⅲ·死神永生&quot;] 正则默认是贪婪模式（在整个表达式匹配成功的前提下，尽可能多的匹配），开启非贪婪模式（在整个表达式匹配成功的前提下，尽可能少的匹配）的方法：在贪婪量词 {m,n}、{m,}、?、*、+ 后加上一个 ? 号，例如 +?。 而在使用环视时会更简单： ('三体是刘慈欣创作的系列长篇科幻小说，由《三体》、《三体Ⅱ·黑暗森林》、《三体Ⅲ·死神永生》组成。').replace(/《/g,'\\n').match(/^.*?(?=》)/gm) return [&quot;三体&quot;, &quot;三体Ⅱ·黑暗森林&quot;, &quot;三体Ⅲ·死神永生&quot;] 似乎也没简单多少...当然最主要的原因是js不支持逆序环视啦啦啦 再举例，匹配6位数字构成的字符串： // 无环视 'http://luwuer.com/629212/1234567890'.match(/[^\\d]\\d{6}[^\\d]/g).join('').match(/\\d{6}/g) return [&quot;629212&quot;] // 环视 'http://luwuer.com/629212/1234567890'.match(/(?!\\d).\\d{6}(?!\\d)/g).join('').match(/\\d{6}/g) return [&quot;629212&quot;] 其实环视在js中更多的是与replace函数组合，就像在单词边界一节中最后的例子。 ","link":"https://tdmaker.github.io/faded/post/regular-expression-assert/"},{"title":"jQuery——拓展","content":"😲 extend函数 $.extend(target,[object1],[onjectN]) $.extend([deep],target,object1,[objectN]) var obj1 = { height: 100, width: 100, length: 100, div: { x: 100, y: 100 } }; var obj2 = { height: 200, width: 200, div: { x: 200 } }; $.extend(obj1, obj2); console.log(obj1.height); console.log(obj1.div.y); //result:200,undefined 当使用true参数时， var obj1 = { height: 100, width: 100, length: 100, div: { x: 100, y: 100 } }; var obj2 = { height: 200, width: 200, div: { x: 200 } }; $.extend(true, obj1, obj2); console.log(obj1.height); console.log(obj1.div.y); //result:200,100 拓展jQuery的公共函数 $.extend({ minValue: function(a, b) { return a &gt; b ? a: b } }); var a = prompt(&quot;input a&quot;); var b = prompt(&quot;input b&quot;); console.log($.minValue(a, b)); $.fn.extend() 方法可以创建 jQuery 对象方法 $.fn.extend({ test: function() { alert(&quot;click &quot; + $(this).html() + &quot; this is test function&quot;); } }); $(&quot;#fnExtend&quot;).click(function() { $(this).test(); }); 😲 自定义jQuery函数 🤗 添加新的全局函数 $.clickDiv = function(node) { console.log(node.text() + &quot; click&quot;); }; $(&quot;div&quot;).click(function() { $.clickDiv($(this)); }); 🤗 通过 extend 函数添加全局函数 $.extend({ foo: function() { alert(&quot;this is a new function 'foo()'&quot;); } }); $.foo(); 🤗 使用命名空间 $.myPluin = { ale: function() { alert(&quot;function from myPluin&quot;); } }; $.nextPluin = { ale: function() { alert(&quot;function from nextPluin&quot;); } } $.myPluin.ale(); $.nextPluin.ale(); 😲 自定义选择器 $.myPluin = { ale: function() { alert(&quot;function from myPluin&quot;); } }; $.nextPluin = { ale: function() { alert(&quot;function from nextPluin&quot;); } }; index = -1; //定义全局变量 index jQuery.expr[&quot;:&quot;].le = function(elem, i, match) { // return i&gt;match[3]-0||i==match[3] console.log(index); index++; return index &gt; match[3] - 0; // 返回索引大于 3 的元素 }; $(&quot;p:le(2)&quot;).css(&quot;color&quot;, &quot;red&quot;); // 返回元素索引值大于等于 2 的元素 $.myPluin.ale(); $.nextPluin.ale(); ","link":"https://tdmaker.github.io/faded/post/jquery-extension/"},{"title":"jQuery——选择器","content":"基本选择器 🎼 ID 选择器： // 选中 id 为 myDiv 的元素，速度最快 $(&quot;#myDiv&quot;) 🎼 类选择器： // 选中 class 属性为 red 的所有元素 $(&quot;.red&quot;) 🎼 元素选择器： // 选中所有 div 元素 $(&quot;div&quot;) 🎼 通配符选择器： // 选中所有元素 $(&quot;*&quot;) 🎼 复合选择器： // 选中所有 span 元素和所有 id 为 myDiv 的元素 $(&quot;span,#myDiv&quot;) 层次选择器 🎼 选择器1 选择器2： // 选中 body 内的所有 div 元素 $(&quot;body div&quot;) 🎼 选择器1 &gt; 选择器2： // 选中 body 内的所有直接 div 元素，不查找间接元素 $(&quot;body &gt; div&quot;) 🎼 选择器1 + 选择器2： // 选中 body 内的所有 div 元素 $(&quot;body div&quot;) 🎼 选择器1 ~ 选择器2： // 选中 body 内的所有 div 元素 $(&quot;body div&quot;) 基本过滤选择器 🎼 第一个元素选择器 // 选中第一个 div 元素 $(&quot;div:first&quot;) 🎼 最后一个元素选择器 // 选中最后一个 div 元素 $(&quot;div:last&quot;) 🎼 排除选择器 // 选中 class 不为 red 的所有 div 元素 $(&quot;div:not(.red)&quot;) 🎼 偶数选择器 // 选中索引值为偶数的 div 元素 $(&quot;div:even&quot;) 🎼 奇数选择器 // 选中索引值为奇数的 div 元素 $(&quot;div:odd&quot;) 🎼 索引值选择器 // 选中索引值为 2 的 div 元素 $(&quot;div:eq(2)&quot;) // 选中索引值大于 2 的 div 元素 $(&quot;div:gt(2)&quot;) // 选中索引值小于2的 div 元素 $(&quot;div:lt(2)&quot;) 内容过滤选择器 // 选中所有包含文本 ok 的 div 元素 $(&quot;div:contains(ok)&quot;) // 选中所有为空的 div 元素 $(&quot;div:empty&quot;) // 选中所有包含 class 为 red 的 div 元素 $(&quot;div:has(.red)&quot;) // 选中所有不为空的 div 元素 $(&quot;div:parent&quot;) 可见性过滤选择器 // 选中所有不可见的 div 元素 $(&quot;div:hidden&quot;) // 选中所有可见的 div 元素 $(&quot;div:visible&quot;) 属性过滤选择器 // 选中所有包含属性 title 的 div 元素 $(&quot;div[title]&quot;) // 选中所有属性 title 等于 ok 的 div 元素 $(&quot;div[title=ok]&quot;) // 选中所有属性 title 不等于 ok 的 div 元素 $(&quot;div[title!=ok]&quot;) // 选中所有属性 title 值以 ok 开头的 div 元素 $(&quot;div[title^=ok]&quot;) // 选中所有属性 title 值含有 ok 的 div 元素 $(&quot;div[title*=ok]&quot;) // 选中所有包含属性 id，并且属性 title 值以 ok 开头的 div 元素 $(&quot;div[id][title^=ok]&quot;) 子元素过滤选择器 // 选中所有是第二个子结点的 div 元素 $(&quot;div:nth-child(2)&quot;) // 选中所有是第一个子结点的 div 元素 $(&quot;div:first-child&quot;) // 选中所有是最后一个子结点的 div 元素 $(&quot;div:last-child&quot;) // 选中所有是唯一子结点的 div 元素 $(&quot;div:only-child&quot;) 表单属性过滤选择器 // 选中表单内可用 input $(&quot;#form1 input:enabled&quot;) // 选中表单内不可用 input $(&quot;#form1 input:disabled&quot;) // 选中表单内所有选中的元素 $(&quot;#form1 input:checked&quot;) // 选中下拉列表中选中的元素 $(&quot;select &gt; option:selected&quot;) ","link":"https://tdmaker.github.io/faded/post/jquery-selectors/"},{"title":"正则表达式——匹配","content":"💊(?:pattern) 非获取匹配，匹配 pattern 但不获取匹配结果，不进行存储供以后使用。这在使用或字符“(|)”来组合一个模式的各个部分是很有用。例如“industr(?:y|ies)”就是一个比“industry|industries”更简略的表达式。 💊 (?=pattern) 非获取匹配，正向肯定预查，在任何匹配 pattern 的字符串开始处匹配查找字符串，该匹配不需要获取供以后使用。例如，“Windows(?=95|98|NT|2000)”能匹配“Windows2000”中的“Windows”，但不能匹配“Windows3.1”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 💊 (?!pattern) 非获取匹配，正向否定预查，在任何不匹配 pattern 的字符串开始处匹配查找字符串，该匹配不需要获取供以后使用。例如“Windows(?!95|98|NT|2000)”能匹配“Windows3.1”中的“Windows”，但不能匹配“Windows2000”中的“Windows”。 💊 (?&lt;=pattern) 非获取匹配，反向肯定预查，与正向肯定预查类似，只是方向相反。例如，“(?&lt;=95|98|NT|2000)Windows”能匹配“2000Windows”中的“Windows”，但不能匹配“3.1Windows”中的“Windows”。 💊 (?&lt;!pattern) 非获取匹配，反向否定预查，与正向否定预查类似，只是方向相反。例如“(?&lt;!95|98|NT|2000)Windows”能匹配“3.1Windows”中的“Windows”，但不能匹配“2000Windows”中的“Windows”。这个地方不正确，有问题 ","link":"https://tdmaker.github.io/faded/post/regular-expression-pattern-matching/"},{"title":"设计师网站","content":"设计师导航 网站 网址 全球100+知名设计网站 http://www.bigbigwork.com/nav/6.html CND设计网址导航 - 优秀设计网站排名大全 http://wz.cndesign.com/ 拍信 https://www.paixin.com/ 我图网 https://www.ooopic.com/ 包图网 https://ibaotu.com/ 素材天下 http://www.sucaitianxia.net/ 素材中国 http://www.sccnn.com/ 站长素材 http://sc.chinaz.com/ 红动中国 https://www.redocn.com/ 千库网 https://588ku.com/ 觅元素 http://www.51yuansu.com/ unDraw https://undraw.co/ DrawKit https://www.drawkit.io/ pngtree https://pngtree.com/ VCG https://www.vcg.com/ Textures for 3D, graphic design and Photoshop! https://www.textures.com/ 無料DTP素材 【素材ページ 】食材・料理の著作権フリー写真 http://www.sozai-page.com/index.html 免费模板网 http://www.wangjie.org/ Landing page templates for startups https://cruip.com/ Avataaars Generator https://getavataaars.com/?avatarStyle=Circle 中国色 http://zhongguose.com/ 完美对称无缝平铺背景图底纹素材 - 图鱼 https://www.hituyu.com/ 花瓣网_陪你做生活的设计师（创意灵感天堂，搜索、发现设计灵感、设计素材） https://huaban.com/ 站酷 (ZCOOL) - 设计师互动平台 - 打开站酷，发现更好的设计！ https://www.zcool.com.cn/ UI中国用户体验设计平台 https://www.ui.cn/ 68Design - 找兼职设计师就上68Design - 【设计师接单平台】 https://www.68design.net/ Flat Design Inspiration - Flat UI https://flatui.com/ UI Movement - The best UI design inspiration, every day https://uimovement.com/ Collect UI - Daily inspiration collected from daily ui archive and beyond. Based on Dribbble shots, hand picked, updating daily. http://www.collectui.com/ siteInspire - Web Design Inspiration https://www.siteinspire.com/ Dribbble - Discover the World’s Top Designers &amp; Creative Professionals https://dribbble.com/ Blocs - Fast, easy to use and powerful visual web design tool, that lets you create responsive websites without writing code. https://blocsapp.com/ UI Design Resources, UI Kits, Wireframes, Icons and More - UI8 https://ui8.net/ UI-Patterns.com https://ui-patterns.com/ 学UI网-UI设计师导航网，最专业的UI设计网站 http://hao.xueui.cn/ 优设导航 - 学设计从这里开始！ http://hao.uisdc.com/ 饭团导航 精选设计师实用工具导航 hao.psefan.com http://hao.psefan.com/ 设计导航 - 精选最好的设计网站大全 https://hao.shejidaren.com/ 优波设计 - 设计师必备网址导航 ubuuk.com https://www.ubuuk.com/ 设计订阅 - 腾讯设计导航 https://idesign.qq.com/#!index/feed http://www.bigbigwork.com/nav/6.html http://www.foolo.cn/ 工业设计网站导航 | 设计癖 http://hao.shejipi.com/ 46设计导航_设计网站大全_46design.com http://www.46design.com/2019/ UI设计师导航网 - 优阁 http://so.uigreat.com/ Canva在线平面设计软件_免费设计模板素材和海量正版图片 - Canva中文官网 https://www.canva.cn/ 创客贴_平面设计作图神器_免费设计模板_在线稿定设计印刷 https://www.chuangkit.com/ 轻量级在线平面设计工具 - 图帮主 https://www.tubangzhu.com/ 图怪兽作图神器-在线图片编辑器-PS图片制作-搞定平面设计不求人 https://818ps.com/ Fotor在线设计工具_免费设计素材和模板_在线平面设计网站 https://www.fotor.com.cn/ Presentation Software Online Presentation Tools 设计癖 | 关注设计癖 提升幸福感 http://www.shejipi.com/ xiaopiu-产品原型设计工具与团队实时协作平台 https://www.xiaopiu.com/ 燃设计-共享全球好设计_软装素材分享_软装设计灵感图库 http://www.ransheji.com/ Themes - macOS - Human Interface Guidelines - Apple Developer https://developer.apple.com/design/human-interface-guidelines/macos/overview/themes/ Overview - Atlassian Design https://atlassian.design/guidelines/product/overview 介绍 - Ant Design https://ant.design/docs/spec/introduce-cn WeUI https://weui.io/ Documentation - Materialize https://materializecss.com/ Styleguide https://www.yelp.com/styleguide/mobile 优优灵感-设计师灵感展现与启发-优优教程网 https://uiiiuiii.com/inspiration Crello — Free Graphic Design Software Create Images Online Tool 优设导航 - 学设计从这里开始！ https://hao.uisdc.com/ Creative Mass https://creativemass.cn/#/ 设计师之家 https://www.51sjsj.com/ Design Seeds for all who ♥ color The Nordnet Brand - Nordnet Brand https://brand.nordnet.se/ STUDIO Design to live website in one click. 图片素材 网站 网址 Unsplash https://unsplash.com/ Pexels https://www.pexels.com/zh-cn/ Gratisography https://gratisography.com/ Beautiful free stock photos https://stocksnap.io/ Foodiesfeed https://www.foodiesfeed.com/ Freephotos https://freephotos.cc/zh Uniquely free photos. https://www.reshot.com/ Free images for creatives, by creatives https://morguefile.com/quest Illustration Gallery https://www.manypixels.co/gallery/ FREE ILLUSTRATIONS https://lukaszadam.com/illustrations 沙沙野 https://www.ssyer.com/ 图虫 https://tuchong.com/ 摄图网 https://699pic.com/ 7MX——Home Business Advertising Ideas https://7mx.com/ 图品汇 https://www.88tph.com/ Free Photos for bloggers and creatives! http://photopin.com/ 花瓣美素 http://www.meisupic.com/ PAKUTASO https://www.pakutaso.com/ 懒人图库 http://www.lanrentuku.com/ SEARCH FOR CONTENT TO REUSE https://search.creativecommons.org/ Free Stock Photos by Canva https://www.canva.com/photos/free/ Creative Briefs. Request for photos https://morguefile.com/quest Illustration Gallery https://www.manypixels.co/gallery/ ImageFinder https://imagefinder.co/ 泼辣有图 http://www.polayoutu.com/collections visualhunt https://visualhunt.com/ foter https://foter.com/ Free high resolution photography - Life of Pix - Home https://www.lifeofpix.com/ New Old Stock https://nos.twnsnd.co/ 千图网 https://www.58pic.com/ Hand-picked free photos for your inspiration - Magdeleine https://magdeleine.co/ 昵图网 http://www.nipic.com/ photock https://www.photock.jp/ 免费正版高清图片素材库 https://pixabay.com/zh/ piqsels https://www.piqsels.com/zh DesignersPics http://www.designerspics.com/ freeimages https://cn.freeimages.com/ StreetWill http://www.streetwill.co/ Discover and share the world's best photos https://web.500px.com/ FREE TRAVEL PHOTOS https://www.bucketlistly.blog/photos Free Stock Photos For Commercial Use. https://www.splitshire.com/splitshire-free-stock-photos/ BURST https://burst.shopify.com/ FOCA https://focastock.com/ jay mantri https://jaymantri.com/#= LET'S FIND THE PERFECT PHOTO FOR YOU https://kaboompics.com/ A curated collection of free web design resources, all for commercial use. http://imcreator.com/free Zoommy https://zoommyapp.com/ STOKPIC - Free Stock Photos For Commercial Use https://stokpic.com/ Cupcake http://cupcake.nilssonlee.se/ Folkert Gorter Superfamous Images https://images.superfamous.com/ PICGRAPHY https://picography.co/ Free stock illustrations, Beautiful Free Art - Mixkit https://mixkit.co/free-stock-art/ Free Stock Photos https://photo-ac.com/ scrolller https://scrolller.com/art JOHN KRAUS PHOTOS https://www.johnkrausphotos.com/Portfolio/ Picrew https://picrew.me/ GENERATED FACES https://generated.photos/faces 用大作，不用翻墙和VPN秒看pixabay上的设计 http://www.bigbigwork.com/pixabay.html GIF and PNG and icon and PSD and LOGO and Vector and illustrations 网站 网址 With Stock Animated GIFs Crafted for Commercial Use https://cliply.co/ SOOGIF，找动图做动图.gif https://www.soogif.com/ Search all the GIFs and Stickers https://giphy.com/ free PNGs https://www.freepngs.com/search-pngs CLEAN PNG https://www.cleanpng.com/ easyicon https://www.easyicon.net/ Icons for everything https://thenounproject.com/ Instant Logo Search http://instantlogosearch.com/ Logo Maker - Create Your Own Logo, It's Free! - FreeLogoDesign https://www.freelogodesign.org/ 365psd https://cn.365psd.com/free-psd Download Free Vectors, Clipart Graphics, Vector Art &amp; Design Templates https://www.vecteezy.com/ freepik https://www.freepik.com/ humaaans https://www.humaaans.com/ Free Vector Illustrations to Class up Your Project https://icons8.com/ouch IRA Design - Build your own amazing illustrations @ Creative Tim https://iradesign.io/ absurd illustrations that make sense https://absurd.design/ Illustration Gallery by ManyPixels Open-Source Editable Illustrations Free Vectors, Stock Photos &amp; PSD Downloads Freepik 视频素材 网站 网址 Thousands of Free High-Resolution CC0 Photos and Videos https://isorepublic.com/ NASA Image and Video Library https://images.nasa.gov/ COVERR - Beautiful Free Stock Video Footage https://coverr.co/ Golden Wolf https://goldenwolf.tv/ 场库 https://www.vmovier.com/ Free stock videos · Pexels Videos https://www.pexels.com/videos/ 天空之城 https://www.skypixel.com/ Distill: Free HD Stock Video &amp; HD Video Clips https://wedistill.io/ Free Video Footage - Best Free Backgrounds Stock Video Footage https://www.free-video-footage.com/ Free Motion Backgrounds MP4, MOV video backgrounds for FREE! Free Stock Video Footage HD 4K Download Motion Graphics https://www.videvo.net/ Free Stock Footage Videos, 4k After Effects Templates and More! https://www.videezy.com/ Free 4K Stock Video | Stock Footage for Free – {Dareful} Completely Free 4K Stock Video https://www.dareful.com/ Free Stock Video Footage HD Royalty-Free Videos Download https://mazwai.com/#/ iTunes Movie Trailers https://trailers.apple.com/ Mixkit - Awesome free assets for your next video project https://mixkit.co/ XStockvideo http://www.xstockvideo.com/ Fonts and icons 网站 网址 IconMoon https://icomoon.io/ iconmonstr https://iconmonstr.com/ Zwicon – Icon set https://www.zwicon.com/cheatsheet.html Find Similar Icons http://compute.vision/nouns/index.html iconSweets — DesignBombs https://designbombs.com/iconsweets/ iconfont https://www.iconfont.cn/ 100font.com - 免版权字体下载、免费商用字体下载网站 https://www.100font.com/ 造字工房 https://www.makefont.com/ 方正字库 http://www.foundertype.com/ 汉仪字库-用心绽放文字之美 http://www.hanyi.com.cn/ Font-To-Width http://font-to-width.com/ ","link":"https://tdmaker.github.io/faded/post/su-cai-wang-zhan/"},{"title":"特色搜索","content":"网盘搜索 网站 网址 盘搜搜 https://www.pansoso.com/ 如风搜 http://www.rufengso.net/ 6miu百度云搜索 http://baiduyun.6miu.com/ 57分享百度云 https://www.57fx.com/user-drnew-daren/ 小不点搜索 https://www.xiaoso.net/ 特色搜索 网站 网址 龙轩搜索 http://ilxdh.com/ 虫部落搜索 https://www.chongbuluo.com/ neets搜索站 https://neets.cc/ 西林街搜索 https://xilinjie.cc/ 茶杯狐 https://www.cupfox.com/ 疯狂影视搜索 http://ifkdy.com/ AnywhereAnything http://lackar.com/aa/ 源代码搜索 https://publicwww.com/ 变量名搜索 https://unbug.github.io/codelf/ 比菲尔德学术搜索 https://www.base-search.net/ 吉他尤克里里谱搜索 https://sopu.52cmajor.com/ Classcentral在线课程搜索 https://www.classcentral.com/ Coursade在线课程搜索 http://www.coursade.com/ Chinese Etymology 字源 https://hanziyuan.net/ 汉典 https://www.zdic.net/ 新华字典 https://zidian.911cha.com/ 导航站 网站 网址 创造狮导航 http://chuangzaoshi.com/ 导航湾 https://www.daohangwan.com/ 好用好玩导航 http://www.haoyonghaowan.com/ 比格张 https://bigezhang.com/ Web前端导航 http://nav.web-hub.cn/ 阿猫阿狗导航 https://dh.woshipm.com/ BTMoo导航 https://www.btmoo.net/ ","link":"https://tdmaker.github.io/faded/post/te-se-sou-suo/"},{"title":"电子书下载","content":"电子书下载 网站 网址 Baen free library https://www.baen.com/allbooks/category/index/id/2012 智奇搜书 https://www.zqbook.top/ 云海电子图书馆 http://www.pdfbook.cn/ 必看网 https://www.biikan.com/ bookboon https://bookboon.com/en Free-Ebooks https://www.free-ebooks.net/ ZLibrary https://b-ok.org/ 书格 https://new.shuge.org/ Academia https://www.academia.edu/ 图灵社区 https://www.ituring.com.cn/ 书伴 https://bookfere.com/ 好读 http://haodoo.net/ ePUBee http://cn.epubee.com/books/ 三秋书屋 https://www.d4j.cn/ SoBooks https://sobooks.cc/ i-Book.in https://book.tstrs.me/ WOW! eBook https://www.wowebook.org/ 计算机书籍控 http://bestcbooks.com/ 鸠摩搜索 https://www.jiumodiary.com/ Library Genesis http://gen.lib.rus.ec/ Library Genesis 2M http://libgen.io/ 免费的计算机编程类中文书籍 https://github.com/justjavac/free-programming-books-zh_CN 国立国会图书馆 https://dl.ndl.go.jp/ ZLibrary https://b-ok.cc/s/ 电子书转换 网站 网址 在线电子书转换器 http://cn.epubee.com/ 文本或 eBook 转换为 Mobi 格式 https://ebook.online-convert.com/convert-to-mobi ","link":"https://tdmaker.github.io/faded/post/ebooks-download/"},{"title":"正则表达式——银行卡号","content":"记录中国主要银行发行的银行卡号的正则表达式 多种银行卡正则 var bankcardList = [{ bankName: &quot;中国邮政储蓄银行&quot;, bankCode: &quot;PSBC&quot;, patterns: [{ reg: /^(621096|621098|622150|622151|622181|622188|622199|955100|621095|620062|621285|621798|621799|621797|620529|621622|621599|621674|623218|623219)\\d{13}$/g, cardType: &quot;DC&quot; }, { reg: /^(62215049|62215050|62215051|62218850|62218851|62218849)\\d{11}$/g, cardType: &quot;DC&quot; }, { reg: /^(622812|622810|622811|628310|625919)\\d{10}$/g, cardType: &quot;CC&quot; }] }, { bankName: &quot;中国工商银行&quot;, bankCode: &quot;ICBC&quot;, patterns: [{ reg: /^(620200|620302|620402|620403|620404|620406|620407|620409|620410|620411|620412|620502|620503|620405|620408|620512|620602|620604|620607|620611|620612|620704|620706|620707|620708|620709|620710|620609|620712|620713|620714|620802|620711|620904|620905|621001|620902|621103|621105|621106|621107|621102|621203|621204|621205|621206|621207|621208|621209|621210|621302|621303|621202|621305|621306|621307|621309|621311|621313|621211|621315|621304|621402|621404|621405|621406|621407|621408|621409|621410|621502|621317|621511|621602|621603|621604|621605|621608|621609|621610|621611|621612|621613|621614|621615|621616|621617|621607|621606|621804|621807|621813|621814|621817|621901|621904|621905|621906|621907|621908|621909|621910|621911|621912|621913|621915|622002|621903|622004|622005|622006|622007|622008|622010|622011|622012|621914|622015|622016|622003|622018|622019|622020|622102|622103|622104|622105|622013|622111|622114|622017|622110|622303|622304|622305|622306|622307|622308|622309|622314|622315|622317|622302|622402|622403|622404|622313|622504|622505|622509|622513|622517|622502|622604|622605|622606|622510|622703|622715|622806|622902|622903|622706|623002|623006|623008|623011|623012|622904|623015|623100|623202|623301|623400|623500|623602|623803|623901|623014|624100|624200|624301|624402|623700|624000)\\d{12}$/g, cardType: &quot;DC&quot; }, { reg: /^(622200|622202|622203|622208|621225|620058|621281|900000|621558|621559|621722|621723|620086|621226|621618|620516|621227|621288|621721|900010|623062|621670|621720|621379|621240|621724|621762|621414|621375|622926|622927|622928|622929|622930|622931|621733|621732|621372|621369|621763)\\d{13}$/g, cardType: &quot;DC&quot; }, { reg: /^(402791|427028|427038|548259|621376|621423|621428|621434|621761|621749|621300|621378|622944|622949|621371|621730|621734|621433|621370|621764|621464|621765|621750|621377|621367|621374|621731|621781)\\d{10}$/g, cardType: &quot;DC&quot; }, { reg: /^(9558)\\d{15}$/g, cardType: &quot;DC&quot; }, { reg: /^(370246|370248|370249|370247|370267|374738|374739)\\d{9}$/g, cardType: &quot;CC&quot; }, { reg: /^(427010|427018|427019|427020|427029|427030|427039|438125|438126|451804|451810|451811|458071|489734|489735|489736|510529|427062|524091|427064|530970|530990|558360|524047|525498|622230|622231|622232|622233|622234|622235|622237|622239|622240|622245|622238|451804|451810|451811|458071|628288|628286|622206|526836|513685|543098|458441|622246|544210|548943|356879|356880|356881|356882|528856|625330|625331|625332|622236|524374|550213|625929|625927|625939|625987|625930|625114|622159|625021|625022|625932|622889|625900|625915|625916|622171|625931|625113|625928|625914|625986|625925|625921|625926|625942|622158|625917|625922|625934|625933|625920|625924|625017|625018|625019)\\d{10}$/g, cardType: &quot;CC&quot; }, { reg: /^(45806|53098|45806|53098)\\d{11}$/g, cardType: &quot;CC&quot; }, { reg: /^(622210|622211|622212|622213|622214|622220|622223|622225|622229|622215|622224)\\d{10}$/g, cardType: &quot;SCC&quot; }, { reg: /^(620054|620142|620184|620030|620050|620143|620149|620124|620183|620094|620186|620148|620185)\\d{10}$/g, cardType: &quot;PC&quot; }, { reg: /^(620114|620187|620046)\\d{13}$/g, cardType: &quot;PC&quot; }] }, { bankName: &quot;中国农业银行&quot;, bankCode: &quot;ABC&quot;, patterns: [{ reg: /^(622841|622824|622826|622848|620059|621282|622828|622823|621336|621619|622821|622822|622825|622827|622845|622849|623018|623206|621671|622840|622843|622844|622846|622847|620501)\\d{13}$/g, cardType: &quot;DC&quot; }, { reg: /^(95595|95596|95597|95598|95599)\\d{14}$/g, cardType: &quot;DC&quot; }, { reg: /^(103)\\d{16}$/g, cardType: &quot;DC&quot; }, { reg: /^(403361|404117|404118|404119|404120|404121|463758|519412|519413|520082|520083|552599|558730|514027|622836|622837|628268|625996|625998|625997|622838|625336|625826|625827|544243|548478|628269)\\d{10}$/g, cardType: &quot;CC&quot; }, { reg: /^(622820|622830)\\d{10}$/g, cardType: &quot;SCC&quot; }] }, { bankName: &quot;中国银行&quot;, bankCode: &quot;BOC&quot;, patterns: [{ reg: /^(621660|621661|621662|621663|621665|621667|621668|621669|621666|456351|601382|621256|621212|621283|620061|621725|621330|621331|621332|621333|621297|621568|621569|621672|623208|621620|621756|621757|621758|621759|621785|621786|621787|621788|621789|621790|622273|622274|622771|622772|622770|621741|621041)\\d{13}$/g, cardType: &quot;DC&quot; }, { reg: /^(621293|621294|621342|621343|621364|621394|621648|621248|621215|621249|621231|621638|621334|621395|623040|622348)\\d{10}$/g, cardType: &quot;DC&quot; }, { reg: /^(625908|625910|625909|356833|356835|409665|409666|409668|409669|409670|409671|409672|512315|512316|512411|512412|514957|409667|438088|552742|553131|514958|622760|628388|518377|622788|628313|628312|622750|622751|625145|622479|622480|622789|625140|622346|622347)\\d{10}$/g, cardType: &quot;CC&quot; }, { reg: /^(518378|518379|518474|518475|518476|524865|525745|525746|547766|558868|622752|622753|622755|524864|622757|622758|622759|622761|622762|622763|622756|622754|622764|622765|558869|625905|625906|625907|625333)\\d{10}$/g, cardType: &quot;SCC&quot; }, { reg: /^(53591|49102|377677)\\d{11}$/g, cardType: &quot;SCC&quot; }, { reg: /^(620514|620025|620026|620210|620211|620019|620035|620202|620203|620048|620515|920000)\\d{10}$/g, cardType: &quot;PC&quot; }, { reg: /^(620040|620531|620513|921000|620038)\\d{13}$/g, cardType: &quot;PC&quot; }] }, { bankName: &quot;中国建设银行&quot;, bankCode: &quot;CCB&quot;, patterns: [{ reg: /^(621284|436742|589970|620060|621081|621467|621598|621621|621700|622280|622700|623211|623668)\\d{13}$/g, cardType: &quot;DC&quot; }, { reg: /^(421349|434061|434062|524094|526410|552245|621080|621082|621466|621488|621499|622966|622988|622382|621487|621083|621084|620107)\\d{10}$/g, cardType: &quot;DC&quot; }, { reg: /^(436742193|622280193)\\d{10}$/g, cardType: &quot;DC&quot; }, { reg: /^(553242)\\d{12}$/g, cardType: &quot;CC&quot; }, { reg: /^(625362|625363|628316|628317|356896|356899|356895|436718|436738|436745|436748|489592|531693|532450|532458|544887|552801|557080|558895|559051|622166|622168|622708|625964|625965|625966|628266|628366|622381|622675|622676|622677)\\d{10}$/g, cardType: &quot;CC&quot; }, { reg: /^(5453242|5491031|5544033)\\d{11}$/g, cardType: &quot;CC&quot; }, { reg: /^(622725|622728|436728|453242|491031|544033|622707|625955|625956)\\d{10}$/g, cardType: &quot;SCC&quot; }, { reg: /^(53242|53243)\\d{11}$/g, cardType: &quot;SCC&quot; }] }, { bankName: &quot;中国交通银行&quot;, bankCode: &quot;COMM&quot;, patterns: [{ reg: /^(622261|622260|622262|621002|621069|621436|621335)\\d{13}$/g, cardType: &quot;DC&quot; }, { reg: /^(620013)\\d{10}$/g, cardType: &quot;DC&quot; }, { reg: /^(405512|601428|405512|601428|622258|622259|405512|601428)\\d{11}$/g, cardType: &quot;DC&quot; }, { reg: /^(49104|53783)\\d{11}$/g, cardType: &quot;CC&quot; }, { reg: /^(434910|458123|458124|520169|522964|552853|622250|622251|521899|622253|622656|628216|622252|955590|955591|955592|955593|628218|625028|625029)\\d{10}$/g, cardType: &quot;CC&quot; }, { reg: /^(622254|622255|622256|622257|622284)\\d{10}$/g, cardType: &quot;SCC&quot; }, { reg: /^(620021|620521)\\d{13}$/g, cardType: &quot;PC&quot; }] }, { bankName: &quot;招商银行&quot;, bankCode: &quot;CMB&quot;, patterns: [{ reg: /^(402658|410062|468203|512425|524011|622580|622588|622598|622609|95555|621286|621483|621485|621486|621299)\\d{10}$/g, cardType: &quot;DC&quot; }, { reg: /^(690755)\\d{9}$/g, cardType: &quot;DC&quot; }, { reg: /^(690755)\\d{12}$/g, cardType: &quot;DC&quot; }, { reg: /^(356885|356886|356887|356888|356890|439188|439227|479228|479229|521302|356889|545620|545621|545947|545948|552534|552587|622575|622576|622577|622578|622579|545619|622581|622582|545623|628290|439225|518710|518718|628362|439226|628262|625802|625803)\\d{10}$/g, cardType: &quot;CC&quot; }, { reg: /^(370285|370286|370287|370289)\\d{9}$/g, cardType: &quot;CC&quot; }, { reg: /^(620520)\\d{13}$/g, cardType: &quot;PC&quot; }] }, { bankName: &quot;中国民生银行&quot;, bankCode: &quot;CMBC&quot;, patterns: [{ reg: /^(622615|622616|622618|622622|622617|622619|415599|421393|421865|427570|427571|472067|472068|622620)\\d{10}$/g, cardType: &quot;DC&quot; }, { reg: /^(545392|545393|545431|545447|356859|356857|407405|421869|421870|421871|512466|356856|528948|552288|622600|622601|622602|517636|622621|628258|556610|622603|464580|464581|523952|545217|553161|356858|622623|625912|625913|625911)\\d{10}$/g, cardType: &quot;CC&quot; }, { reg: /^(377155|377152|377153|377158)\\d{9}$/g, cardType: &quot;CC&quot; }] }, { bankName: &quot;中国光大银行&quot;, bankCode: &quot;CEB&quot;, patterns: [{ reg: /^(303)\\d{13}$/g, cardType: &quot;DC&quot; }, { reg: /^(90030)\\d{11}$/g, cardType: &quot;DC&quot; }, { reg: /^(620535)\\d{13}$/g, cardType: &quot;DC&quot; }, { reg: /^(620085|622660|622662|622663|622664|622665|622666|622667|622669|622670|622671|622672|622668|622661|622674|622673|620518|621489|621492)\\d{10}$/g, cardType: &quot;DC&quot; }, { reg: /^(356837|356838|486497|622657|622685|622659|622687|625978|625980|625981|625979|356839|356840|406252|406254|425862|481699|524090|543159|622161|622570|622650|622655|622658|625975|625977|628201|628202|625339|625976)\\d{10}$/g, cardType: &quot;CC&quot; }] }, { bankName: &quot;中信银行&quot;, bankCode: &quot;CITIC&quot;, patterns: [{ reg: /^(433670|433680|442729|442730|620082|622690|622691|622692|622696|622698|622998|622999|433671|968807|968808|968809|621771|621767|621768|621770|621772|621773|622453|622456)\\d{10}$/g, cardType: &quot;DC&quot; }, { reg: /^(622459)\\d{11}$/g, cardType: &quot;DC&quot; }, { reg: /^(376968|376969|376966)\\d{9}$/g, cardType: &quot;CC&quot; }, { reg: /^(400360|403391|403392|404158|404159|404171|404172|404173|404174|404157|433667|433668|433669|514906|403393|520108|433666|558916|622678|622679|622680|622688|622689|628206|556617|628209|518212|628208|356390|356391|356392|622916|622918|622919)\\d{10}$/g, cardType: &quot;CC&quot; }] }, { bankName: &quot;华夏银行&quot;, bankCode: &quot;HXBANK&quot;, patterns: [{ reg: /^(622630|622631|622632|622633|999999|621222|623020|623021|623022|623023)\\d{10}$/g, cardType: &quot;DC&quot; }, { reg: /^(523959|528709|539867|539868|622637|622638|628318|528708|622636|625967|625968|625969)\\d{10}$/g, cardType: &quot;CC&quot; }] }, { bankName: &quot;深发/平安银行&quot;, bankCode: &quot;SPABANK&quot;, patterns: [{ reg: /^(621626|623058)\\d{13}$/g, cardType: &quot;DC&quot; }, { reg: /^(602907|622986|622989|622298|627069|627068|627066|627067|412963|415752|415753|622535|622536|622538|622539|998800|412962|622983)\\d{10}$/g, cardType: &quot;DC&quot; }, { reg: /^(531659|622157|528020|622155|622156|526855|356869|356868|625360|625361|628296|435744|435745|483536|622525|622526|998801|998802)\\d{10}$/g, cardType: &quot;CC&quot; }, { reg: /^(620010)\\d{10}$/g, cardType: &quot;PC&quot; }] }, { bankName: &quot;兴业银行&quot;, bankCode: &quot;CIB&quot;, patterns: [{ reg: /^(438589)\\d{12}$/g, cardType: &quot;DC&quot; }, { reg: /^(90592)\\d{11}$/g, cardType: &quot;DC&quot; }, { reg: /^(966666|622909|438588|622908)\\d{12}$/g, cardType: &quot;DC&quot; }, { reg: /^(461982|486493|486494|486861|523036|451289|527414|528057|622901|622902|622922|628212|451290|524070|625084|625085|625086|625087|548738|549633|552398|625082|625083|625960|625961|625962|625963)\\d{10}$/g, cardType: &quot;CC&quot; }, { reg: /^(620010)\\d{10}$/g, cardType: &quot;PC&quot; }] }, { bankName: &quot;上海银行&quot;, bankCode: &quot;SHBANK&quot;, patterns: [{ reg: /^(621050|622172|622985|622987|620522|622267|622278|622279|622468|622892|940021)\\d{12}$/g, cardType: &quot;DC&quot; }, { reg: /^(438600)\\d{10}$/g, cardType: &quot;DC&quot; }, { reg: /^(356827|356828|356830|402673|402674|486466|519498|520131|524031|548838|622148|622149|622268|356829|622300|628230|622269|625099|625953)\\d{10}$/g, cardType: &quot;CC&quot; }] }, { bankName: &quot;浦东发展银行&quot;, bankCode: &quot;SPDB&quot;, patterns: [{ reg: /^(622516|622517|622518|622521|622522|622523|984301|984303|621352|621793|621795|621796|621351|621390|621792|621791)\\d{10}$/g, cardType: &quot;DC&quot; }, { reg: /^(84301|84336|84373|84385|84390|87000|87010|87030|87040|84380|84361|87050|84342)\\d{11}$/g, cardType: &quot;DC&quot; }, { reg: /^(356851|356852|404738|404739|456418|498451|515672|356850|517650|525998|622177|622277|628222|622500|628221|622176|622276|622228|625957|625958|625993|625831)\\d{10}$/g, cardType: &quot;CC&quot; }, { reg: /^(622520|622519)\\d{10}$/g, cardType: &quot;SCC&quot; }, { reg: /^(620530)\\d{13}$/g, cardType: &quot;PC&quot; }] }, { bankName: &quot;广发银行&quot;, bankCode: &quot;GDB&quot;, patterns: [{ reg: /^(622516|622517|622518|622521|622522|622523|984301|984303|621352|621793|621795|621796|621351|621390|621792|621791)\\d{10}$/g, cardType: &quot;DC&quot; }, { reg: /^(622568|6858001|6858009|621462)\\d{13}$/g, cardType: &quot;DC&quot; }, { reg: /^(9111)\\d{15}$/g, cardType: &quot;DC&quot; }, { reg: /^(406365|406366|428911|436768|436769|436770|487013|491032|491033|491034|491035|491036|491037|491038|436771|518364|520152|520382|541709|541710|548844|552794|493427|622555|622556|622557|622558|622559|622560|528931|558894|625072|625071|628260|628259|625805|625806|625807|625808|625809|625810)\\d{10}$/g, cardType: &quot;CC&quot; }, { reg: /^(685800|6858000)\\d{13}$/g, cardType: &quot;CC&quot; }] }, { bankName: &quot;渤海银行&quot;, bankCode: &quot;BOHAIB&quot;, patterns: [{ reg: /^(621268|622684|622884|621453)\\d{10}$/g, cardType: &quot;DC&quot; }] }, { bankName: &quot;广州银行&quot;, bankCode: &quot;GCB&quot;, patterns: [{ reg: /^(603445|622467|940016|621463)\\d{13}$/g, cardType: &quot;DC&quot; }] }, { bankName: &quot;金华银行&quot;, bankCode: &quot;JHBANK&quot;, patterns: [{ reg: /^(622449|940051)\\d{10}$/g, cardType: &quot;DC&quot; }, { reg: /^(622450|628204)\\d{10}$/g, cardType: &quot;CC&quot; }] }, { bankName: &quot;温州银行&quot;, bankCode: &quot;WZCB&quot;, patterns: [{ reg: /^(621977)\\d{10}$/g, cardType: &quot;DC&quot; }, { reg: /^(622868|622899|628255)\\d{10}$/g, cardType: &quot;CC&quot; }] }, { bankName: &quot;徽商银行&quot;, bankCode: &quot;HSBANK&quot;, patterns: [{ reg: /^(622877|622879|621775|623203)\\d{13}$/g, cardType: &quot;DC&quot; }, { reg: /^(603601|622137|622327|622340|622366)\\d{11}$/g, cardType: &quot;DC&quot; }, { reg: /^(628251|622651|625828)\\d{10}$/g, cardType: &quot;CC&quot; }] }, { bankName: &quot;江苏银行&quot;, bankCode: &quot;JSBANK&quot;, patterns: [{ reg: /^(621076|622173|622131|621579|622876)\\d{13}$/g, cardType: &quot;DC&quot; }, { reg: /^(504923|622422|622447|940076)\\d{10}$/g, cardType: &quot;DC&quot; }, { reg: /^(628210|622283|625902)\\d{10}$/g, cardType: &quot;CC&quot; }] }, { bankName: &quot;南京银行&quot;, bankCode: &quot;NJCB&quot;, patterns: [{ reg: /^(621777|622305|621259)\\d{10}$/g, cardType: &quot;DC&quot; }, { reg: /^(622303|628242|622595|622596)\\d{10}$/g, cardType: &quot;CC&quot; }] }, { bankName: &quot;宁波银行&quot;, bankCode: &quot;NBBANK&quot;, patterns: [{ reg: /^(621279|622281|622316|940022)\\d{10}$/g, cardType: &quot;DC&quot; }, { reg: /^(621418)\\d{13}$/g, cardType: &quot;DC&quot; }, { reg: /^(625903|622778|628207|512431|520194|622282|622318)\\d{10}$/g, cardType: &quot;CC&quot; }] }, { bankName: &quot;北京银行&quot;, bankCode: &quot;BJBANK&quot;, patterns: [{ reg: /^(623111|421317|422161|602969|422160|621030|621420|621468)\\d{10}$/g, cardType: &quot;DC&quot; }, { reg: /^(522001|622163|622853|628203|622851|622852)\\d{10}$/g, cardType: &quot;CC&quot; }] }, { bankName: &quot;北京农村商业银行&quot;, bankCode: &quot;BJRCB&quot;, patterns: [{ reg: /^(620088|621068|622138|621066|621560)\\d{13}$/g, cardType: &quot;DC&quot; }, { reg: /^(625526|625186|628336)\\d{10}$/g, cardType: &quot;CC&quot; }] }, { bankName: &quot;汇丰银行&quot;, bankCode: &quot;HSBC&quot;, patterns: [{ reg: /^(622946)\\d{10}$/g, cardType: &quot;DC&quot; }, { reg: /^(622406|621442)\\d{11}$/g, cardType: &quot;DC&quot; }, { reg: /^(622407|621443)\\d{13}$/g, cardType: &quot;DC&quot; }, { reg: /^(622360|622361|625034|625096|625098)\\d{10}$/g, cardType: &quot;CC&quot; }] }, { bankName: &quot;渣打银行&quot;, bankCode: &quot;SCB&quot;, patterns: [{ reg: /^(622948|621740|622942|622994)\\d{10}$/g, cardType: &quot;DC&quot; }, { reg: /^(622482|622483|622484)\\d{10}$/g, cardType: &quot;CC&quot; }] }, { bankName: &quot;花旗银行&quot;, bankCode: &quot;CITI&quot;, patterns: [{ reg: /^(621062|621063)\\d{10}$/g, cardType: &quot;DC&quot; }, { reg: /^(625076|625077|625074|625075|622371|625091)\\d{10}$/g, cardType: &quot;CC&quot; }] }, { bankName: &quot;东亚银行&quot;, bankCode: &quot;HKBEA&quot;, patterns: [{ reg: /^(622933|622938|623031|622943|621411)\\d{13}$/g, cardType: &quot;DC&quot; }, { reg: /^(622372|622471|622472|622265|622266|625972|625973)\\d{10}$/g, cardType: &quot;CC&quot; }, { reg: /^(622365)\\d{11}$/g, cardType: &quot;CC&quot; }] }, { bankName: &quot;广东华兴银行&quot;, bankCode: &quot;GHB&quot;, patterns: [{ reg: /^(621469|621625)\\d{13}$/g, cardType: &quot;DC&quot; }] }, { bankName: &quot;深圳农村商业银行&quot;, bankCode: &quot;SRCB&quot;, patterns: [{ reg: /^(622128|622129|623035)\\d{10}$/g, cardType: &quot;DC&quot; }] }, { bankName: &quot;广州农村商业银行股份有限公司&quot;, bankCode: &quot;GZRCU&quot;, patterns: [{ reg: /^(909810|940035|621522|622439)\\d{12}$/g, cardType: &quot;DC&quot; }] }, { bankName: &quot;东莞农村商业银行&quot;, bankCode: &quot;DRCBCL&quot;, patterns: [{ reg: /^(622328|940062|623038)\\d{13}$/g, cardType: &quot;DC&quot; }, { reg: /^(625288|625888)\\d{10}$/g, cardType: &quot;CC&quot; }] }, { bankName: &quot;东莞市商业银行&quot;, bankCode: &quot;BOD&quot;, patterns: [{ reg: /^(622333|940050)\\d{10}$/g, cardType: &quot;DC&quot; }, { reg: /^(621439|623010)\\d{13}$/g, cardType: &quot;DC&quot; }, { reg: /^(622888)\\d{10}$/g, cardType: &quot;CC&quot; }] }, { bankName: &quot;广东省农村信用社联合社&quot;, bankCode: &quot;GDRCC&quot;, patterns: [{ reg: /^(622302)\\d{10}$/g, cardType: &quot;DC&quot; }, { reg: /^(622477|622509|622510|622362|621018|621518)\\d{13}$/g, cardType: &quot;DC&quot; }] }, { bankName: &quot;大新银行&quot;, bankCode: &quot;DSB&quot;, patterns: [{ reg: /^(622297|621277)\\d{10}$/g, cardType: &quot;DC&quot; }, { reg: /^(622375|622489)\\d{11}$/g, cardType: &quot;DC&quot; }, { reg: /^(622293|622295|622296|622373|622451|622294|625940)\\d{10}$/g, cardType: &quot;CC&quot; }] }, { bankName: &quot;永亨银行&quot;, bankCode: &quot;WHB&quot;, patterns: [{ reg: /^(622871|622958|622963|622957|622861|622932|622862|621298)\\d{10}$/g, cardType: &quot;DC&quot; }, { reg: /^(622798|625010|622775|622785)\\d{10}$/g, cardType: &quot;CC&quot; }] }, { bankName: &quot;星展银行香港有限公司&quot;, bankCode: &quot;DBS&quot;, patterns: [{ reg: /^(621016|621015)\\d{13}$/g, cardType: &quot;DC&quot; }, { reg: /^(622487|622490|622491|622492)\\d{10}$/g, cardType: &quot;DC&quot; }, { reg: /^(622487|622490|622491|622492|621744|621745|621746|621747)\\d{11}$/g, cardType: &quot;DC&quot; }] }, { bankName: &quot;恒丰银行&quot;, bankCode: &quot;EGBANK&quot;, patterns: [{ reg: /^(623078)\\d{13}$/g, cardType: &quot;DC&quot; }, { reg: /^(622384|940034)\\d{11}$/g, cardType: &quot;DC&quot; }] }, { bankName: &quot;天津市商业银行&quot;, bankCode: &quot;TCCB&quot;, patterns: [{ reg: /^(940015|622331)\\d{12}$/g, cardType: &quot;DC&quot; }, { reg: /^(6091201)\\d{11}$/g, cardType: &quot;DC&quot; }, { reg: /^(622426|628205)\\d{10}$/g, cardType: &quot;CC&quot; }] }, { bankName: &quot;浙商银行&quot;, bankCode: &quot;CZBANK&quot;, patterns: [{ reg: /^(621019|622309|621019)\\d{13}$/g, cardType: &quot;DC&quot; }, { reg: /^(6223091100|6223092900|6223093310|6223093320|6223093330|6223093370|6223093380|6223096510|6223097910)\\d{9}$/g, cardType: &quot;DC&quot; }] }, { bankName: &quot;南洋商业银行&quot;, bankCode: &quot;NCB&quot;, patterns: [{ reg: /^(621213|621289|621290|621291|621292|621042|621743)\\d{13}$/g, cardType: &quot;DC&quot; }, { reg: /^(623041|622351)\\d{10}$/g, cardType: &quot;DC&quot; }, { reg: /^(625046|625044|625058|622349|622350)\\d{10}$/g, cardType: &quot;CC&quot; }, { reg: /^(620208|620209|625093|625095)\\d{10}$/g, cardType: &quot;PC&quot; }] }, { bankName: &quot;厦门银行&quot;, bankCode: &quot;XMBANK&quot;, patterns: [{ reg: /^(622393|940023)\\d{10}$/g, cardType: &quot;DC&quot; }, { reg: /^(6886592)\\d{11}$/g, cardType: &quot;DC&quot; }, { reg: /^(623019|621600|)\\d{13}$/g, cardType: &quot;DC&quot; }] }, { bankName: &quot;福建海峡银行&quot;, bankCode: &quot;FJHXBC&quot;, patterns: [{ reg: /^(622388)\\d{10}$/g, cardType: &quot;DC&quot; }, { reg: /^(621267|623063)\\d{12}$/g, cardType: &quot;DC&quot; }, { reg: /^(620043|)\\d{12}$/g, cardType: &quot;PC&quot; }] }, { bankName: &quot;吉林银行&quot;, bankCode: &quot;JLBANK&quot;, patterns: [{ reg: /^(622865|623131)\\d{13}$/g, cardType: &quot;DC&quot; }, { reg: /^(940012)\\d{10}$/g, cardType: &quot;DC&quot; }, { reg: /^(622178|622179|628358)\\d{10}$/g, cardType: &quot;CC&quot; }] }, { bankName: &quot;汉口银行&quot;, bankCode: &quot;HKB&quot;, patterns: [{ reg: /^(990027)\\d{12}$/g, cardType: &quot;DC&quot; }, { reg: /^(622325|623105|623029)\\d{10}$/g, cardType: &quot;DC&quot; }] }, { bankName: &quot;盛京银行&quot;, bankCode: &quot;SJBANK&quot;, patterns: [{ reg: /^(566666)\\d{12}$/g, cardType: &quot;DC&quot; }, { reg: /^(622455|940039)\\d{13}$/g, cardType: &quot;DC&quot; }, { reg: /^(623108|623081)\\d{10}$/g, cardType: &quot;DC&quot; }, { reg: /^(622466|628285)\\d{10}$/g, cardType: &quot;CC&quot; }] }, { bankName: &quot;大连银行&quot;, bankCode: &quot;DLB&quot;, patterns: [{ reg: /^(603708)\\d{11}$/g, cardType: &quot;DC&quot; }, { reg: /^(622993|623069|623070|623172|623173)\\d{13}$/g, cardType: &quot;DC&quot; }, { reg: /^(622383|622385|628299)\\d{10}$/g, cardType: &quot;CC&quot; }] }, { bankName: &quot;河北银行&quot;, bankCode: &quot;BHB&quot;, patterns: [{ reg: /^(622498|622499|623000|940046)\\d{13}$/g, cardType: &quot;DC&quot; }, { reg: /^(622921|628321)\\d{10}$/g, cardType: &quot;CC&quot; }] }, { bankName: &quot;乌鲁木齐市商业银行&quot;, bankCode: &quot;URMQCCB&quot;, patterns: [{ reg: /^(621751|622143|940001|621754)\\d{13}$/g, cardType: &quot;DC&quot; }, { reg: /^(622476|628278)\\d{10}$/g, cardType: &quot;CC&quot; }] }, { bankName: &quot;绍兴银行&quot;, bankCode: &quot;SXCB&quot;, patterns: [{ reg: /^(622486)\\d{10}$/g, cardType: &quot;DC&quot; }, { reg: /^(603602|623026|623086)\\d{12}$/g, cardType: &quot;DC&quot; }, { reg: /^(628291)\\d{10}$/g, cardType: &quot;CC&quot; }] }, { bankName: &quot;成都商业银行&quot;, bankCode: &quot;CDCB&quot;, patterns: [{ reg: /^(622152|622154|622996|622997|940027|622153|622135|621482|621532)\\d{13}$/g, cardType: &quot;DC&quot; }] }, { bankName: &quot;抚顺银行&quot;, bankCode: &quot;FSCB&quot;, patterns: [{ reg: /^(622442)\\d{11}$/g, cardType: &quot;DC&quot; }, { reg: /^(940053)\\d{12}$/g, cardType: &quot;DC&quot; }, { reg: /^(622442|623099)\\d{13}$/g, cardType: &quot;DC&quot; }] }, { bankName: &quot;郑州银行&quot;, bankCode: &quot;ZZBANK&quot;, patterns: [{ reg: /^(622421)\\d{13}$/g, cardType: &quot;DC&quot; }, { reg: /^(940056)\\d{11}$/g, cardType: &quot;DC&quot; }, { reg: /^(96828)\\d{11}$/g, cardType: &quot;DC&quot; }] }, { bankName: &quot;宁夏银行&quot;, bankCode: &quot;NXBANK&quot;, patterns: [{ reg: /^(621529|622429|621417|623089|623200)\\d{13}$/g, cardType: &quot;DC&quot; }, { reg: /^(628214|625529|622428)\\d{10}$/g, cardType: &quot;CC&quot; }] }, { bankName: &quot;重庆银行&quot;, bankCode: &quot;CQBANK&quot;, patterns: [{ reg: /^(9896)\\d{12}$/g, cardType: &quot;DC&quot; }, { reg: /^(622134|940018|623016)\\d{10}$/g, cardType: &quot;DC&quot; }] }, { bankName: &quot;哈尔滨银行&quot;, bankCode: &quot;HRBANK&quot;, patterns: [{ reg: /^(621577|622425)\\d{13}$/g, cardType: &quot;DC&quot; }, { reg: /^(940049)\\d{12}$/g, cardType: &quot;DC&quot; }, { reg: /^(622425)\\d{11}$/g, cardType: &quot;DC&quot; }] }, { bankName: &quot;兰州银行&quot;, bankCode: &quot;LZYH&quot;, patterns: [{ reg: /^(622139|940040|628263)\\d{10}$/g, cardType: &quot;DC&quot; }, { reg: /^(621242|621538|621496)\\d{13}$/g, cardType: &quot;DC&quot; }] }, { bankName: &quot;青岛银行&quot;, bankCode: &quot;QDCCB&quot;, patterns: [{ reg: /^(621252|622146|940061|628239)\\d{10}$/g, cardType: &quot;DC&quot; }, { reg: /^(621419|623170)\\d{13}$/g, cardType: &quot;DC&quot; }] }, { bankName: &quot;秦皇岛市商业银行&quot;, bankCode: &quot;QHDCCB&quot;, patterns: [{ reg: /^(62249802|94004602)\\d{11}$/g, cardType: &quot;DC&quot; }, { reg: /^(621237|623003)\\d{13}$/g, cardType: &quot;DC&quot; }] }, { bankName: &quot;青海银行&quot;, bankCode: &quot;BOQH&quot;, patterns: [{ reg: /^(622310|940068)\\d{11}$/g, cardType: &quot;DC&quot; }, { reg: /^(622817|628287|625959)\\d{10}$/g, cardType: &quot;CC&quot; }, { reg: /^(62536601)\\d{8}$/g, cardType: &quot;CC&quot; }] }, { bankName: &quot;台州银行&quot;, bankCode: &quot;TZCB&quot;, patterns: [{ reg: /^(622427)\\d{10}$/g, cardType: &quot;DC&quot; }, { reg: /^(940069)\\d{11}$/g, cardType: &quot;DC&quot; }, { reg: /^(623039)\\d{13}$/g, cardType: &quot;DC&quot; }, { reg: /^(622321|628273)\\d{10}$/g, cardType: &quot;CC&quot; }, { reg: /^(625001)\\d{10}$/g, cardType: &quot;SCC&quot; }] }, { bankName: &quot;长沙银行&quot;, bankCode: &quot;CSCB&quot;, patterns: [{ reg: /^(694301)\\d{12}$/g, cardType: &quot;DC&quot; }, { reg: /^(940071|622368|621446)\\d{13}$/g, cardType: &quot;DC&quot; }, { reg: /^(625901|622898|622900|628281|628282|622806|628283)\\d{10}$/g, cardType: &quot;CC&quot; }, { reg: /^(620519)\\d{13}$/g, cardType: &quot;PC&quot; }] }, { bankName: &quot;泉州银行&quot;, bankCode: &quot;BOQZ&quot;, patterns: [{ reg: /^(683970|940074)\\d{12}$/g, cardType: &quot;DC&quot; }, { reg: /^(622370)\\d{13}$/g, cardType: &quot;DC&quot; }, { reg: /^(621437)\\d{13}$/g, cardType: &quot;DC&quot; }, { reg: /^(628319)\\d{10}$/g, cardType: &quot;CC&quot; }] }, { bankName: &quot;包商银行&quot;, bankCode: &quot;BSB&quot;, patterns: [{ reg: /^(622336|621760)\\d{11}$/g, cardType: &quot;DC&quot; }, { reg: /^(622165)\\d{10}$/g, cardType: &quot;DC&quot; }, { reg: /^(622315|625950|628295)\\d{10}$/g, cardType: &quot;CC&quot; }] }, { bankName: &quot;龙江银行&quot;, bankCode: &quot;DAQINGB&quot;, patterns: [{ reg: /^(621037|621097|621588|622977)\\d{13}$/g, cardType: &quot;DC&quot; }, { reg: /^(62321601)\\d{11}$/g, cardType: &quot;DC&quot; }, { reg: /^(622860)\\d{10}$/g, cardType: &quot;DC&quot; }, { reg: /^(622644|628333)\\d{10}$/g, cardType: &quot;CC&quot; }] }, { bankName: &quot;上海农商银行&quot;, bankCode: &quot;SHRCB&quot;, patterns: [{ reg: /^(622478|940013|621495)\\d{10}$/g, cardType: &quot;DC&quot; }, { reg: /^(625500)\\d{10}$/g, cardType: &quot;SCC&quot; }, { reg: /^(622611|622722|628211|625989)\\d{10}$/g, cardType: &quot;CC&quot; }] }, { bankName: &quot;浙江泰隆商业银行&quot;, bankCode: &quot;ZJQL&quot;, patterns: [{ reg: /^(622717)\\d{10}$/g, cardType: &quot;SCC&quot; }, { reg: /^(628275|622565|622287)\\d{10}$/g, cardType: &quot;CC&quot; }] }, { bankName: &quot;内蒙古银行&quot;, bankCode: &quot;H3CB&quot;, patterns: [{ reg: /^(622147|621633)\\d{13}$/g, cardType: &quot;DC&quot; }, { reg: /^(628252)\\d{10}$/g, cardType: &quot;CC&quot; }] }, { bankName: &quot;广西北部湾银行&quot;, bankCode: &quot;BGB&quot;, patterns: [{ reg: /^(623001)\\d{10}$/g, cardType: &quot;DC&quot; }, { reg: /^(628227)\\d{10}$/g, cardType: &quot;CC&quot; }, { reg: /^(622335)\\d{10}$/g, cardType: &quot;CC&quot; } ] }, { bankName: &quot;桂林银行&quot;, bankCode: &quot;GLBANK&quot;, patterns: [{ reg: /^(621456)\\d{11}$/g, cardType: &quot;DC&quot; }, { reg: /^(621562)\\d{13}$/g, cardType: &quot;DC&quot; }, { reg: /^(628219)\\d{10}$/g, cardType: &quot;CC&quot; }] }, { bankName: &quot;龙江银行&quot;, bankCode: &quot;DAQINGB&quot;, patterns: [{ reg: /^(621037|621097|621588|622977)\\d{13}$/g, cardType: &quot;DC&quot; }, { reg: /^(62321601)\\d{11}$/g, cardType: &quot;DC&quot; }, { reg: /^(622475|622860)\\d{10}$/g, cardType: &quot;DC&quot; }, { reg: /^(625588)\\d{10}$/g, cardType: &quot;SCC&quot; }, { reg: /^(622270|628368|625090|622644|628333)\\d{10}$/g, cardType: &quot;CC&quot; }] }, { bankName: &quot;成都农村商业银行&quot;, bankCode: &quot;CDRCB&quot;, patterns: [{ reg: /^(623088)\\d{13}$/g, cardType: &quot;DC&quot; }, { reg: /^(622829|628301|622808|628308)\\d{10}$/g, cardType: &quot;CC&quot; }] }, { bankName: &quot;福建省农村信用社联合社&quot;, bankCode: &quot;FJNX&quot;, patterns: [{ reg: /^(622127|622184|621701|621251|621589|623036)\\d{13}$/g, cardType: &quot;DC&quot; }, { reg: /^(628232|622802|622290)\\d{10}$/g, cardType: &quot;CC&quot; }] }, { bankName: &quot;天津农村商业银行&quot;, bankCode: &quot;TRCB&quot;, patterns: [{ reg: /^(622531|622329)\\d{13}$/g, cardType: &quot;DC&quot; }, { reg: /^(622829|628301)\\d{10}$/g, cardType: &quot;CC&quot; }] }, { bankName: &quot;江苏省农村信用社联合社&quot;, bankCode: &quot;JSRCU&quot;, patterns: [{ reg: /^(621578|623066|622452|622324)\\d{13}$/g, cardType: &quot;DC&quot; }, { reg: /^(622815|622816|628226)\\d{10}$/g, cardType: &quot;CC&quot; }] }, { bankName: &quot;湖南农村信用社联合社&quot;, bankCode: &quot;SLH&quot;, patterns: [{ reg: /^(622906|628386|625519|625506)\\d{10}$/g, cardType: &quot;CC&quot; }] }, { bankName: &quot;江西省农村信用社联合社&quot;, bankCode: &quot;JXNCX&quot;, patterns: [{ reg: /^(621592)\\d{10}$/g, cardType: &quot;DC&quot; }, { reg: /^(628392)\\d{10}$/g, cardType: &quot;CC&quot; }] }, { bankName: &quot;商丘市商业银行&quot;, bankCode: &quot;SCBBANK&quot;, patterns: [{ reg: /^(621748)\\d{13}$/g, cardType: &quot;DC&quot; }, { reg: /^(628271)\\d{10}$/g, cardType: &quot;CC&quot; }] }, { bankName: &quot;华融湘江银行&quot;, bankCode: &quot;HRXJB&quot;, patterns: [{ reg: /^(621366|621388)\\d{13}$/g, cardType: &quot;DC&quot; }, { reg: /^(628328)\\d{10}$/g, cardType: &quot;CC&quot; }] }, { bankName: &quot;衡水市商业银行&quot;, bankCode: &quot;HSBK&quot;, patterns: [{ reg: /^(621239|623068)\\d{13}$/g, cardType: &quot;DC&quot; }] }, { bankName: &quot;重庆南川石银村镇银行&quot;, bankCode: &quot;CQNCSYCZ&quot;, patterns: [{ reg: /^(621653004)\\d{10}$/g, cardType: &quot;DC&quot; }] }, { bankName: &quot;湖南省农村信用社联合社&quot;, bankCode: &quot;HNRCC&quot;, patterns: [{ reg: /^(622169|621519|621539|623090)\\d{13}$/g, cardType: &quot;DC&quot; }] }, { bankName: &quot;邢台银行&quot;, bankCode: &quot;XTB&quot;, patterns: [{ reg: /^(621238|620528)\\d{13}$/g, cardType: &quot;DC&quot; }] }, { bankName: &quot;临汾市尧都区农村信用合作联社&quot;, bankCode: &quot;LPRDNCXYS&quot;, patterns: [{ reg: /^(628382|625158)\\d{10}$/g, cardType: &quot;CC&quot; }] }, { bankName: &quot;东营银行&quot;, bankCode: &quot;DYCCB&quot;, patterns: [{ reg: /^(621004)\\d{12}$/g, cardType: &quot;DC&quot; }, { reg: /^(628217)\\d{10}$/g, cardType: &quot;CC&quot; }] }, { bankName: &quot;上饶银行&quot;, bankCode: &quot;SRBANK&quot;, patterns: [{ reg: /^(621416)\\d{10}$/g, cardType: &quot;DC&quot; }, { reg: /^(628217)\\d{10}$/g, cardType: &quot;CC&quot; }] }, { bankName: &quot;德州银行&quot;, bankCode: &quot;DZBANK&quot;, patterns: [{ reg: /^(622937)\\d{13}$/g, cardType: &quot;DC&quot; }, { reg: /^(628397)\\d{10}$/g, cardType: &quot;CC&quot; }] }, { bankName: &quot;承德银行&quot;, bankCode: &quot;CDB&quot;, patterns: [{ reg: /^(628229)\\d{10}$/g, cardType: &quot;CC&quot; }] }, { bankName: &quot;云南省农村信用社&quot;, bankCode: &quot;YNRCC&quot;, patterns: [{ reg: /^(622469|628307)\\d{10}$/g, cardType: &quot;CC&quot; }] }, { bankName: &quot;柳州银行&quot;, bankCode: &quot;LZCCB&quot;, patterns: [{ reg: /^(622292|622291|621412)\\d{12}$/g, cardType: &quot;DC&quot; }, { reg: /^(622880|622881)\\d{10}$/g, cardType: &quot;DC&quot; }, { reg: /^(62829)\\d{10}$/g, cardType: &quot;CC&quot; }] }, { bankName: &quot;威海市商业银行&quot;, bankCode: &quot;WHSYBANK&quot;, patterns: [{ reg: /^(623102)\\d{10}$/g, cardType: &quot;DC&quot; }, { reg: /^(628234)\\d{10}$/g, cardType: &quot;CC&quot; }] }, { bankName: &quot;湖州银行&quot;, bankCode: &quot;HZBANK&quot;, patterns: [{ reg: /^(628306)\\d{10}$/g, cardType: &quot;CC&quot; }] }, { bankName: &quot;潍坊银行&quot;, bankCode: &quot;BANKWF&quot;, patterns: [{ reg: /^(622391|940072)\\d{10}$/g, cardType: &quot;DC&quot; }, { reg: /^(628391)\\d{10}$/g, cardType: &quot;CC&quot; }] }, { bankName: &quot;赣州银行&quot;, bankCode: &quot;GZB&quot;, patterns: [{ reg: /^(622967|940073)\\d{13}$/g, cardType: &quot;DC&quot; }, { reg: /^(628233)\\d{10}$/g, cardType: &quot;CC&quot; }] }, { bankName: &quot;日照银行&quot;, bankCode: &quot;RZGWYBANK&quot;, patterns: [{ reg: /^(628257)\\d{10}$/g, cardType: &quot;CC&quot; }] }, { bankName: &quot;南昌银行&quot;, bankCode: &quot;NCB&quot;, patterns: [{ reg: /^(621269|622275)\\d{10}$/g, cardType: &quot;DC&quot; }, { reg: /^(940006)\\d{11}$/g, cardType: &quot;DC&quot; }, { reg: /^(628305)\\d{11}$/g, cardType: &quot;CC&quot; }] }, { bankName: &quot;贵阳银行&quot;, bankCode: &quot;GYCB&quot;, patterns: [{ reg: /^(622133|621735)\\d{13}$/g, cardType: &quot;DC&quot; }, { reg: /^(888)\\d{13}$/g, cardType: &quot;DC&quot; }, { reg: /^(628213)\\d{10}$/g, cardType: &quot;CC&quot; }] }, { bankName: &quot;锦州银行&quot;, bankCode: &quot;BOJZ&quot;, patterns: [{ reg: /^(622990|940003)\\d{11}$/g, cardType: &quot;DC&quot; }, { reg: /^(628261)\\d{10}$/g, cardType: &quot;CC&quot; }] }, { bankName: &quot;齐商银行&quot;, bankCode: &quot;QSBANK&quot;, patterns: [{ reg: /^(622311|940057)\\d{11}$/g, cardType: &quot;DC&quot; }, { reg: /^(628311)\\d{10}$/g, cardType: &quot;CC&quot; }] }, { bankName: &quot;珠海华润银行&quot;, bankCode: &quot;RBOZ&quot;, patterns: [{ reg: /^(622363|940048)\\d{13}$/g, cardType: &quot;DC&quot; }, { reg: /^(628270)\\d{10}$/g, cardType: &quot;CC&quot; }] }, { bankName: &quot;葫芦岛市商业银行&quot;, bankCode: &quot;HLDCCB&quot;, patterns: [{ reg: /^(622398|940054)\\d{10}$/g, cardType: &quot;DC&quot; }] }, { bankName: &quot;宜昌市商业银行&quot;, bankCode: &quot;HBC&quot;, patterns: [{ reg: /^(940055)\\d{11}$/g, cardType: &quot;DC&quot; }, { reg: /^(622397)\\d{11}$/g, cardType: &quot;CC&quot; }] }, { bankName: &quot;杭州商业银行&quot;, bankCode: &quot;HZCB&quot;, patterns: [{ reg: /^(603367|622878)\\d{12}$/g, cardType: &quot;DC&quot; }, { reg: /^(622397)\\d{11}$/g, cardType: &quot;CC&quot; }] }, { bankName: &quot;苏州市商业银行&quot;, bankCode: &quot;JSBANK&quot;, patterns: [{ reg: /^(603506)\\d{13}$/g, cardType: &quot;DC&quot; }] }, { bankName: &quot;辽阳银行&quot;, bankCode: &quot;LYCB&quot;, patterns: [{ reg: /^(622399|940043)\\d{11}$/g, cardType: &quot;DC&quot; }] }, { bankName: &quot;洛阳银行&quot;, bankCode: &quot;LYB&quot;, patterns: [{ reg: /^(622420|940041)\\d{11}$/g, cardType: &quot;DC&quot; }] }, { bankName: &quot;焦作市商业银行&quot;, bankCode: &quot;JZCBANK&quot;, patterns: [{ reg: /^(622338)\\d{13}$/g, cardType: &quot;DC&quot; }, { reg: /^(940032)\\d{10}$/g, cardType: &quot;DC&quot; }] }, { bankName: &quot;镇江市商业银行&quot;, bankCode: &quot;ZJCCB&quot;, patterns: [{ reg: /^(622394|940025)\\d{10}$/g, cardType: &quot;DC&quot; }] }, { bankName: &quot;法国兴业银行&quot;, bankCode: &quot;FGXYBANK&quot;, patterns: [{ reg: /^(621245)\\d{10}$/g, cardType: &quot;DC&quot; }] }, { bankName: &quot;大华银行&quot;, bankCode: &quot;DYBANK&quot;, patterns: [{ reg: /^(621328)\\d{13}$/g, cardType: &quot;DC&quot; }] }, { bankName: &quot;企业银行&quot;, bankCode: &quot;DIYEBANK&quot;, patterns: [{ reg: /^(621651)\\d{13}$/g, cardType: &quot;DC&quot; }] }, { bankName: &quot;华侨银行&quot;, bankCode: &quot;HQBANK&quot;, patterns: [{ reg: /^(621077)\\d{10}$/g, cardType: &quot;DC&quot; }] }, { bankName: &quot;恒生银行&quot;, bankCode: &quot;HSB&quot;, patterns: [{ reg: /^(622409|621441)\\d{13}$/g, cardType: &quot;DC&quot; }, { reg: /^(622410|621440)\\d{11}$/g, cardType: &quot;DC&quot; }, { reg: /^(622950|622951)\\d{10}$/g, cardType: &quot;DC&quot; }, { reg: /^(625026|625024|622376|622378|622377|625092)\\d{10}$/g, cardType: &quot;CC&quot; }] }, { bankName: &quot;临沂商业银行&quot;, bankCode: &quot;LSB&quot;, patterns: [{ reg: /^(622359|940066)\\d{13}$/g, cardType: &quot;DC&quot; }] }, { bankName: &quot;烟台商业银行&quot;, bankCode: &quot;YTCB&quot;, patterns: [{ reg: /^(622886)\\d{10}$/g, cardType: &quot;DC&quot; }] }, { bankName: &quot;齐鲁银行&quot;, bankCode: &quot;QLB&quot;, patterns: [{ reg: /^(940008|622379)\\d{13}$/g, cardType: &quot;DC&quot; }, { reg: /^(628379)\\d{10}$/g, cardType: &quot;CC&quot; }] }, { bankName: &quot;BC卡公司&quot;, bankCode: &quot;BCCC&quot;, patterns: [{ reg: /^(620011|620027|620031|620039|620103|620106|620120|620123|620125|620220|620278|620812|621006|621011|621012|621020|621023|621025|621027|621031|620132|621039|621078|621220|621003)\\d{10}$/g, cardType: &quot;DC&quot; }, { reg: /^(625003|625011|625012|625020|625023|625025|625027|625031|621032|625039|625078|625079|625103|625106|625006|625112|625120|625123|625125|625127|625131|625032|625139|625178|625179|625220|625320|625111|625132|625244)\\d{10}$/g, cardType: &quot;CC&quot; }] }, { bankName: &quot;集友银行&quot;, bankCode: &quot;CYB&quot;, patterns: [{ reg: /^(622355|623042)\\d{10}$/g, cardType: &quot;DC&quot; }, { reg: /^(621043|621742)\\d{13}$/g, cardType: &quot;DC&quot; }, { reg: /^(622352|622353|625048|625053|625060)\\d{10}$/g, cardType: &quot;CC&quot; }, { reg: /^(620206|620207)\\d{10}$/g, cardType: &quot;PC&quot; }] }, { bankName: &quot;大丰银行&quot;, bankCode: &quot;TFB&quot;, patterns: [{ reg: /^(622547|622548|622546)\\d{13}$/g, cardType: &quot;DC&quot; }, { reg: /^(625198|625196|625147)\\d{10}$/g, cardType: &quot;CC&quot; }, { reg: /^(620072)\\d{13}$/g, cardType: &quot;PC&quot; }, { reg: /^(620204|620205)\\d{10}$/g, cardType: &quot;PC&quot; }] }, { bankName: &quot;AEON信贷财务亚洲有限公司&quot;, bankCode: &quot;AEON&quot;, patterns: [{ reg: /^(621064|622941|622974)\\d{10}$/g, cardType: &quot;DC&quot; }, { reg: /^(622493)\\d{10}$/g, cardType: &quot;CC&quot; }] }, { bankName: &quot;澳门BDA&quot;, bankCode: &quot;MABDA&quot;, patterns: [{ reg: /^(621274|621324)\\d{13}$/g, cardType: &quot;DC&quot; }] }] //验证银行卡号 $(&quot;input[name='bankNum']&quot;).blur(function () { var num = $(this).val(); //去掉空格，因为input框中设置了自动空格，如果input框中没有设置自动空格可省略这句代码 num = num.replace(/\\s/g, &quot;&quot;); //判断卡号是否正确 for (var i = 0,len=bankcardList.length; i &lt; len; i++) { for (var j = 0,regLen = bankcardList[i].patterns.length; j &lt; regLen; j++) { var reg = bankcardList[i].patterns[j].reg.test(num); if(reg){ alert(&quot;输入的是&quot;+bankcardList[i].bankName+&quot;的卡号&quot;) return ; } } } }); ","link":"https://tdmaker.github.io/faded/post/regular-expression-band-card/"},{"title":"正则表达式——简介","content":"在自然语言处理中，很多时候我们都需要从文本或字符串中抽取出想要的信息，并进一步做语义理解或其它处理。 常用正则表达式网站 Regex Dictionary https://visca.com/regexdict/ RegExr https://regexr.com/ RegExper https://regexper.com/ Regular Expressions 101 https://regex101.com/ 基本语句 ♍锚点：^ 和 $ ^The 匹配任何以“The”开头的字符串。 end$ 匹配以“end”为结尾的字符串。 ^The end$ 匹配从“The”开始到“end”结束的字符串。 roar 匹配任何带有文本“roar”的字符串。 ♍数量符：* 和 + 和 ? 和 {} abc* 匹配在“ab”后面跟着 0 个或多个“c”的字符串。 abc+ 匹配在“ab”后面跟着 1 个或多个“c”的字符串。 abc? 匹配在“ab”后面跟着 0 个或 1 个“c”的字符串。 abc{2} 匹配在“ab”后面跟着 2 个“c”的字符串。 abc{2,} 匹配在“ab”后面跟着 2 个或更多“c”的字符串。 abc{2,5} 匹配在“ab”后面跟着 2 到 5 个“c”的字符串。 a(bc)* 匹配在“a”后面跟着 0 个或更多“bc”序列的字符串。 a(bc){2,5} 匹配在“a”后面跟着 2 到 5 个“bc”序列的字符串。 ♍或运算符：| 和 [] a(b|c) 匹配在“a”后面跟着“b”或“c”的字符串。 a[bc] 匹配在“a”后面跟着“b”或“c”的字符串。 ♍字符类：\\d 和 \\w 和 \\s 和 . \\d 匹配数字型的单个字符。 \\w 匹配单个词字（字母加下划线）。 \\s 匹配单个空格字符（包括制表符和换行符）。 . 匹配任意字符。 使用 . 运算符需要非常小心，因为常见类或排除型字符类都要更快与精确。\\d、\\w 和 \\s 同样有它们各自的排除型字符类，即 \\D、\\W 和 \\S。例如 \\D 将执行与 \\d 完全相反的匹配方法： \\D 匹配单个非数字型的字符。 为了正确地匹配，我们必须使用转义符反斜杠 \\ 定义我们需要匹配的符号 ^.[$()|*+?{\\，因为我们可能认为这些符号在原文本中有特殊的含义。 \\$\\d 匹配在单个数字前有符号“$”的字符串。 注意我们同样能匹配 non-printable 字符，例如 Tab 符 \\t、换行符 \\n 和回车符 \\r。 ♍Flags 模式的结尾我们通常可以指定以下 flag 配置或它们的组合： g（global）在第一次完成匹配后并不会返回结果，它会继续搜索剩下的文本。 m（multi line）允许使用^和$匹配一行的开始和结尾，而不是整个序列。 i（insensitive）令整个表达式不区分大小写（例如/aBc/i 将匹配 AbC）。 中级语句 ♍分组和捕获：() a(bc) 圆括弧会创建一个捕获性分组，它会捕获匹配项“bc”。 a(?:bc)* 使用“?: ”会使捕获分组失效，只需要匹配前面的“a”。 a(?&lt;foo&gt;bc) 使用“?&lt;foo&gt;”会为分组配置一个名称 。 捕获性圆括号 () 和非捕获性圆括弧 (?:) 对于从字符串或数据中抽取信息非常重要，我们可以使用 Python 等不同的编程语言实现这一功能。从多个分组中捕获的多个匹配项将以经典的数组形式展示：我们可以使用匹配结果的索引访问它们的值。如果需要为分组添加名称（使用 (?&lt;foo&gt;...)），我们就能如字典那样使用匹配结果检索分组的值，其中字典的键为分组的名称。 ♍方括弧表达式：[] [abc] 匹配带有一个“a”、“ab”或“ac”的字符串。 [a-c] 匹配带有一个“a”、“ab”或“ac”的字符串。 [a-fA-F0-9] 匹配一个代表 16 进制数字的字符串，不区分大小写。 [0-9]% 匹配在 % 符号前面带有 0 到 9 这几个字符的字符串。 [^a-zA-Z] 匹配不带 a 到 z 或 A 到 Z 的字符串，其中 ^ 为否定表达式。 记住在方括弧内，所有特殊字符（包括反斜杠 \\ ）都会失去它们应有的意义。 ♍Greedy 和 Lazy 匹配 数量符（* + {}）是一种贪心运算符，所以它们会遍历给定的文本，并尽可能匹配。例如，&lt;.+&gt; 可以匹配文本 “This is a &lt;div&gt; simple div&lt;/div&gt; test” 中的 “&lt;div&gt;simple div&lt;/div&gt;&quot;。为了仅捕获 div 标签，我们需要使用 ? 令贪心搜索变得 Lazy 一点： &lt;.+?&gt; 一次或多次匹配“&lt;”和“&gt;”里面的任何字符，可按需扩展。 注意更好的解决方案应该需要避免使用 .，这有利于实现更严格的正则表达式： &lt;[^&lt;&gt;]+&gt; 一次或多次匹配“&lt;”和“&gt;”里面的任何字符，除去“&lt;”或“&gt;”字符。 高级语句 ♍边界符：\\b 和 \\B \\babc\\b 执行整词匹配搜索。 \\b 如插入符号那样表示一个锚点（它与 $ 和 ^ 相同）来匹配位置，其中一边是一个单词符号（如 \\w），另一边不是单词符号（例如它可能是字符串的起始点或空格符号）。 它同样能表达相反的非单词边界 \\B，它会匹配 \\b 不会匹配的位置，如果我们希望找到被单词字符环绕的搜索模式，就可以使用它。 \\Babc\\B 只要是被单词字符环绕的模式就会匹配。 ♍前向匹配和后向匹配：(?=) 和 (?&lt;=) d(?=r) 只有在后面跟着“r”的时候才匹配“d”，但是“r”并不会成为整个正则表达式匹配的一部分。 (?&lt;=r)d 只有在前面跟着“r”时才匹配“d”，但是“r”并不会成为整个正则表达式匹配的一部分。 我们同样能使用否定运算子： d(?!r) 只有在后面不跟着“r”的时候才匹配“d”，但是“r”并不会成为整个正则表达式匹配的一部分。 (?&lt;!r)d 只有在前面不跟着“r”时才匹配“d”，但是“r”并不会成为整个正则表达式匹配的一部分。 结语 正如上文所示，正则表达式的应用领域非常广，很可能各位读者在开发的过程中已经遇到了它，下面是正则表达式常用的领域： 数据验证，例如检查时间字符串是否符合格式； 数据抓取，以特定顺序抓取包含特定文本或内容的网页； 数据包装，将数据从某种原格式转换为另外一种格式； 字符串解析，例如捕获所拥有 URL 的 GET 参数，或捕获一组圆括弧内的文本； 字符串替代，将字符串中的某个字符替换为其它字符。 ","link":"https://tdmaker.github.io/faded/post/regular-expression-introduction/"},{"title":"有趣的网站","content":"一些平时遇到的有用有趣的网站 网站 网址 在浏览器中运行 Linux https://bellard.org/jslinux/ 一个修改漫画的小工具 https://moeka.me/mangaEditor/ AI 人工智能图片放大 https://bigjpg.com/ 黑白照片上色 https://colourise.sg/ 在线 Photoshop https://ps.gaoding.com/#/ GIF 加字幕 http://www.yingjingtu.com/index 证件照换底色 https://www.gaoding.com/koutu 图片背景消除 https://www.remove.bg/zh 快速去掉背景色 https://bgeraser.com/index.html 网版图制作 https://xoihazard.com/tools/halftone/ 双色套效果 https://duotones.co/ SVG在线压缩合并 https://www.zhangxinxu.com/sp/svgo/ Emoji 马赛克 https://ericandrewlewis.github.io/emoji-mosaic/ CSS 动画制作 https://animista.net/ SQL 语句在线格式化 https://sqlfum.pt/ 实时在线分享代码 https://codeshare.io/ gif 制作 https://gifs.com/ 生成漂亮的代码截图 https://carbon.now.sh/ 在线文件转换 https://cn.office-converter.com/ File Converter https://cloudconvert.com/ ToolFk 在线程序员开发工具 https://www.toolfk.com/ 在线工具 https://tool.lu/ 一个工具箱 http://www.atoolbox.net/ 爱资料工具 https://www.toolnb.com/ 孟坤工具箱 http://tool.mkblog.cn/ OKTools https://oktools.net/ 在线工具 https://helloacm.com/tools/ JS/HTML格式化 https://www.zxgj.cn/g/jshtmlformat 甜言蜜语 API https://api.tryto.cn/saylove/text 甜言蜜语 API https://api.tryto.cn/djt/text 码灵程序员网址导航 https://nav.imaring.com/ CSS 剪切路径生成器 https://bennettfeely.com/clippy/ 文章生成器 https://suulnnka.github.io/BullshitGenerator/index.html 在线屏幕录制 https://www.p2hp.com/screenrecord.html 高手工具 https://c.p2hp.com/ 在线加密算法 https://www.ssleye.com/ JSON在线格式化,JSON在线解析 https://json.im/ 哈希 https://haxi.im/ 图片隐写术加密、图片隐写术解密 https://c.p2hp.com/yinxietu/ 在线代码运行时 Labstack https://code.labstack.com/dart 在线文件加密 https://hat.sh/ 在线检测浏览器版本 https://liulanmi.com/labs/core.html 糖果短语视频生成器 https://hattemi.com/ 前端网址导航 http://www.daqianduan.com/nav 背景生成器 https://bggenerator.com/zh-cn.php “爱古典”数据库 http://www.iloveclassics.icoc.cc/ Compare package download counts over time https://www.npmtrends.com/ IP反查域名 https://dns.aizhan.com/ ","link":"https://tdmaker.github.io/faded/post/you-qu-de-wang-zhan/"},{"title":"正则表达式——常用案例","content":"正则大全 https://any86.github.io/any-rule/ 火车车次 /^[GCDZTSPKXLY1-9]\\d{1,4}$/ 手机机身码(IMEI) /^\\d{15,17}$/ 必须带端口号的网址(或ip) /^(((ht|f)tps?):\\/\\/)?[\\w\\-]+(\\.[\\w\\-]+)+:\\d{0,5}\\/?/ 网址(支持端口和&quot;?+参数&quot;和&quot;#+参数) /^(((ht|f)tps?):\\/\\/)?[\\w\\-]+(\\.[\\w\\-]+)+([\\w\\-.,@?^=%&amp;:\\/~+#]*[\\w\\-@?^=%&amp;\\/~+#])?$/ 统一社会信用代码 /^[0-9A-HJ-NPQRTUWXY]{2}\\d{6}[0-9A-HJ-NPQRTUWXY]{10}$/ 迅雷链接 /^thunderx?:\\/\\/[a-zA-Z\\d]+=$/ ed2k链接(宽松匹配) /^ed2k:\\/\\/\\|file\\|.+\\|\\/$/ 磁力链接(宽松匹配) /^magnet:\\?xt=urn:btih:[0-9a-fA-F]{40,}.*$/ 子网掩码 /^(?:\\d{1,2}|1\\d\\d|2[0-4]\\d|25[0-5])(?:\\.(?:\\d{1,2}|1\\d\\d|2[0-4]\\d|25[0-5])){3}$/ Linux&quot;文件夹&quot;路径 /^\\/(\\w+\\/?)+$/ Linux&quot;文件&quot;路径 /^\\/(\\w+\\/)+\\w+\\.\\w+$/ Window下&quot;文件夹&quot;路径 /^[a-zA-Z]:\\\\(?:\\w+\\\\?)*$/ Window下&quot;文件&quot;路径 /^[a-zA-Z]:\\\\(?:\\w+\\\\)*\\w+\\.\\w+$/ A股代码 /^(s[hz]|S[HZ])(000[\\d]{3}|002[\\d]{3}|300[\\d]{3}|600[\\d]{3}|60[\\d]{4})$/ 考卷分数 /^150$|^(?:\\d|[1-9]\\d|1[0-4]\\d)(?:.5)?$/ 大于等于0, 小于等于150, 支持小数位出现5, 如145.5 校验密码强度 ^(?=.*\\\\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$ 密码的强度必须是包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间。 /^(?=.*[0-9])(?=.*[a-z])(?=.*[A-Z])(?=.*\\_)\\w{8,20}$/ 只允许字母数字下划线，必须含有大小写和数字和下划线 校验中文 ^[\\\\u4e00-\\\\u9fa5]{0,}$ 由数字、26个英文字母或下划线组成的字符串 ^\\\\w+$ 校验E-Mail 地址 [\\\\w!#$%&amp;'*+/=?^_{|}~-]+(?:\\.[\\w!#$%&amp;'*+/=?^_{|}~-]+)*@(?:[\\\\w](?:[\\\\w-]*[\\\\w])?\\\\.)+[\\\\w](?:[\\\\w-]*[\\\\w])? 校验日期 ^(?:(?!0000)[0-9]{4}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$ “yyyy-mm-dd“ 格式的日期校验，已考虑平闰年。 校验金额 ^[0-9]+(.[0-9]{2})?$ 金额校验，精确到2位小数。 判断IE的版本 ^.*MSIE [5-8](?:\\\\.[0-9]+)?(?!.*Trident\\\\/[5-9]\\\\.0).*$ 校验IPv4地址 \\\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\b 校验IPv6地址 (([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])) 提取URL链接 ^(f|ht){1}(tp|tps):\\\\/\\\\/([\\\\w-]+\\\\.)+[\\\\w-]+(\\\\/[\\\\w- ./?%&amp;=]*)? 文件路径及扩展名校验 ^([a-zA-Z]\\\\:|\\\\\\\\)\\\\\\\\([^\\\\\\\\]+\\\\\\\\)*[^\\\\/:*?&quot;&lt;&gt;|]+\\\\.txt(l)?$ 验证windows下文件路径和扩展名（以 .txt 文件为例） 提取Color Hex Codes ^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$ 提取网页图片 \\\\&lt; *[img][^\\\\\\\\&gt;]*[src] *= *[\\\\&quot;\\\\']{0,1}([^\\\\&quot;\\\\'\\\\ &gt;]*) 提取页面超链接 (&lt;a\\\\s*(?!.*\\\\brel=)[^&gt;]*)(href=&quot;https?:\\\\/\\\\/)((?!(?:(?:www\\\\.)?'.implode('|(?:www\\\\.)?', $follow_list).'))[^&quot;]+)&quot;((?!.*\\\\brel=)[^&gt;]*)(?:[^&gt;]*)&gt; 查找CSS属性 ^\\\\s*[a-zA-Z\\\\-]+\\\\s*[:]{1}\\\\s[a-zA-Z0-9\\\\s.#]+[;]{1} 抽取注释 &lt;!--(.*?)--&gt; 匹配HTML标签 &lt;\\\\/?\\\\w+((\\\\s+\\\\w+(\\\\s*=\\\\s*(?:&quot;.*?&quot;|'.*?'|[\\\\^'&quot;&gt;\\\\s]+))?)+\\\\s*|\\\\s*)\\\\/?&gt; 银行卡四位一空格 str.replace(/\\s/g, '').replace(/(.{4})/g, &quot;$1 &quot;); 用户名正则 /^[a-zA-Z0-9_-]{4,16}$/ 4到16位（字母，数字，下划线，减号） 密码正则 ^[a-zA-Z]\\w{5,17}$ 以字母开头，长度在6~18之间，只能包含字母、数字和下划线 强密码正则 /^.*(?=.{6,})(?=.*\\d)(?=.*[A-Z])(?=.*[a-z])(?=.*[!@#$%^&amp;*? ]).*$/ 最少6位，包括至少1个大写字母，1个小写字母，1个数字，1个特殊字符 QQ 号正则 /^[1-9][0-9]{4,10}$/ 微信号正则 /^[a-zA-Z]([-_a-zA-Z0-9]{5,19})+$/ 6至20位，以字母开头，字母，数字，减号，下划线 特殊字符正则 /[&quot;'&lt;&gt;%;)(&amp;+]+-!！@#$~/ 域名正则 [a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.? 车牌号正则 /^[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领A-Z]{1}[A-Z]{1}[A-Z0-9]{4}[A-Z0-9挂学警港澳]{1}$/ 护照正则 /^(P\\d{7}|G\\d{7,8}|TH\\d{7,8}|S\\d{7,8}|A\\d{7,8}|L\\d{7,8}|\\d{9}|D\\d+|1[4,5]\\d{7})$/ 固定电话正则 (\\(\\d{3,4}\\)|\\d{3,4}-|\\s)?\\d{8} 邮政编码正则 [1-9]{1}(\\d+){5} 经度正则 /^(\\-|\\+)?(((\\d|[1-9]\\d|1[0-7]\\d|0{1,3})\\.\\d{0,6})|(\\d|[1-9]\\d|1[0-7]\\d|0{1,3})|180\\.0{0,6}|180)$/ 维度正则 /^(\\-|\\+)?([0-8]?\\d{1}\\.\\d{0,6}|90\\.0{0,6}|[0-8]?\\d{1}|90)$/ ","link":"https://tdmaker.github.io/faded/post/regular-expression-regular-cases/"},{"title":"Hello Gridea","content":"👏 欢迎使用 Gridea ！ ✍️ Gridea 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... Github Gridea 主页 示例网站 特性👇 📝 你可以使用最酷的 Markdown 语法，进行快速创作 🌉 你可以给文章配上精美的封面图和在文章任意位置插入图片 🏷️ 你可以对文章进行标签分组 📋 你可以自定义菜单，甚至可以创建外部链接菜单 💻 你可以在 Windows，MacOS 或 Linux 设备上使用此客户端 🌎 你可以使用 𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌 或 Coding Pages 向世界展示，未来将支持更多平台 💬 你可以进行简单的配置，接入 Gitalk 或 DisqusJS 评论系统 🇬🇧 你可以使用中文简体或英语 🌁 你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力 🖥 你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步 🌱 当然 Gridea 还很年轻，有很多不足，但请相信，它会不停向前 🏃 未来，它一定会成为你离不开的伙伴 尽情发挥你的才华吧！ 😘 Enjoy~ ","link":"https://tdmaker.github.io/faded/post/hello-gridea/"}]}