<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>正则表达式——断言 | Typhoeus</title>
<link rel="shortcut icon" href="https://tdmaker.github.io/faded//favicon.ico?v=1586178087934">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://tdmaker.github.io/faded//styles/main.css">
<link rel="alternate" type="application/atom+xml" title="正则表达式——断言 | Typhoeus - Atom Feed" href="https://tdmaker.github.io/faded//atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="
正则表达式断言

正则表达式大多数结构匹配的文本会出现在最终的匹配结果中，但也有些结构并不真正匹配文本，而只是负责判断某个位置左/右侧是否符合要求，这种结构被称为断言（assertion）。常见的断言有三类： 单词边界、行起始/结束位置、..." />
    <meta name="keywords" content="正则表达式" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://tdmaker.github.io/faded/">
  <img class="avatar" src="https://tdmaker.github.io/faded//images/avatar.png?v=1586178087934" alt="">
  </a>
  <h1 class="site-title">
    Typhoeus
  </h1>
  <p class="site-description">
    温故而知新
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              正则表达式——断言
            </h2>
            <div class="post-info">
              <span>
                2020-04-06
              </span>
              <span>
                7 min read
              </span>
              
                <a href="https://tdmaker.github.io/faded/tag/regular-expression/" class="post-tag">
                  # 正则表达式
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <blockquote>
<p><a href="https://www.jianshu.com/p/08c2fa742c1b">正则表达式断言</a></p>
</blockquote>
<p>正则表达式大多数结构匹配的文本会出现在最终的匹配结果中，但也有些结构并不真正匹配文本，而只是负责判断某个位置左/右侧是否符合要求，这种结构被称为断言（assertion）。常见的断言有三类： 单词边界、行起始/结束位置、环视。本文主要简单阐述对三类断言的理解。</p>
<h1 id="单词边界">单词边界</h1>
<p>单词边界顾名思义，是指单词字符 <code>(\w)</code> 能匹配的字符串的左右位置。在 JavaScript、php、Python 2、Ruby 中，单词字符 <code>(\w)</code> 等同于 <code>[0-9a-zA-Z]</code>，所以在这些语言中，给定一段文本可以用 <code>\b\w+\b</code> 把所有单词提取出来。<br>
例如：</p>
<pre><code class="language-javascript">('Love is composed of a single soul inhabiting two bodies.').match(/\b\w+\b/g)

return [&quot;Love&quot;, &quot;is&quot;, &quot;composed&quot;, &quot;of&quot;, &quot;a&quot;, &quot;single&quot;, &quot;soul&quot;, &quot;inhabiting&quot;, &quot;two&quot;, &quot;bodies&quot;]
</code></pre>
<p>这里值得注意的是，有些单词例如 E-mail 和组合词 I'm 这样的，<code>\b\w+\b</code> 是无法匹配的。如要匹配，可根据需求修改为 <code>\b['-\w]\b</code>。</p>
<ul>
<li><strong>单词边界</strong>记为 <code>\b</code>，它能匹配的位置：一边是单词字符 <code>\w</code>，一边是非单词字符 <code>\W</code>。</li>
<li>与单词边界对应的是<strong>非单词边界</strong> <code>\B</code>，两者关系类似 <code>\w</code> 与 <code>\W</code>、<code>\d</code> 与 <code>\D</code>。</li>
</ul>
<p>这里注意，<strong>非单词边界</strong>（<code>\B</code>）和<strong>单词字符</strong>（<code>\w</code>）是不一样的，因为前者是<strong>断言</strong>，而后者是<strong>普通匹配</strong>。<br>
例如：</p>
<pre><code class="language-javascript">// 式一
String(1234567890).replace(/(?=(\B)(\d{3})+$)/g, ',')
=&gt; 1,234,567,890
// 式二
String(1234567890).replace(/(?=(\w)(\d{3})+$)/g, ',')
=&gt; ,123,456,7890
// 附加常用例子，20180911格式化为2018-09-11
'20180911'.replace(/(?=\B(\d{2})+$)/g, '-').replace(/-/, '')
=&gt;2018-09-11
</code></pre>
<p>造成差异的原因就是:<br>
式一中的 <code>\B</code> 匹配边界（是断言）。第一次匹配时，在 1234567890 中数字 1 的前方时，会环视后方进行肯定断言<code>(?=)</code>：后方必须是满足两个 pattern 才通过。第一个 pattern <code>(\B)</code>在数字 1 的前方匹配成功；故继续在此位置匹配第二个 pattern <code>(\d{3})+$</code>，发现 123456789 之后并不是结束符（结束符和开始符也是断言，下文讲述），故匹配失败。开始第二次匹配，从数字 1 和数字 2 的中间开始...最后会匹配成功三个位置：1 和 2 之间、4 和 5 之间、7 和 8 之间，再被,替换，故得到结果。</p>
<p>同理，式二在第一次匹配时，在数字 1 的前方环视后方进行肯定断言：后方必须是满足两个 pattern 才通过。第一个 pattern <code>(\w)</code> 在数字 1 的前方匹配成功，并将匹配位置移动到 1 和 2 之间；然后继续匹配第二个pattern <code>(\d{3})+$</code>...第一次匹配成功，故数字 1 前方的断言是成功的，标记该位置...最后得到三个位置：1 前方、3 和 4 之间、6 和 7 之间，再被,替换，故得到结果。</p>
<p>所以 <code>\B</code> 只是去判断该位置左右是否只有一边有单词字符，另一边不是单词字符，且在匹配成功时，不会导致匹配位置发生改变。说起来算是一种判断吧~</p>
<p>这种只是匹配某个位置而不是文本的元字符，在正则中也被称为<strong>锚点</strong>。下文继续介绍常见锚点之二：行起始/结束位置。</p>
<h1 id="行起始结束位置">行起始/结束位置</h1>
<p><code>^</code> 与 <code>$</code> 分别表示（行）起始位置和（行）结束位置，比如正则表达式 <code>/^lu.*r$/</code> 只能匹配的 lu 开始并以 r 结束的字符串，例如：luwuer、lu fd --r，不能匹配 nb luwuer、lu fd --rb等。</p>
<p>其实行起始/结束位置断言，常用在正则表达式开启<strong>多行模式</strong>（Multiline Mode）的情况下。<br>
例如：</p>
<pre><code class="language-javascript">('first line\nsecond line\nlast line').match(/^\w+/gm)
return [&quot;first&quot;, &quot;second&quot;, &quot;last&quot;]
</code></pre>
<p>既然是多行匹配，这里说说如何划分<strong>行</strong>。</p>
<p>在编辑文本时，敲回车键就向文本输入了<strong>行终止符</strong>（line terminal），表示结束当前行。这里只需注意，敲入回车时向文本中输入的行终止符在主流平台上是有差别的：</p>
<ul>
<li>Windows 的行终止符是 <code>\r\n</code>。</li>
<li>UNIX/Linux/Mac OS 的行终止符是 <code>\n</code>。</li>
</ul>
<p>不过正则的行起始/结束位置断言都是可以识别的哈~</p>
<h1 id="环视">环视</h1>
<p>环视是指在某个位置向左/向右看，保证其左/右位置必须出现某类字符（包括单词字符 <code>\w</code> 和非单词字符<code>\W</code>），且环视也同上两个断言，只是做一个判断（匹配一个位置，本身不匹配任何字符，但又比上两个断言灵活）。也有人称环视为<strong>零宽断言</strong>。</p>
<p>环视分为四种：</p>
<ul>
<li><strong>肯定顺序</strong>环视（正向肯定断言）positive-lookahead: <code>?=pattern</code>；</li>
<li><strong>否定顺序</strong>环视（正向否定断言）negative-lookahead: <code>?!pattern</code>；</li>
<li><strong>肯定逆序</strong>环视（反向肯定断言）positive-lookahead: <code>?&lt;=pattern</code>，js不支持；</li>
<li><strong>否定逆序</strong>环视（反向否定断言）negative-lookahead: <code>?&lt;=pattern</code>，js不支持。</li>
</ul>
<p>比如我们要匹配一串文字中包含在书名号《》中的书名，如不考虑环视可能需要如下实现：</p>
<pre><code class="language-javascript">('三体是刘慈欣创作的系列长篇科幻小说，由《三体》、《三体Ⅱ·黑暗森林》、《三体Ⅲ·死神永生》组成。').match(/《.*?》/g).join(',').replace(/[《》]/g, '').split(',')
return [&quot;三体&quot;, &quot;三体Ⅱ·黑暗森林&quot;, &quot;三体Ⅲ·死神永生&quot;]
</code></pre>
<p><em>正则默认是贪婪模式（在整个表达式匹配成功的前提下，尽可能多的匹配），开启非贪婪模式（在整个表达式匹配成功的前提下，尽可能少的匹配）的方法：在贪婪量词 <code>{m,n}</code>、<code>{m,}</code>、<code>?</code>、<code>*</code>、<code>+</code> 后加上一个 <code>?</code> 号，例如 <code>+?</code>。</em><br>
而在使用环视时会更简单：</p>
<pre><code class="language-javascript">('三体是刘慈欣创作的系列长篇科幻小说，由《三体》、《三体Ⅱ·黑暗森林》、《三体Ⅲ·死神永生》组成。').replace(/《/g,'\n').match(/^.*?(?=》)/gm)
return [&quot;三体&quot;, &quot;三体Ⅱ·黑暗森林&quot;, &quot;三体Ⅲ·死神永生&quot;]
</code></pre>
<p>似乎也没简单多少...当然最主要的原因是js不支持逆序环视啦啦啦</p>
<p>再举例，匹配6位数字构成的字符串：</p>
<pre><code class="language-javascript">// 无环视
'http://luwuer.com/629212/1234567890'.match(/[^\d]\d{6}[^\d]/g).join('').match(/\d{6}/g)
return [&quot;629212&quot;]
// 环视
'http://luwuer.com/629212/1234567890'.match(/(?!\d).\d{6}(?!\d)/g).join('').match(/\d{6}/g)
return [&quot;629212&quot;]
</code></pre>
<p>其实环视在js中更多的是与replace函数组合，就像在单词边界一节中最后的例子。</p>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#%E5%8D%95%E8%AF%8D%E8%BE%B9%E7%95%8C">单词边界</a></li>
<li><a href="#%E8%A1%8C%E8%B5%B7%E5%A7%8B%E7%BB%93%E6%9D%9F%E4%BD%8D%E7%BD%AE">行起始/结束位置</a></li>
<li><a href="#%E7%8E%AF%E8%A7%86">环视</a></li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://tdmaker.github.io/faded/post/jquery-extension/">
              <h3 class="post-title">
                jQuery——拓展
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://tdmaker.github.io/faded//atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
