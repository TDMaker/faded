<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>正则表达式——简介 | Typhoeus</title>
<link rel="shortcut icon" href="https://tdmaker.github.io/faded//favicon.ico?v=1586081912249">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://tdmaker.github.io/faded//styles/main.css">
<link rel="alternate" type="application/atom+xml" title="正则表达式——简介 | Typhoeus - Atom Feed" href="https://tdmaker.github.io/faded//atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="在自然语言处理中，很多时候我们都需要从文本或字符串中抽取出想要的信息，并进一步做语义理解或其它处理。
常用正则表达式网站

Regex Dictionary https://visca.com/regexdict/
RegExr https..." />
    <meta name="keywords" content="" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://tdmaker.github.io/faded/">
  <img class="avatar" src="https://tdmaker.github.io/faded//images/avatar.png?v=1586081912249" alt="">
  </a>
  <h1 class="site-title">
    Typhoeus
  </h1>
  <p class="site-description">
    温故而知新
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              正则表达式——简介
            </h2>
            <div class="post-info">
              <span>
                2020-04-02
              </span>
              <span>
                7 min read
              </span>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <p>在自然语言处理中，很多时候我们都需要从文本或字符串中抽取出想要的信息，并进一步做语义理解或其它处理。</p>
<h1 id="常用正则表达式网站">常用正则表达式网站</h1>
<ul>
<li>Regex Dictionary <a href="https://visca.com/regexdict/">https://visca.com/regexdict/</a></li>
<li>RegExr <a href="https://regexr.com/">https://regexr.com/</a></li>
<li>RegExper <a href="https://regexper.com/">https://regexper.com/</a></li>
<li>Regular Expressions 101 <a href="https://regex101.com/">https://regex101.com/</a></li>
</ul>
<!-- more -->
<h1 id="基本语句">基本语句</h1>
<h2 id="锚点-和">♍锚点：<code>^</code> 和 <code>$</code></h2>
<ul>
<li><code>^The</code> 匹配任何以“The”开头的字符串。</li>
<li><code>end$</code> 匹配以“end”为结尾的字符串。</li>
<li><code>^The end$</code> 匹配从“The”开始到“end”结束的字符串。</li>
<li><code>roar</code> 匹配任何带有文本“roar”的字符串。</li>
</ul>
<h2 id="数量符-和-和-和">♍数量符：<code>*</code> 和 <code>+</code> 和 <code>?</code> 和 <code>{}</code></h2>
<ul>
<li><code>abc*</code> 匹配在“ab”后面跟着 0 个或多个“c”的字符串。</li>
<li><code>abc+</code> 匹配在“ab”后面跟着 1 个或多个“c”的字符串。</li>
<li><code>abc?</code> 匹配在“ab”后面跟着 0 个或 1 个“c”的字符串。</li>
<li><code>abc{2}</code> 匹配在“ab”后面跟着 2 个“c”的字符串。</li>
<li><code>abc{2,}</code> 匹配在“ab”后面跟着 2 个或更多“c”的字符串。</li>
<li><code>abc{2,5}</code> 匹配在“ab”后面跟着 2 到 5 个“c”的字符串。</li>
<li><code>a(bc)*</code> 匹配在“a”后面跟着 0 个或更多“bc”序列的字符串。</li>
<li><code>a(bc){2,5}</code> 匹配在“a”后面跟着 2 到 5 个“bc”序列的字符串。</li>
</ul>
<h2 id="或运算符-和">♍或运算符：<code>|</code> 和 <code>[]</code></h2>
<ul>
<li><code>a(b|c)</code> 匹配在“a”后面跟着“b”或“c”的字符串。</li>
<li><code>a[bc]</code> 匹配在“a”后面跟着“b”或“c”的字符串。</li>
</ul>
<h2 id="字符类d-和-w-和-s-和">♍字符类：<code>\d</code> 和 <code>\w</code> 和 <code>\s</code> 和 <code>.</code></h2>
<ul>
<li><code>\d</code> 匹配数字型的单个字符。</li>
<li><code>\w</code> 匹配单个词字（字母加下划线）。</li>
<li><code>\s</code> 匹配单个空格字符（包括制表符和换行符）。</li>
<li><code>.</code> 匹配任意字符。</li>
</ul>
<p>使用 <code>.</code> 运算符需要非常小心，因为常见类或排除型字符类都要更快与精确。<code>\d</code>、<code>\w</code> 和 <code>\s</code> 同样有它们各自的排除型字符类，即 <code>\D</code>、<code>\W</code> 和 <code>\S</code>。例如 <code>\D</code> 将执行与 <code>\d</code> 完全相反的匹配方法：</p>
<ul>
<li><code>\D</code> 匹配单个非数字型的字符。</li>
</ul>
<p>为了正确地匹配，我们必须使用转义符反斜杠 <code>\</code> 定义我们需要匹配的符号 <code>^.[$()|*+?{\</code>，因为我们可能认为这些符号在原文本中有特殊的含义。</p>
<ul>
<li><code>\$\d</code> 匹配在单个数字前有符号“$”的字符串。</li>
</ul>
<p>注意我们同样能匹配 <em>non-printable</em> 字符，例如 Tab 符 <code>\t</code>、换行符 <code>\n</code> 和回车符 <code>\r</code>。</p>
<h2 id="flags">♍Flags</h2>
<p>模式的结尾我们通常可以指定以下 flag 配置或它们的组合：</p>
<ul>
<li><code>g</code>（global）在第一次完成匹配后并不会返回结果，它会继续搜索剩下的文本。</li>
<li><code>m</code>（multi line）允许使用^和$匹配一行的开始和结尾，而不是整个序列。</li>
<li><code>i</code>（insensitive）令整个表达式不区分大小写（例如/aBc/i 将匹配 AbC）。</li>
</ul>
<h1 id="中级语句">中级语句</h1>
<h2 id="分组和捕获">♍分组和捕获：<code>()</code></h2>
<ul>
<li><code>a(bc)</code> 圆括弧会创建一个捕获性分组，它会捕获匹配项“bc”。</li>
<li><code>a(?:bc)*</code> 使用“<code>?:</code> ”会使捕获分组失效，只需要匹配前面的“a”。</li>
<li><code>a(?&lt;foo&gt;bc)</code> 使用“<code>?&lt;foo&gt;</code>”会为分组配置一个名称 。</li>
</ul>
<p>捕获性圆括号 <code>()</code> 和非捕获性圆括弧 <code>(?:)</code> 对于从字符串或数据中抽取信息非常重要，我们可以使用 Python 等不同的编程语言实现这一功能。从多个分组中捕获的多个匹配项将以经典的数组形式展示：我们可以使用匹配结果的索引访问它们的值。如果需要为分组添加名称（使用 <code>(?&lt;foo&gt;...)</code>），我们就能如字典那样使用匹配结果检索分组的值，其中字典的键为分组的名称。</p>
<h2 id="方括弧表达式">♍方括弧表达式：<code>[]</code></h2>
<ul>
<li><code>[abc]</code> 匹配带有一个“a”、“ab”或“ac”的字符串。</li>
<li><code>[a-c]</code> 匹配带有一个“a”、“ab”或“ac”的字符串。</li>
<li><code>[a-fA-F0-9]</code> 匹配一个代表 16 进制数字的字符串，不区分大小写。</li>
<li><code>[0-9]%</code> 匹配在 <code>%</code> 符号前面带有 0 到 9 这几个字符的字符串。</li>
<li><code>[^a-zA-Z]</code> 匹配不带 a 到 z 或 A 到 Z 的字符串，其中 <code>^</code> 为否定表达式。</li>
</ul>
<p>记住在方括弧内，所有特殊字符（包括反斜杠 <code>\</code> ）都会失去它们应有的意义。</p>
<h2 id="greedy-和-lazy-匹配">♍Greedy 和 Lazy 匹配</h2>
<p>数量符（<code>* + {}</code>）是一种贪心运算符，所以它们会遍历给定的文本，并尽可能匹配。例如，<code>&lt;.+&gt;</code> 可以匹配文本 “<strong>This is a &lt;div&gt; simple div&lt;/div&gt; test</strong>” 中的 “<strong>&lt;div&gt;simple div&lt;/div&gt;&quot;</strong>。为了仅捕获 <strong>div</strong> 标签，我们需要使用 <code>?</code> 令贪心搜索变得 Lazy 一点：</p>
<ul>
<li><code>&lt;.+?&gt;</code>  一次或多次匹配“<code>&lt;</code>”和“<code>&gt;</code>”里面的任何字符，可按需扩展。</li>
</ul>
<p>注意更好的解决方案应该需要避免使用 <code>.</code>，这有利于实现更严格的正则表达式：</p>
<ul>
<li><code>&lt;[^&lt;&gt;]+&gt;</code> 一次或多次匹配“<code>&lt;</code>”和“<code>&gt;</code>”里面的任何字符，除去“<code>&lt;</code>”或“<code>&gt;</code>”字符。</li>
</ul>
<h1 id="高级语句">高级语句</h1>
<h2 id="边界符b-和-b">♍边界符：<code>\b</code> 和 <code>\B</code></h2>
<ul>
<li><code>\babc\b</code> 执行整词匹配搜索。</li>
</ul>
<p><code>\b</code> 如插入符号那样表示一个锚点（它与 <code>$</code> 和 <code>^</code> 相同）来匹配位置，其中一边是一个单词符号（如 <code>\w</code>），另一边不是单词符号（例如它可能是字符串的起始点或空格符号）。<br>
它同样能表达相反的非单词边界 <code>\B</code>，它会匹配 <code>\b</code> 不会匹配的位置，如果我们希望找到被单词字符环绕的搜索模式，就可以使用它。</p>
<ul>
<li><code>\Babc\B</code> 只要是被单词字符环绕的模式就会匹配。</li>
</ul>
<h2 id="前向匹配和后向匹配-和">♍前向匹配和后向匹配：<code>(?=)</code> 和 <code>(?&lt;=)</code></h2>
<ul>
<li><code>d(?=r)</code> 只有在后面跟着“r”的时候才匹配“d”，但是“r”并不会成为整个正则表达式匹配的一部分。</li>
<li><code>(?&lt;=r)d</code> 只有在前面跟着“r”时才匹配“d”，但是“r”并不会成为整个正则表达式匹配的一部分。</li>
</ul>
<p>我们同样能使用否定运算子：</p>
<ul>
<li><code>d(?!r)</code> 只有在后面不跟着“r”的时候才匹配“d”，但是“r”并不会成为整个正则表达式匹配的一部分。</li>
<li><code>(?&lt;!r)d</code> 只有在前面不跟着“r”时才匹配“d”，但是“r”并不会成为整个正则表达式匹配的一部分。</li>
</ul>
<h1 id="结语">结语</h1>
<p>正如上文所示，正则表达式的应用领域非常广，很可能各位读者在开发的过程中已经遇到了它，下面是正则表达式常用的领域：</p>
<ul>
<li>数据验证，例如检查时间字符串是否符合格式；</li>
<li>数据抓取，以特定顺序抓取包含特定文本或内容的网页；</li>
<li>数据包装，将数据从某种原格式转换为另外一种格式；</li>
<li>字符串解析，例如捕获所拥有 URL 的 GET 参数，或捕获一组圆括弧内的文本；</li>
<li>字符串替代，将字符串中的某个字符替换为其它字符。</li>
</ul>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%BD%91%E7%AB%99">常用正则表达式网站</a></li>
<li><a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E5%8F%A5">基本语句</a>
<ul>
<li><a href="#%E9%94%9A%E7%82%B9-%E5%92%8C">♍锚点：<code>^</code> 和 <code>$</code></a></li>
<li><a href="#%E6%95%B0%E9%87%8F%E7%AC%A6-%E5%92%8C-%E5%92%8C-%E5%92%8C">♍数量符：<code>*</code> 和 <code>+</code> 和 <code>?</code> 和 <code>{}</code></a></li>
<li><a href="#%E6%88%96%E8%BF%90%E7%AE%97%E7%AC%A6-%E5%92%8C">♍或运算符：<code>|</code> 和 <code>[]</code></a></li>
<li><a href="#%E5%AD%97%E7%AC%A6%E7%B1%BBd-%E5%92%8C-w-%E5%92%8C-s-%E5%92%8C">♍字符类：<code>\d</code> 和 <code>\w</code> 和 <code>\s</code> 和 <code>.</code></a></li>
<li><a href="#flags">♍Flags</a></li>
</ul>
</li>
<li><a href="#%E4%B8%AD%E7%BA%A7%E8%AF%AD%E5%8F%A5">中级语句</a>
<ul>
<li><a href="#%E5%88%86%E7%BB%84%E5%92%8C%E6%8D%95%E8%8E%B7">♍分组和捕获：<code>()</code></a></li>
<li><a href="#%E6%96%B9%E6%8B%AC%E5%BC%A7%E8%A1%A8%E8%BE%BE%E5%BC%8F">♍方括弧表达式：<code>[]</code></a></li>
<li><a href="#greedy-%E5%92%8C-lazy-%E5%8C%B9%E9%85%8D">♍Greedy 和 Lazy 匹配</a></li>
</ul>
</li>
<li><a href="#%E9%AB%98%E7%BA%A7%E8%AF%AD%E5%8F%A5">高级语句</a>
<ul>
<li><a href="#%E8%BE%B9%E7%95%8C%E7%AC%A6b-%E5%92%8C-b">♍边界符：<code>\b</code> 和 <code>\B</code></a></li>
<li><a href="#%E5%89%8D%E5%90%91%E5%8C%B9%E9%85%8D%E5%92%8C%E5%90%8E%E5%90%91%E5%8C%B9%E9%85%8D-%E5%92%8C">♍前向匹配和后向匹配：<code>(?=)</code> 和 <code>(?&lt;=)</code></a></li>
</ul>
</li>
<li><a href="#%E7%BB%93%E8%AF%AD">结语</a></li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://tdmaker.github.io/faded/post/you-qu-de-wang-zhan/">
              <h3 class="post-title">
                有趣的网站
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://tdmaker.github.io/faded//atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
